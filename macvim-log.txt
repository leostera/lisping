
chdir(/Applications/MacVim.app/Contents/Resources/vim)
fchdir() to previous dir
sourcing "$VIM/vimrc"
line 1: " System vimrc file for MacVim
line 2: "
line 3: " Maintainer:^IBjorn Winckler <bjorn.winckler@gmail.com>
line 4: " Last Change:^ISat Aug 29 2009
line 5: 
line 6: set nocompatible
line 7: 
line 8: " The default for 'backspace' is very confusing to new users, so change it to a
line 9: " more sensible value.  Add "set backspace&" to your ~/.vimrc to reset it.
line 10: set backspace+=indent,eol,start
line 11: 
line 12: " Disable localized menus for now since only some items are translated (e.g.
line 13: " the entire MacVim menu is set up in a nib file which currently only is
line 14: " translated to English).
line 15: set langmenu=none
finished sourcing $VIM/vimrc
chdir(/Users/leostera)
fchdir() to previous dir
sourcing "$HOME/.vimrc"
line 1: set nocompatible              " be iMproved
line 2: filetype off                  " required!
Searching for "ftoff.vim" in "/Users/leostera/.vim,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after"
Searching for "/Users/leostera/.vim/ftoff.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftoff.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 2: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
Error detected while processing /Applications/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim:
line   11:
E216: No such group or event: filetypedetect *
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim
continuing in /Users/leostera/.vimrc
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/ftoff.vim"
Searching for "/Users/leostera/.vim/after/ftoff.vim"
line 3: 
line 4: set rtp+=~/.vim/bundle/Vundle.vim
line 5: set rtp+=~/.vim/bundle/powerline/powerline/bindings/vim
line 6: call vundle#rc()
Searching for "autoload/vundle.vim" in "/Users/leostera/.vim,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim"
Searching for "/Users/leostera/.vim/autoload/vundle.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/autoload/vundle.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/autoload/vundle.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/autoload/vundle.vim"
Searching for "/Users/leostera/.vim/after/autoload/vundle.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/autoload/vundle.vim"
chdir(/Users/leostera/.vim/bundle/Vundle.vim/autoload)
fchdir() to previous dir
line 6: sourcing "/Users/leostera/.vim/bundle/Vundle.vim/autoload/vundle.vim"
line 1: " Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim
line 2: " Author:       gmarik
line 3: " HomePage:     http://github.com/gmarik/Vundle.vim
line 4: " Readme:       http://github.com/gmarik/Vundle.vim/blob/master/README.md
line 5: " Version:      0.10.2
line 6: 
line 7: " Plugin Commands
line 9: com! -nargs=+  -bar   Plugin call vundle#config#bundle(<args>)
line 10: 
line 12: com! -nargs=? -bang -complete=custom,vundle#scripts#complete PluginInstall call vundle#installer#new('!' == '<bang>', <q-args>)
line 13: 
line 15: com! -nargs=? -bang -complete=custom,vundle#scripts#complete PluginSearch call vundle#scripts#all('!' == '<bang>', <q-args>)
line 16: 
line 18: com! -nargs=0 -bang PluginList call vundle#installer#list('!' == '<bang>')
line 19: 
line 21: com! -nargs=? -bang   PluginClean call vundle#installer#clean('!' == '<bang>')
line 22: 
line 24: com! -nargs=0         PluginDocs call vundle#installer#helptags(g:bundles)
line 25: 
line 26: " Aliases
line 27: com! PluginUpdate PluginInstall!
line 28: 
line 29: " Vundle Aliases
line 30: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleInstall PluginInstall<bang> <args>
line 31: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleSearch  PluginSearch<bang> <args>
line 32: com! -nargs=? -bang                                          VundleClean   PluginClean<bang>
line 33: com! -nargs=0                                                VundleDocs    PluginDocs
line 34: com!                                                         VundleUpdate  PluginInstall!
line 35: 
line 36: " Deprecated Commands
line 37: com! -nargs=+                                                Bundle        call vundle#config#bundle(<args>)
line 38: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall PluginInstall<bang> <args>
line 39: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch  PluginSearch<bang> <args>
line 40: com! -nargs=0 -bang                                          BundleList    PluginList<bang>
line 41: com! -nargs=? -bang                                          BundleClean   PluginClean<bang>
line 42: com! -nargs=0                                                BundleDocs    PluginDocs
line 43: com!                                                         BundleUpdate  PluginInstall!
line 44: 
line 45: " Set up the signs used in the installer window. (See :help signs)
line 46: if (has('signs'))
line 47:   sign define Vu_error    text=!  texthl=Error
line 48:   sign define Vu_active   text=>  texthl=Comment
line 49:   sign define Vu_todate   text=.  texthl=Comment
line 50:   sign define Vu_new      text=+  texthl=Comment
line 51:   sign define Vu_updated  text=*  texthl=Comment
line 52:   sign define Vu_deleted  text=-  texthl=Comment
line 53:   sign define Vu_helptags text=*  texthl=Comment
line 54:   sign define Vu_pinned   text==  texthl=Comment
line 55: endif
line 56: 
line 57: " Set up Vundle.  This function has to be called from the users vimrc file.
line 58: " This will force Vim to source this file as a side effect which wil define
line 59: " the :Plugin command.  After calling this function the user can use the
line 60: " :Plugin command in the vimrc.  It is not possible to do this automatically
line 61: " because when loading the vimrc file no plugins where loaded yet.
line 62: func! vundle#rc(...) abort
line 69: 
line 70: " Alternative to vundle#rc, offers speed up by modifying rtp only when end()
line 71: " called later.
line 72: func! vundle#begin(...) abort
line 76: 
line 77: " Finishes putting plugins on the rtp.
line 78: func! vundle#end(...) abort
line 82: 
line 83: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:
finished sourcing /Users/leostera/.vim/bundle/Vundle.vim/autoload/vundle.vim
continuing in /Users/leostera/.vimrc
calling function vundle#rc()

line 1:   let g:bundle_dir = len(a:000) > 0 ? expand(a:1, 1) : expand('$HOME/.vim/bundle', 1)
line 2:   let g:updated_bundles = []
line 3:   let g:vundle_log = []
line 4:   let g:vundle_changelog = ['Updated Plugins:']
line 5:   call vundle#config#init()
Searching for "autoload/vundle/config.vim" in "/Users/leostera/.vim,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim"
Searching for "/Users/leostera/.vim/autoload/vundle/config.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/autoload/vundle/config.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/autoload/vundle/config.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/autoload/vundle/config.vim"
Searching for "/Users/leostera/.vim/after/autoload/vundle/config.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"
chdir(/Users/leostera/.vim/bundle/Vundle.vim/autoload/vundle)
fchdir() to previous dir
line 5: sourcing "/Users/leostera/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"
line 1: " ---------------------------------------------------------------------------
line 2: " Add a plugin to the runtimepath.
line 3: "
line 4: " arg    -- a string specifying the plugin
line 5: " ...    -- a dictionary of options for the plugin
line 6: " return -- the return value from vundle#config#init_bundle()
line 7: " ---------------------------------------------------------------------------
line 8: func! vundle#config#bundle(arg, ...)
line 23: 
line 24: 
line 25: " ---------------------------------------------------------------------------
line 26: "  When lazy bundle load is used (begin/end functions), add all configured
line 27: "  bundles to runtimepath and reorder appropriately.
line 28: " ---------------------------------------------------------------------------
line 29: func! vundle#config#activate_bundles()
line 33: 
line 34: 
line 35: " ---------------------------------------------------------------------------
line 36: " Initialize Vundle.
line 37: "
line 38: " Start a new bundles list and make sure the runtimepath does not contain
line 39: " directories from a previous call. In theory, this should only be called
line 40: " once.
line 41: " ---------------------------------------------------------------------------
line 42: func! vundle#config#init()
line 48: 
line 49: 
line 50: " ---------------------------------------------------------------------------
line 51: " Add a list of bundles to the runtimepath and source them.
line 52: "
line 53: " bundles -- a list of bundle objects
line 54: " ---------------------------------------------------------------------------
line 55: func! vundle#config#require(bundles) abort
line 66: 
line 67: 
line 68: " ---------------------------------------------------------------------------
line 69: " Create a bundle object from a bundle specification.
line 70: "
line 71: " name   -- the bundle specification as a string
line 72: " opts   -- the options dictionary from then bundle definition
line 73: " return -- an initialized bundle object
line 74: " ---------------------------------------------------------------------------
line 75: func! vundle#config#init_bundle(name, opts)
line 84: 
line 85: 
line 86: " ---------------------------------------------------------------------------
line 87: " Check if the current bundle name has already been used in this running
line 88: " instance and show an error to that effect.
line 89: "
line 90: " bundle -- a bundle object whose name is to be checked
line 91: " return -- 0 if the bundle's name has been seen before, 1 otherwise
line 92: " ---------------------------------------------------------------------------
line 93: funct! s:check_bundle_name(bundle)
line 104: 
line 105: 
line 106: " ---------------------------------------------------------------------------
line 107: " Parse the options which can be supplied with the bundle specification.
line 108: " Corresponding documentation: vundle-plugins-configure
line 109: "
line 110: " opts   -- a dictionary with the user supplied options for the bundle
line 111: " return -- a dictionary with the user supplied options for the bundle, this
line 112: "           will be merged with a s:bundle object into one dictionary.
line 113: " ---------------------------------------------------------------------------
line 114: func! s:parse_options(opts)
line 124: 
line 125: 
line 126: " ---------------------------------------------------------------------------
line 127: " Parse the plugin specification.  Corresponding documentation:
line 128: " vundle-plugins-uris
line 129: "
line 130: " arg    -- the string supplied to identify the plugin
line 131: " return -- a dictionary with the folder name (key 'name') and the uri (key
line 132: "           'uri') for cloning the plugin  and the original argument (key
line 133: "           'name_spec')
line 134: " ---------------------------------------------------------------------------
line 135: func! s:parse_name(arg)
line 157: 
line 158: 
line 159: " ---------------------------------------------------------------------------
line 160: "  Modify the runtimepath, after all bundles have been added, so that the
line 161: "  directories that were in the default runtimepath appear first in the list
line 162: "  (with their 'after' directories last).
line 163: " ---------------------------------------------------------------------------
line 164: func! s:rtp_add_defaults()
line 176: 
line 177: 
line 178: " ---------------------------------------------------------------------------
line 179: " Remove all paths for the plugins which are managed by Vundle from the
line 180: " runtimepath.
line 181: " ---------------------------------------------------------------------------
line 182: func! s:rtp_rm_a()
line 189: 
line 190: 
line 191: " ---------------------------------------------------------------------------
line 192: " Add all paths for the plugins which are managed by Vundle to the
line 193: " runtimepath.
line 194: " ---------------------------------------------------------------------------
line 195: func! s:rtp_add_a()
line 202: 
line 203: 
line 204: " ---------------------------------------------------------------------------
line 205: " Remove a directory and the corresponding 'after' directory from runtimepath.
line 206: "
line 207: " dir    -- the directory name to be removed as a string.  The corresponding
line 208: "           'after' directory will also be removed.
line 209: " ---------------------------------------------------------------------------
line 210: func! s:rtp_rm(dir) abort
line 214: 
line 215: 
line 216: " ---------------------------------------------------------------------------
line 217: " Add a directory and the corresponding 'after' directory to runtimepath.
line 218: "
line 219: " dir    -- the directory name to be added as a string.  The corresponding
line 220: "           'after' directory will also be added.
line 221: " ---------------------------------------------------------------------------
line 222: func! s:rtp_add(dir) abort
line 226: 
line 227: 
line 228: " ---------------------------------------------------------------------------
line 229: " Expand and simplify a path.
line 230: "
line 231: " path   -- the path to expand as a string
line 232: " return -- the expanded and simplified path
line 233: " ---------------------------------------------------------------------------
line 234: func! s:expand_path(path) abort
line 237: 
line 238: 
line 239: " ---------------------------------------------------------------------------
line 240: " Find the actual path inside a bundle directory to be added to the
line 241: " runtimepath.  It might be provided by the user with the 'rtp' option.
line 242: " Corresponding documentation: vundle-plugins-configure
line 243: "
line 244: " opts   -- a bundle dict
line 245: " return -- expanded path to the corresponding plugin directory
line 246: " ---------------------------------------------------------------------------
line 247: func! s:rtpath(opts)
line 250: 
line 251: 
line 252: " ---------------------------------------------------------------------------
line 253: " a bundle 'object'
line 254: " ---------------------------------------------------------------------------
line 255: let s:bundle = {}
line 256: 
line 257: 
line 258: " ---------------------------------------------------------------------------
line 259: " Return the absolute path to the directory inside the bundle directory
line 260: " (prefix) where thr bundle will be cloned.
line 261: "
line 262: " return -- the target location to clone this bundle to
line 263: " ---------------------------------------------------------------------------
line 264: func! s:bundle.path()
line 267: 
line 268: 
line 269: " ---------------------------------------------------------------------------
line 270: "  Determine if the bundle has the pinned attribute set in the config
line 271: "
line 272: "  return -- 1 if the bundle is pinned, 0 otherwise
line 273: " ---------------------------------------------------------------------------
line 274: func! s:bundle.is_pinned()
line 277: 
line 278: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:
finished sourcing /Users/leostera/.vim/bundle/Vundle.vim/autoload/vundle/config.vim
continuing in function vundle#rc
calling function vundle#rc..vundle#config#init()

line 1:   if !exists('g:bundles') | let g:bundles = [] | endif
line 1:  let g:bundles = [] | endif
line 1:  endif
line 2:   call s:rtp_rm_a()
calling function vundle#rc..vundle#config#init..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/after
function vundle#rc..vundle#config#init..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#rc..vundle#config#init

line 3:   let g:bundles = []
line 4:   let g:bundle_names = {}
function vundle#rc..vundle#config#init returning #0

continuing in function vundle#rc

function vundle#rc returning #0

continuing in /Users/leostera/.vimrc

line 7: 
line 8: " let Vundle manage Vundle
line 9: Bundle 'gmarik/vundle'
line 9: call vundle#config#bundle('gmarik/vundle')
calling function vundle#config#bundle('gmarik/vundle')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('gmarik/vundle', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('gmarik/vundle')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/gmarik/vu... 'vundle', 'name_spec': 'gmarik/vundle'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 10: 
line 11: " Language bundles
line 12: Bundle 'mustache/vim-mustache-handlebars'
line 12: call vundle#config#bundle('mustache/vim-mustache-handlebars')
calling function vundle#config#bundle('mustache/vim-mustache-handlebars')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('mustache/vim-mustache-handlebars', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('mustache/vim-mustache-handlebars')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/mustache/...ec': 'mustache/vim-mustache-handlebars'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/mustache/...ache-handlebars', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vim-mustache-handlebars')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vim-mustache-handlebars'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vim-mustache-handlebars'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vim-mustache-handlebars'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/mustache/...ache-handlebars', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/mustache/...ache-handlebars', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/mustache/...ache-handlebars', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 13: Bundle 'pangloss/vim-javascript'
line 13: call vundle#config#bundle('pangloss/vim-javascript')
calling function vundle#config#bundle('pangloss/vim-javascript')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('pangloss/vim-javascript', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('pangloss/vim-javascript')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/pangloss/... 'name_spec': 'pangloss/vim-javascript'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/pangloss/.../vim-javascript', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vim-javascript')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vim-javascript'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vim-javascript'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vim-javascript'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/pangloss/.../vim-javascript', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/pangloss/.../vim-javascript', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/pangloss/.../vim-javascript', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 14: Bundle 'mattn/emmet-vim'
line 14: call vundle#config#bundle('mattn/emmet-vim')
calling function vundle#config#bundle('mattn/emmet-vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('mattn/emmet-vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('mattn/emmet-vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/mattn/emm...et-vim', 'name_spec': 'mattn/emmet-vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/mattn/emm...mattn/emmet-vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/emmet-vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/emmet-vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/emmet-vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/emmet-vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/mattn/emm...mattn/emmet-vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/mattn/emm...mattn/emmet-vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/mattn/emm...mattn/emmet-vim', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 15: 
line 16: au BufRead,BufNewFile *.es6 setfiletype javascript
line 17: au BufRead,BufNewFile *.es6.erb setfiletype javascript
line 18: au BufRead,BufNewFile dispatch.conf setfiletype erlang
line 19: 
line 20: " General programming bundles
line 21: Bundle 'nathanaelkane/vim-indent-guides'
line 21: call vundle#config#bundle('nathanaelkane/vim-indent-guides')
calling function vundle#config#bundle('nathanaelkane/vim-indent-guides')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('nathanaelkane/vim-indent-guides', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('nathanaelkane/vim-indent-guides')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/nathanael...pec': 'nathanaelkane/vim-indent-guides'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/nathanael...m-indent-guides', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vim-indent-guides')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vim-indent-guides'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vim-indent-guides'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vim-indent-guides'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/nathanael...m-indent-guides', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/nathanael...m-indent-guides', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/nathanael...m-indent-guides', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 22: 
line 23: Bundle 'scrooloose/syntastic'
line 23: call vundle#config#bundle('scrooloose/syntastic')
calling function vundle#config#bundle('scrooloose/syntastic')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('scrooloose/syntastic', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('scrooloose/syntastic')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/scrooloos...c', 'name_spec': 'scrooloose/syntastic'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/scrooloos...loose/syntastic', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/syntastic')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/scrooloos...loose/syntastic', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/scrooloos...loose/syntastic', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/scrooloos...loose/syntastic', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 24: let g:syntastic_check_on_open=1
line 25: 
line 26: let g:ycm_add_preview_to_completeopt=0
line 27: let g:ycm_confirm_extra_conf=0
line 28: set completeopt-=preview
line 29: 
line 30: Bundle 'tpope/vim-surround'
line 30: call vundle#config#bundle('tpope/vim-surround')
calling function vundle#config#bundle('tpope/vim-surround')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('tpope/vim-surround', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('tpope/vim-surround')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/tpope/vim...und', 'name_spec': 'tpope/vim-surround'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/tpope/vim...pe/vim-surround', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vim-surround')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vim-surround'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vim-surround'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vim-surround'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-surround', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/tpope/vim...pe/vim-surround', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-surround', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 31: 
line 32: " Git bundles
line 33: Bundle 'tpope/vim-fugitive'
line 33: call vundle#config#bundle('tpope/vim-fugitive')
calling function vundle#config#bundle('tpope/vim-fugitive')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('tpope/vim-fugitive', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('tpope/vim-fugitive')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/tpope/vim...ive', 'name_spec': 'tpope/vim-fugitive'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vim-fugitive')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 34: Bundle 'airblade/vim-gitgutter'
line 34: call vundle#config#bundle('airblade/vim-gitgutter')
calling function vundle#config#bundle('airblade/vim-gitgutter')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('airblade/vim-gitgutter', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('airblade/vim-gitgutter')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/airblade/..., 'name_spec': 'airblade/vim-gitgutter'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/airblade/...e/vim-gitgutter', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vim-gitgutter')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vim-gitgutter'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vim-gitgutter'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vim-gitgutter'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/airblade/...e/vim-gitgutter', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/airblade/...e/vim-gitgutter', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after,/Users/leostera/.vim/bundle/vim-gitgutter/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/airblade/...e/vim-gitgutter', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 35: 
line 36: " File browsing bundles
line 37: Bundle 'kien/ctrlp.vim'
line 37: call vundle#config#bundle('kien/ctrlp.vim')
calling function vundle#config#bundle('kien/ctrlp.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('kien/ctrlp.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('kien/ctrlp.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/kien/ctrl...rlp.vim', 'name_spec': 'kien/ctrlp.vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/ctrlp.vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after,/Users/leostera/.vim/bundle/vim-gitgutter/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after,/Users/leostera/.vim/bundle/vim-gitgutter/after,/Users/leostera/.vim/bundle/ctrlp.vim/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 38: Bundle 'terryma/vim-multiple-cursors'
line 38: call vundle#config#bundle('terryma/vim-multiple-cursors')
calling function vundle#config#bundle('terryma/vim-multiple-cursors')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('terryma/vim-multiple-cursors', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('terryma/vim-multiple-cursors')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/terryma/v...e_spec': 'terryma/vim-multiple-cursors'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/terryma/v...ultiple-cursors', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/vim-multiple-cursors')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/vim-multiple-cursors'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/vim-multiple-cursors'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/vim-multiple-cursors'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/terryma/v...ultiple-cursors', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/terryma/v...ultiple-cursors', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after,/Users/leostera/.vim/bundle/vim-gitgutter/after,/Users/leostera/.vim/bundle/ctrlp.vim/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after,/Users/leostera/.vim/bundle/vim-gitgutter/after,/Users/leostera/.vim/bundle/ctrlp.vim/after,/Users/leostera/.vim/bundle/vim-multiple-cursors/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/terryma/v...ultiple-cursors', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 39: Bundle 'Lokaltog/powerline'
line 39: call vundle#config#bundle('Lokaltog/powerline')
calling function vundle#config#bundle('Lokaltog/powerline')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('Lokaltog/powerline', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name('Lokaltog/powerline')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_parse_name returning {'uri': 'https://github.com/Lokaltog/...ine', 'name_spec': 'Lokaltog/powerline'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath({'uri': 'https://github.com/Lokaltog/...altog/powerline', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path('/Users/leostera/.vim/bundle/powerline')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1..<SNR>5_expand_path returning '/Users/leostera/.vim/bundle/powerline'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath..1 returning '/Users/leostera/.vim/bundle/powerline'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>5_rtpath returning '/Users/leostera/.vim/bundle/powerline'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/Lokaltog/...altog/powerline', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>5_check_bundle_name({'uri': 'https://github.com/Lokaltog/...altog/powerline', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>5_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
calling function vundle#config#bundle..<SNR>5_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after,/Users/leostera/.vim/bundle/vim-gitgutter/after,/Users/leostera/.vim/bundle/ctrlp.vim/after,/Users/leostera/.vim/bundle/vim-multiple-cursors/after
function vundle#config#bundle..<SNR>5_rtp_rm_a returning #0

continuing in function vundle#config#bundle

line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
calling function vundle#config#bundle..<SNR>5_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim/bundle/emmet-vim/after,/Users/leostera/.vim/bundle/vim-indent-guides/after,/Users/leostera/.vim/bundle/syntastic/after,/Users/leostera/.vim/bundle/vim-surround/after,/Users/leostera/.vim/bundle/vim-fugitive/after,/Users/leostera/.vim/bundle/vim-gitgutter/after,/Users/leostera/.vim/bundle/ctrlp.vim/after,/Users/leostera/.vim/bundle/vim-multiple-cursors/after,/Users/leostera/.vim/bundle/powerline/after
function vundle#config#bundle..<SNR>5_rtp_add_a returning #0

continuing in function vundle#config#bundle

line 11:     call s:rtp_add_defaults()
calling function vundle#config#bundle..<SNR>5_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/Users/leostera/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/Users/leostera/.vim
line 10:   endif
function vundle#config#bundle..<SNR>5_rtp_add_defaults returning #0

continuing in function vundle#config#bundle

line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/Lokaltog/...altog/powerline', 'path': function('1')}

continuing in /Users/leostera/.vimrc

line 40: 
line 41: filetype plugin indent on
Searching for "filetype.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.v
Searching for "/Users/leostera/.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/filetype.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 41: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2014 Feb 26
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Abaqus or Trasys
line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
line 53: 
line 54: func! s:Check_inp()
line 73: 
line 74: " A-A-P recipe
line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 76: 
line 77: " A2ps printing utility
line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 79: 
line 80: " ABAB/4
line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 82: 
line 83: " ABC music notation
line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 85: 
line 86: " ABEL
line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 88: 
line 89: " AceDB
line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 91: 
line 92: " Ada (83, 9X, 95)
line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 94: if has("vms")
line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 96: else
line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 98: endif
line 99: 
line 100: " AHDL
line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 102: 
line 103: " AMPL
line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 105: 
line 106: " Ant
line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 108: 
line 109: " Arduino
line 110: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 111: 
line 112: " Apache style config file
line 113: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 114: 
line 115: " Apache config file
line 116: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 117: 
line 118: " XA65 MOS6510 cross assembler
line 119: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 120: 
line 121: " Applescript
line 122: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 123: 
line 124: " Applix ELF
line 126: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 127: 
line 128: " ALSA configuration
line 129: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 130: 
line 131: " Arc Macro Language
line 132: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 133: 
line 134: " APT config file
line 135: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 136: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 137: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 138: 
line 139: " Arch Inventory file
line 140: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 141: 
line 142: " ART*Enterprise (formerly ART-IM)
line 143: au BufNewFile,BufRead *.art^I^I^Isetf art
line 144: 
line 145: " AsciiDoc
line 146: au BufNewFile,BufRead *.asciidoc^I^Isetf asciidoc
line 147: 
line 148: " ASN.1
line 149: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 150: 
line 151: " Active Server Pages (with Visual Basic Script)
line 157: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 158: 
line 159: " Active Server Pages (with Perl or Visual Basic Script)
line 167: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 168: 
line 169: " Grub (must be before catch *.lst)
line 170: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 171: 
line 172: " Assembly (all kinds)
line 173: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 174: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
line 175: 
line 176: " This function checks for the kind of assembly that is wanted by the user, or
line 177: " can be detected from the first five lines of the file.
line 178: func! s:FTasm()
line 199: 
line 200: func! s:FTasmsyntax()
line 212: 
line 213: " Macro (VAX)
line 214: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 215: 
line 216: " Atlas
line 217: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 218: 
line 219: " Autoit v3
line 220: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 221: 
line 222: " Autohotkey
line 223: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 224: 
line 225: " Automake
line 226: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 227: 
line 228: " Autotest .at files are actually m4
line 229: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 230: 
line 231: " Avenue
line 232: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 233: 
line 234: " Awk
line 235: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 236: 
line 237: " B
line 238: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 239: 
line 240: " BASIC or Visual Basic
line 241: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
line 242: 
line 243: " Check if one of the first five lines contains "VB_Name".  In that case it is
line 244: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
line 245: func! s:FTVB(alt)
line 252: 
line 253: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 254: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 255: 
line 256: " IBasic file (similar to QBasic)
line 257: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 258: 
line 259: " FreeBasic file (similar to QBasic)
line 260: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 261: 
line 262: " Batch file for MSDOS.
line 263: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 264: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 266: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 267: 
line 268: " Batch file for 4DOS
line 269: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
line 270: func! s:FTbtm()
line 277: 
line 278: " BC calculator
line 279: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 280: 
line 281: " BDF font
line 282: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 283: 
line 284: " BibTeX bibliography database file
line 285: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 286: 
line 287: " BibTeX Bibliography Style
line 288: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 289: 
line 290: " BIND configuration
line 291: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named
line 292: 
line 293: " BIND zone
line 294: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 295: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
line 296: 
line 297: func! s:BindzoneCheck(default)
line 304: 
line 305: " Blank
line 306: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 307: 
line 308: " Blkid cache file
line 309: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 310: 
line 311: " C or lpc
line 312: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
line 313: 
line 314: func! s:FTlpc()
line 327: 
line 328: " Calendar
line 329: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 330: 
line 331: " C#
line 332: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 333: 
line 334: " CSDL
line 335: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 336: 
line 337: " Cabal
line 338: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 339: 
line 340: " Cdrdao TOC
line 341: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 342: 
line 343: " Cdrdao config
line 344: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 345: 
line 346: " Cfengine
line 347: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 348: 
line 349: " ChaiScript
line 350: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 351: 
line 352: " Comshare Dimension Definition Language
line 353: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 354: 
line 355: " Conary Recipe
line 356: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 357: 
line 358: " Controllable Regex Mutilator
line 359: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 360: 
line 361: " Cyn++
line 362: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 363: 
line 364: " Cynlib
line 365: " .cc and .cpp files can be C++ or Cynlib.
line 367: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 369: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 370: 
line 371: " C++
line 372: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 373: if has("fname_case")
line 374:   au BufNewFile,BufRead *.C,*.H setf cpp
line 375: endif
line 376: 
line 377: " .h files can be C, Ch C++, ObjC or ObjC++.
line 378: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 379: " detected automatically.
line 380: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
line 381: 
line 382: func! s:FTheader()
line 397: 
line 398: " Ch (CHscript)
line 399: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 400: 
line 401: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 402: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 403: 
line 404: " Cascading Style Sheets
line 405: au BufNewFile,BufRead *.css^I^I^Isetf css
line 406: 
line 407: " Century Term Command Scripts (*.cmd too)
line 408: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 409: 
line 410: " Changelog
line 412: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 413: 
line 419: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 420: 
line 424: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 425: 
line 426: " CHILL
line 427: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 428: 
line 429: " Changes for WEB and CWEB or CHILL
line 430: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
line 431: 
line 432: " This function checks if one of the first ten lines start with a '@'.  In
line 433: " that case it is probably a change file.
line 434: " If the first line starts with # or ! it's probably a ch file.
line 435: " If a line has "main", "include", "//" ir "/*" it's probably ch.
line 436: " Otherwise CHILL is assumed.
line 437: func! s:FTchange()
line 460: 
line 461: " ChordPro
line 462: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 463: 
line 464: " Clean
line 465: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 466: 
line 467: " Clever
line 468: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 469: 
line 470: " Clever or dtd
line 471: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
line 472: 
line 473: func! s:FTent()
line 492: 
line 493: " Clipper (or FoxPro; could also be eviews)
line 499: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 500: 
line 501: " Clojure
line 502: au BufNewFile,BufRead *.clj,*.cljs^I^Isetf clojure
line 503: 
line 504: " Cmake
line 505: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 506: 
line 507: " Cmusrc
line 508: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 509: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 510: 
line 511: " Cobol
line 512: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 513: "   cobol or zope form controller python script? (heuristic)
line 519: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 520: 
line 521: " Coco/R
line 522: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 523: 
line 524: " Cold Fusion
line 525: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 526: 
line 527: " Configure scripts
line 528: au BufNewFile,BufRead configure.in,configure.ac setf config
line 529: 
line 530: " CUDA  Cumpute Unified Device Architecture
line 531: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
line 532: 
line 533: " WildPackets EtherPeek Decoder
line 534: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 535: 
line 536: " Enlightenment configuration files
line 537: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 538: 
line 539: " Eterm
line 540: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 541: 
line 542: " Euphoria 3 or 4
line 543: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
line 544: if has("fname_case")
line 545:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
line 546: endif
line 547: 
line 548: func! s:EuphoriaCheck()
line 555: 
line 556: " Lynx config files
line 557: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 558: 
line 559: " Quake
line 560: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 561: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 562: 
line 563: " Quake C
line 564: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 565: 
line 566: " Configure files
line 567: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 568: 
line 569: " Cucumber
line 570: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 571: 
line 572: " Communicating Sequential Processes
line 573: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 574: 
line 575: " CUPL logic description and simulation
line 576: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 577: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 578: 
line 579: " Debian Control
line 580: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 584: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 585: 
line 586: " Debian Sources.list
line 587: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 588: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 589: 
line 590: " Deny hosts
line 591: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 592: 
line 593: " dnsmasq(8) configuration files
line 594: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 595: 
line 596: " ROCKLinux package description
line 597: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 598: 
line 599: " the D language or dtrace
line 600: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
line 601: 
line 602: func! s:DtraceCheck()
line 613: 
line 614: " Desktop files
line 615: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 616: 
line 617: " Dict config
line 618: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 619: 
line 620: " Dictd config
line 621: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 622: 
line 623: " Diff files
line 624: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff
line 625: 
line 626: " Dircolors
line 627: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 628: 
line 629: " Diva (with Skill) or InstallShield
line 635: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 636: 
line 637: " DCL (Digital Command Language - vms) or DNS zone file
line 638: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
line 639: 
line 640: " DOT
line 641: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 642: 
line 643: " Dylan - lid files
line 644: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 645: 
line 646: " Dylan - intr files (melange)
line 647: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 648: 
line 649: " Dylan
line 650: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 651: 
line 652: " Microsoft Module Definition
line 653: au BufNewFile,BufRead *.def^I^I^Isetf def
line 654: 
line 655: " Dracula
line 656: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 657: 
line 658: " Datascript
line 659: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 660: 
line 661: " dsl
line 662: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 663: 
line 664: " DTD (Document Type Definition for XML)
line 665: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 666: 
line 667: " DTS/DSTI (device tree files)
line 668: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 669: 
line 670: " EDIF (*.edf,*.edif,*.edn,*.edo)
line 671: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif
line 672: 
line 673: " Embedix Component Description
line 674: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 675: 
line 676: " Eiffel or Specman or Euphoria
line 677: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
line 678: 
line 679: " Elinks configuration
line 680: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 681: 
line 682: func! s:FTe()
line 697: 
line 698: " ERicsson LANGuage; Yaws is erlang too
line 699: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 700: 
line 701: " Elm Filter Rules file
line 702: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 703: 
line 704: " ESMTP rc file
line 705: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 706: 
line 707: " ESQL-C
line 708: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 709: 
line 710: " Esterel
line 711: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 712: 
line 713: " Essbase script
line 714: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 715: 
line 716: " Exim
line 717: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 718: 
line 719: " Expect
line 720: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 721: 
line 722: " Exports
line 723: au BufNewFile,BufRead exports^I^I^Isetf exports
line 724: 
line 725: " Falcon
line 726: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 727: 
line 728: " Fantom
line 729: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 730: 
line 731: " Factor
line 732: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 733: 
line 734: " Fetchmail RC file
line 735: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 736: 
line 737: " FlexWiki - disabled, because it has side effects when a .wiki file
line 738: " is not actually FlexWiki
line 739: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 740: 
line 741: " Focus Executable
line 742: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 743: 
line 744: " Focus Master file (but not for auto.master)
line 745: au BufNewFile,BufRead auto.master^I^Isetf conf
line 746: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 747: 
line 748: " Forth
line 749: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
line 750: 
line 751: " Reva Forth
line 752: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 753: 
line 754: " Fortran
line 755: if has("fname_case")
line 756:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 757: endif
line 758: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 759: 
line 760: " Framescript
line 761: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 762: 
line 763: " FStab
line 764: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 765: 
line 766: " GDB command files
line 767: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 768: 
line 769: " GDMO
line 770: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 771: 
line 772: " Gedcom
line 773: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 774: 
line 775: " Git
line 776: au BufNewFile,BufRead *.git/COMMIT_EDITMSG^Isetf gitcommit
line 777: au BufNewFile,BufRead *.git/MERGE_MSG^I^Isetf gitcommit
line 778: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
line 779: au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
line 780: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
line 781: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
line 782: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 786: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 790: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 791: 
line 792: " Gkrellmrc
line 793: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 794: 
line 795: " GP scripts (2.0 and onward)
line 796: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 797: 
line 798: " GPG
line 799: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 800: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 801: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 802: 
line 803: " gnash(1) configuration files
line 804: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 805: 
line 806: " Gitolite
line 807: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 808: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 809: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 810: 
line 811: " Gnuplot scripts
line 812: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 813: 
line 814: " GrADS scripts
line 815: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 816: 
line 817: " Gretl
line 818: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 819: 
line 820: " Groovy
line 821: au BufNewFile,BufRead *.groovy^I^I^Isetf groovy
line 822: 
line 823: " GNU Server Pages
line 824: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 825: 
line 826: " Group file
line 827: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 828: 
line 829: " GTK RC
line 830: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 831: 
line 832: " Haml
line 833: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 834: 
line 835: " Hamster Classic | Playground files
line 836: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 837: 
line 838: " Haskell
line 839: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 840: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 841: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 842: 
line 843: " Haste
line 844: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 845: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 846: 
line 847: " Hercules
line 848: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules
line 849: 
line 850: " HEX (Intel)
line 851: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 852: 
line 853: " Tilde (must be before HTML)
line 854: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 855: 
line 856: " HTML (.shtml and .stm for server side)
line 857: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
line 858: 
line 859: " Distinguish between HTML, XHTML and Django
line 860: func! s:FThtml()
line 875: 
line 876: " HTML with Ruby - eRuby
line 877: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 878: 
line 879: " HTML with M4
line 880: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 881: 
line 882: " HTML Cheetah template
line 883: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 884: 
line 885: " Host config
line 886: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 887: 
line 888: " Hosts access
line 889: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 890: 
line 891: " Hyper Builder
line 892: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 893: 
line 894: " Httest
line 895: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 896: 
line 897: " Icon
line 898: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 899: 
line 900: " IDL (Interface Description Language)
line 901: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
line 902: 
line 903: " Distinguish between standard IDL and MS-IDL
line 904: func! s:FTidl()
line 915: 
line 916: " Microsoft IDL (Interface Description Language)  Also *.idl
line 917: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 918: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 919: 
line 920: " Icewm menu
line 921: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 922: 
line 923: " Indent profile (must come before IDL *.pro!)
line 924: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 925: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
line 926: 
line 927: " IDL (Interactive Data Language)
line 928: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
line 929: 
line 930: " Distinguish between "default" and Cproto prototype file. */
line 931: func! s:ProtoCheck(default)
line 943: 
line 944: 
line 945: " Indent RC
line 946: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 947: 
line 948: " Inform
line 949: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 950: 
line 951: " Initng
line 952: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 953: 
line 954: " Innovation Data Processing
line 955: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 956: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog
line 957: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 958: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 959: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 960: 
line 961: " Ipfilter
line 962: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 963: 
line 964: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 965: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 966: 
line 967: " .INI file for MSDOS
line 968: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 969: 
line 970: " SysV Inittab
line 971: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 972: 
line 973: " Inno Setup
line 974: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 975: 
line 976: " J
line 977: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 978: 
line 979: " JAL
line 980: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 981: 
line 982: " Jam
line 983: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 984: 
line 985: " Java
line 986: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 987: 
line 988: " JavaCC
line 989: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 990: 
line 991: " JavaScript, ECMAScript
line 992: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
line 993: 
line 994: " Java Server Pages
line 995: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 996: 
line 997: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 998: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 999: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 1000: 
line 1001: " Jess
line 1002: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 1003: 
line 1004: " Jgraph
line 1005: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 1006: 
line 1007: " Jovial
line 1008: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 1009: 
line 1010: " Kixtart
line 1011: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 1012: 
line 1013: " Kimwitu[++]
line 1014: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 1015: 
line 1016: " KDE script
line 1017: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 1018: 
line 1019: " Kconfig
line 1020: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1021: 
line 1022: " Lace (ISE)
line 1023: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1024: 
line 1025: " Latte
line 1026: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1027: 
line 1028: " Limits
line 1029: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1030: 
line 1031: " LambdaProlog (*.mod too, see Modsim)
line 1032: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 1033: 
line 1034: " LDAP LDIF
line 1035: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1036: 
line 1037: " Ld loader
line 1038: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1039: 
line 1040: " Lex
line 1041: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 1042: 
line 1043: " Libao
line 1044: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1045: 
line 1046: " Libsensors
line 1047: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1048: 
line 1049: " LFTP
line 1050: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1051: 
line 1052: " Lifelines (or Lex for C++!)
line 1053: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1054: 
line 1055: " Lilo: Linux loader
line 1056: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1057: 
line 1058: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 1059: if has("fname_case")
line 1060:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 1061: else
line 1062:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 1063: endif
line 1064: 
line 1065: " SBCL implementation of Common Lisp
line 1066: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1067: 
line 1068: " Liquid
line 1069: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1070: 
line 1071: " Lite
line 1072: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1073: 
line 1074: " LiteStep RC files
line 1075: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1076: 
line 1077: " Login access
line 1078: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1079: 
line 1080: " Login defs
line 1081: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1082: 
line 1083: " Logtalk
line 1084: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1085: 
line 1086: " LOTOS
line 1087: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1088: 
line 1089: " Lout (also: *.lt)
line 1090: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1091: 
line 1092: " Lua
line 1093: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1094: 
line 1095: " Linden Scripting Language (Second Life)
line 1096: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 1097: 
line 1098: " Lynx style file (or LotusScript!)
line 1099: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1100: 
line 1101: " M4
line 1103: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1104: 
line 1105: " MaGic Point
line 1106: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1107: 
line 1108: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
line 1109: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1110: 
line 1111: " Mail aliases
line 1112: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1113: 
line 1114: " Mailcap configuration file
line 1115: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1116: 
line 1117: " Makefile
line 1118: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1119: 
line 1120: " MakeIndex
line 1121: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1122: 
line 1123: " Mallard
line 1124: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1125: 
line 1126: " Manpage
line 1127: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1128: 
line 1129: " Man config
line 1130: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1131: 
line 1132: " Maple V
line 1133: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1134: 
line 1135: " Map (UMN mapserver config file)
line 1136: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1137: 
line 1138: " Markdown
line 1139: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,README.md  setf markdown
line 1140: 
line 1141: " Mason
line 1142: au BufNewFile,BufRead *.mason,*.mhtml^I^Isetf mason
line 1143: 
line 1144: " Matlab or Objective C
line 1145: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
line 1146: 
line 1147: func! s:FTm()
line 1171: 
line 1172: " Mathematica notebook
line 1173: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1174: 
line 1175: " Maya Extension Language
line 1176: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1177: 
line 1178: " Mercurial (hg) commit file
line 1179: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1180: 
line 1181: " Mercurial config (looks like generic config file)
line 1182: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1183: 
line 1184: " Messages (logs mostly)
line 1185: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1186: 
line 1187: " Metafont
line 1188: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1189: 
line 1190: " MetaPost
line 1191: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1192: 
line 1193: " MGL
line 1194: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1195: 
line 1196: " MIX - Knuth assembly
line 1197: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1198: 
line 1199: " MMIX or VMS makefile
line 1200: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
line 1201: 
line 1202: " Symbian meta-makefile definition (MMP)
line 1203: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1204: 
line 1205: func! s:FTmms()
line 1221: 
line 1222: 
line 1223: " Modsim III (or LambdaProlog)
line 1229: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1230: 
line 1231: " Modula 2
line 1232: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2
line 1233: 
line 1234: " Modula 3 (.m3, .i3, .mg, .ig)
line 1235: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1236: 
line 1237: " Monk
line 1238: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1239: 
line 1240: " MOO
line 1241: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1242: 
line 1243: " Modconf
line 1244: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1245: 
line 1246: " Mplayer config
line 1247: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1248: 
line 1249: " Moterola S record
line 1250: au BufNewFile,BufRead *.s19,*.s28,*.s37^I^Isetf srec
line 1251: 
line 1252: " Mrxvtrc
line 1253: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1254: 
line 1255: " Msql
line 1256: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1257: 
line 1258: " Mysql
line 1259: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1260: 
line 1261: " Mutt setup files (must be before catch *.rc)
line 1262: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1263: 
line 1264: " M$ Resource files
line 1265: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1266: 
line 1267: " MuPAD source
line 1268: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1269: 
line 1270: " Mush
line 1271: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1272: 
line 1273: " Mutt setup file (also for Muttng)
line 1274: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1275: 
line 1276: " Nano
line 1277: au BufNewFile,BufRead */etc/nanorc,.nanorc^Isetf nanorc
line 1278: 
line 1279: " Nastran input/DMAP
line 1280: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1281: 
line 1282: " Natural
line 1283: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1284: 
line 1285: " Netrc
line 1286: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1287: 
line 1288: " Ninja file
line 1289: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1290: 
line 1291: " Novell netware batch files
line 1292: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1293: 
line 1294: " Nroff/Troff (*.ms and *.t are checked below)
line 1298: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1299: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1300: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
line 1301: 
line 1302: " This function checks if one of the first five lines start with a dot.  In
line 1303: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
line 1304: func! s:FTnroff()
line 1311: 
line 1312: " Nroff or Objective C++
line 1313: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
line 1314: 
line 1315: func! s:FTmm()
line 1327: 
line 1328: " Not Quite C
line 1329: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1330: 
line 1331: " NSIS
line 1332: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1333: 
line 1334: " OCAML
line 1335: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1336: 
line 1337: " Occam
line 1338: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1339: 
line 1340: " Omnimark
line 1341: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1342: 
line 1343: " OpenROAD
line 1344: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1345: 
line 1346: " OPL
line 1347: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1348: 
line 1349: " Oracle config file
line 1350: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1351: 
line 1352: " Packet filter conf
line 1353: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1354: 
line 1355: " Pam conf
line 1356: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1357: 
line 1358: " PApp
line 1359: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1360: 
line 1361: " Password file
line 1362: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1363: 
line 1364: " Pascal (also *.p)
line 1365: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1366: 
line 1367: " Delphi project file
line 1368: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1369: 
line 1370: " PDF
line 1371: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1372: 
line 1373: " Perl
line 1374: if has("fname_case")
line 1375:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
line 1376: else
line 1377:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
line 1378: endif
line 1379: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl
line 1380: au BufNewFile,BufRead *.p6,*.pm6^I^Isetf perl6
line 1381: 
line 1382: func! s:FTpl()
line 1396: 
line 1397: " Perl, XPM or XPM2
line 1405: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1406: 
line 1407: " Perl POD
line 1408: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1409: 
line 1410: " Php, php3, php4, etc.
line 1411: " Also Phtml (was used for PHP 2 in the past)
line 1412: " Also .ctp for Cake template file
line 1413: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1414: 
line 1415: " Pike
line 1416: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
line 1417: 
line 1418: " Pinfo config
line 1419: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1420: 
line 1421: " Palm Resource compiler
line 1422: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1423: 
line 1424: " Pine config
line 1425: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1426: 
line 1427: " PL/1, PL/I
line 1428: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1429: 
line 1430: " PL/M (also: *.inp)
line 1431: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1432: 
line 1433: " PL/SQL
line 1434: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1435: 
line 1436: " PLP
line 1437: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1438: 
line 1439: " PO and PO template (GNU gettext)
line 1440: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1441: 
line 1442: " Postfix main config
line 1443: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1444: 
line 1445: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1446: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1447: 
line 1448: " PostScript Printer Description
line 1449: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1450: 
line 1451: " Povray
line 1452: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1453: 
line 1454: " Povray configuration
line 1455: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1456: 
line 1457: " Povray, PHP or assembly
line 1458: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
line 1459: 
line 1460: func! s:FTinc()
line 1481: 
line 1482: " Printcap and Termcap
line 1484: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1486: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1487: 
line 1488: " PCCTS / ANTRL
line 1489: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1490: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1491: 
line 1492: " PPWizard
line 1493: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1494: 
line 1495: " Obj 3D file format
line 1496: " TODO: is there a way to avoid MS-Windows Object files?
line 1497: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1498: 
line 1499: " Oracle Pro*C/C++
line 1500: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1501: 
line 1502: " Privoxy actions file
line 1503: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1504: 
line 1505: " Procmail
line 1506: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1507: 
line 1508: " Progress or CWEB
line 1509: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
line 1510: 
line 1511: func! s:FTprogress_cweb()
line 1522: 
line 1523: " Progress or assembly
line 1524: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
line 1525: 
line 1526: func! s:FTprogress_asm()
line 1548: 
line 1549: " Progress or Pascal
line 1550: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
line 1551: 
line 1552: func! s:FTprogress_pascal()
line 1576: 
line 1577: 
line 1578: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1579: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1583: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1584: 
line 1585: " Prolog
line 1586: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1587: 
line 1588: " Promela
line 1589: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1590: 
line 1591: " Google protocol buffers
line 1592: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1593: 
line 1594: " Protocols
line 1595: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1596: 
line 1597: " Pyrex
line 1598: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1599: 
line 1600: " Python
line 1601: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python
line 1602: 
line 1603: " Quixote (Python-based web framework)
line 1604: au BufNewFile,BufRead *.ptl^I^I^Isetf python
line 1605: 
line 1606: " Radiance
line 1607: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1608: 
line 1609: " Ratpoison config/command files
line 1610: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1611: 
line 1612: " RCS file
line 1613: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1614: 
line 1615: " Readline
line 1616: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1617: 
line 1618: " Registry for MS-Windows
line 1620: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1621: 
line 1622: " Renderman Interface Bytestream
line 1623: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1624: 
line 1625: " Rexx
line 1626: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1627: 
line 1628: " R (Splus)
line 1629: if has("fname_case")
line 1630:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1631: else
line 1632:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1633: endif
line 1634: 
line 1635: " R Help file
line 1636: if has("fname_case")
line 1637:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1638: else
line 1639:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1640: endif
line 1641: 
line 1642: " R noweb file
line 1643: if has("fname_case")
line 1644:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1645: else
line 1646:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1647: endif
line 1648: 
line 1649: " Rexx, Rebol or R
line 1650: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
line 1651: 
line 1652: func! s:FTr()
line 1684: 
line 1685: " Remind
line 1686: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1687: 
line 1688: " Resolv.conf
line 1689: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1690: 
line 1691: " Relax NG Compact
line 1692: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1693: 
line 1694: " Relax NG XML
line 1695: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1696: 
line 1697: " RPL/2
line 1698: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1699: 
line 1700: " Robots.txt
line 1701: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1702: 
line 1703: " Rpcgen
line 1704: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1705: 
line 1706: " reStructuredText Documentation Format
line 1707: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1708: 
line 1709: " RTF
line 1710: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1711: 
line 1712: " Interactive Ruby shell
line 1713: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1714: 
line 1715: " Ruby
line 1716: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1717: 
line 1718: " RubyGems
line 1719: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1720: 
line 1721: " Rackup
line 1722: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1723: 
line 1724: " Bundler
line 1725: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1726: 
line 1727: " Ruby on Rails
line 1728: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1729: 
line 1730: " Rantfile and Rakefile is like Ruby
line 1731: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1732: 
line 1733: " S-lang (or shader language, or SmallLisp)
line 1734: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1735: 
line 1736: " Samba config
line 1737: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1738: 
line 1739: " SAS script
line 1740: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1741: 
line 1742: " Sass
line 1743: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1744: 
line 1745: " Sather
line 1746: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1747: 
line 1748: " Scilab
line 1749: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1750: 
line 1751: " SCSS
line 1752: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1753: 
line 1754: " SD: Streaming Descriptors
line 1755: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1756: 
line 1757: " SDL
line 1758: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1759: 
line 1760: " sed
line 1761: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1762: 
line 1763: " Sieve (RFC 3028)
line 1764: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
line 1765: 
line 1766: " Sendmail
line 1767: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1768: 
line 1769: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1770: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
line 1771: 
line 1772: func! s:McSetf()
line 1787: 
line 1788: " Services
line 1789: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1790: 
line 1791: " Service Location config
line 1792: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1793: 
line 1794: " Service Location registration
line 1795: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1796: 
line 1797: " Service Location SPI
line 1798: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1799: 
line 1800: " Setserial config
line 1801: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1802: 
line 1803: " SGML
line 1813: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1814: 
line 1815: " SGMLDECL
line 1819: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1820: 
line 1821: " SGML catalog file
line 1822: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1823: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1824: 
line 1825: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1826: " Gentoo ebuilds are actually bash scripts
line 1827: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
line 1828: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
line 1829: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
line 1830: 
line 1831: " Also called from scripts.vim.
line 1832: func! SetFileTypeSH(name)
line 1875: 
line 1876: " For shell-like file types, check for an "exec" command hidden in a comment,
line 1877: " as used for Tcl.
line 1878: " Also called from scripts.vim, thus can't be local to this script.
line 1879: func! SetFileTypeShell(name)
line 1898: 
line 1899: " tcsh scripts
line 1900: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
line 1901: 
line 1902: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1903: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
line 1904: 
line 1905: func! s:CSH()
line 1914: 
line 1915: " Z-Shell script
line 1916: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1917: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 1918: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1919: 
line 1920: " Scheme
line 1921: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1922: 
line 1923: " Screen RC
line 1924: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1925: 
line 1926: " Simula
line 1927: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1928: 
line 1929: " SINDA
line 1930: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1931: 
line 1932: " SiSU
line 1933: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1934: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1935: 
line 1936: " SKILL
line 1937: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1938: 
line 1939: " SLRN
line 1940: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1941: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1942: 
line 1943: " Smalltalk (and TeX)
line 1944: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1952: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1953: 
line 1954: " Smarty templates
line 1955: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1956: 
line 1957: " SMIL or XML
line 1963: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1964: 
line 1965: " SMIL or SNMP MIB file
line 1971: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1972: 
line 1973: " SMITH
line 1974: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1975: 
line 1976: " Snobol4 and spitbol
line 1977: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1978: 
line 1979: " SNMP MIB files
line 1980: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1981: 
line 1982: " Snort Configuration
line 1983: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1984: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
line 1985: 
line 1986: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
line 1987: func! s:FTRules()
line 2015: 
line 2016: 
line 2017: " Spec (Linux RPM)
line 2018: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 2019: 
line 2020: " Speedup (AspenTech plant simulator)
line 2021: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 2022: 
line 2023: " Slice
line 2024: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2025: 
line 2026: " Spice
line 2027: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2028: 
line 2029: " Spyce
line 2030: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2031: 
line 2032: " Squid
line 2033: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2034: 
line 2035: " SQL for Oracle Designer
line 2036: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 2037: 
line 2038: " SQL
line 2039: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
line 2040: 
line 2041: func! s:SQL()
line 2048: 
line 2049: " SQLJ
line 2050: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2051: 
line 2052: " SQR
line 2053: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2054: 
line 2055: " OpenSSH configuration
line 2056: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 2057: 
line 2058: " OpenSSH server configuration
line 2059: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 2060: 
line 2061: " Stata
line 2062: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
line 2063: 
line 2064: " SMCL
line 2065: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2066: 
line 2067: " Stored Procedures
line 2068: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2069: 
line 2070: " Standard ML
line 2071: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2072: 
line 2073: " Sratus VOS command macro
line 2074: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2075: 
line 2076: " Sysctl
line 2077: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2078: 
line 2079: " Synopsys Design Constraints
line 2080: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2081: 
line 2082: " Sudoers
line 2083: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2084: 
line 2085: " SVG (Scalable Vector Graphics)
line 2086: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2087: 
line 2088: " If the file has an extension of 't' and is in a directory 't' or 'xt' then
line 2089: " it is almost certainly a Perl test file.
line 2090: " If the first line starts with '#' and contains 'perl' it's probably a Perl
line 2091: " file.
line 2092: " (Slow test) If a file contains a 'use' statement then it is almost certainly
line 2093: " a Perl file.
line 2094: func! s:FTperl()
line 2110: 
line 2111: " Tads (or Nroff or Perl test file)
line 2113: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
line 2114: 
line 2115: " Tags
line 2116: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2117: 
line 2118: " TAK
line 2119: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2120: 
line 2121: " Task
line 2122: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2123: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2124: 
line 2125: " Tcl (JACL too)
line 2126: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 2127: 
line 2128: " TealInfo
line 2129: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2130: 
line 2131: " Telix Salt
line 2132: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2133: 
line 2134: " Terminfo
line 2135: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2136: 
line 2137: " TeX
line 2138: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2139: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
line 2140: 
line 2141: " Choose context, plaintex, or tex (LaTeX) based on these rules:
line 2142: " 1. Check the first line of the file for "%&<format>".
line 2143: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
line 2144: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
line 2145: func! s:FTtex()
line 2192: 
line 2193: " ConTeXt
line 2194: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
line 2195: 
line 2196: " Texinfo
line 2197: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2198: 
line 2199: " TeX configuration
line 2200: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2201: 
line 2202: " Tidy config
line 2203: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 2204: 
line 2205: " TF mud client
line 2206: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 2207: 
line 2208: " TPP - Text Presentation Program
line 2209: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 2210: 
line 2211: " Treetop
line 2212: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2213: 
line 2214: " Trustees
line 2215: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2216: 
line 2217: " TSS - Geometry
line 2218: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2219: 
line 2220: " TSS - Optics
line 2221: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2222: 
line 2223: " TSS - Command Line (temporary)
line 2224: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2225: 
line 2226: " TWIG files
line 2227: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2228: 
line 2229: " Motif UIT/UIL files
line 2230: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2231: 
line 2232: " Udev conf
line 2233: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2234: 
line 2235: " Udev permissions
line 2236: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2237: "
line 2238: " Udev symlinks config
line 2239: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2240: 
line 2241: " UnrealScript
line 2242: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2243: 
line 2244: " Updatedb
line 2245: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2246: 
line 2247: " Upstart (init(8)) config files
line 2248: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2249: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2250: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2251: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
line 2252: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2253: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2254: 
line 2255: " Vera
line 2256: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2257: 
line 2258: " Verilog HDL
line 2259: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 2260: 
line 2261: " Verilog-AMS HDL
line 2262: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2263: 
line 2264: " SystemVerilog
line 2265: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 2266: 
line 2267: " VHDL
line 2268: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 2269: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2270: 
line 2271: " Vim script
line 2272: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 2273: 
line 2274: " Viminfo file
line 2275: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2276: 
line 2277: " Virata Config Script File or Drupal module
line 2283: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2284: 
line 2285: " Visual Basic (also uses *.bas) or FORM
line 2286: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
line 2287: 
line 2288: " SaxBasic is close to Visual Basic
line 2289: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2290: 
line 2291: " Vgrindefs file
line 2292: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2293: 
line 2294: " VRML V1.0c
line 2295: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2296: 
line 2297: " Webmacro
line 2298: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2299: 
line 2300: " Wget config
line 2301: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2302: 
line 2303: " Website MetaLanguage
line 2304: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2305: 
line 2306: " Winbatch
line 2307: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2308: 
line 2309: " WSML
line 2310: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2311: 
line 2312: " WvDial
line 2313: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2314: 
line 2315: " CVS RC file
line 2316: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2317: 
line 2318: " CVS commit file
line 2319: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2320: 
line 2321: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2322: " lines in a WEB file).
line 2328: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2329: 
line 2330: " Windows Scripting Host and Windows Script Component
line 2331: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2332: 
line 2333: " XHTML
line 2334: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2335: 
line 2336: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 2342: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2343: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 2344: 
line 2345: " XFree86 config
line 2350: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2353: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2354: 
line 2355: " Xorg config
line 2356: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2357: 
line 2358: " Xinetd conf
line 2359: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2360: 
line 2361: " XS Perl extension interface language
line 2362: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2363: 
line 2364: " X resources file
line 2365: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2366: 
line 2367: " Xmath
line 2368: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2370: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
line 2371: 
line 2372: " XML  specific variants: docbk and xbl
line 2373: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
line 2374: 
line 2375: func! s:FTxml()
line 2400: 
line 2401: " XMI (holding UML models) is also XML
line 2402: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2403: 
line 2404: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 2405: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2406: 
line 2407: " Qt Linguist translation source and Qt User Interface Files are XML
line 2408: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 2409: 
line 2410: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2411: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2412: 
line 2413: " Xdg menus
line 2414: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2415: 
line 2416: " ATI graphics driver configuration
line 2417: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2418: 
line 2419: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2420: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2421: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2422: 
line 2423: " XML User Interface Language
line 2424: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2425: 
line 2426: " X11 xmodmap (also see below)
line 2427: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2428: 
line 2429: " Xquery
line 2430: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2431: 
line 2432: " XSD
line 2433: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2434: 
line 2435: " Xslt
line 2436: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2437: 
line 2438: " Yacc
line 2439: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 2440: 
line 2441: " Yacc or racc
line 2442: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
line 2443: 
line 2444: func! s:FTy()
line 2460: 
line 2461: 
line 2462: " Yaml
line 2463: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 2464: 
line 2465: " yum conf (close enough to dosini)
line 2466: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2467: 
line 2468: " Zimbu
line 2469: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2470: 
line 2471: " Zope
line 2472: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2473: "   cpt (zope form controller page template)
line 2474: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
line 2475: "   zsql (zope sql method)
line 2476: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
line 2477: 
line 2478: " Z80 assembler asz80
line 2479: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2480: 
line 2481: augroup END
line 2482: 
line 2483: 
line 2484: " Source the user-specified filetype file, for backwards compatibility with
line 2485: " Vim 5.x.
line 2486: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2487:   execute "source " . myfiletypefile
line 2488: endif
line 2489: 
line 2490: 
line 2491: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2492: " when there are no matching file name extensions.
line 2493: " Don't do this for compressed files.
line 2494: augroup filetypedetect
line 2497: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2498: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2499: 
line 2500: 
line 2501: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2502: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2503: " script file.
line 2504: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2505: " like are used.
line 2506: 
line 2507: " More Apache config files
line 2508: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2509: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2510: 
line 2511: " Asterisk config file
line 2512: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2513: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2514: 
line 2515: " Bazaar version control
line 2516: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2517: 
line 2518: " BIND zone
line 2519: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2520: 
line 2521: " Calendar
line 2524: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2525: 
line 2526: " Changelog
line 2532: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2533: 
line 2534: " Crontab
line 2535: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2536: 
line 2537: " dnsmasq(8) configuration
line 2538: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2539: 
line 2540: " Dracula
line 2541: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2542: 
line 2543: " Fvwm
line 2544: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2546: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2552: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2553: 
line 2554: " Gedcom
line 2555: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2556: 
line 2557: " GTK RC
line 2558: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2559: 
line 2560: " Jam
line 2561: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2562: 
line 2563: " Jargon
line 2567: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2568: 
line 2569: " Kconfig
line 2570: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2571: 
line 2572: " Lilo: Linux loader
line 2573: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2574: 
line 2575: " Logcheck
line 2576: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2577: 
line 2578: " Makefile
line 2579: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2580: 
line 2581: " Ruby Makefile
line 2582: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2583: 
line 2584: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2585: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2586: 
line 2587: " Modconf
line 2591: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2592: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2593: 
line 2594: " Mutt setup file
line 2595: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2596: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2597: 
line 2598: " Nroff macros
line 2599: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2600: 
line 2601: " Pam conf
line 2602: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2603: 
line 2604: " Printcap and Termcap
line 2608: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2612: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2613: 
line 2614: " ReDIF
line 2615: " Only used when the .rdf file was not detected to be XML.
line 2616: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
line 2617: func! s:Redif()
line 2627: 
line 2628: " Remind
line 2629: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2630: 
line 2631: " Vim script
line 2632: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2633: 
line 2634: " Subversion commit file
line 2635: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2636: 
line 2637: " X resources file
line 2638: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2639: 
line 2640: " XFree86 config
line 2642: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2647: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2648: 
line 2649: " X11 xmodmap
line 2650: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2651: 
line 2652: " Xinetd conf
line 2653: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2654: 
line 2655: " yum conf (close enough to dosini)
line 2656: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2657: 
line 2658: " Z-Shell script
line 2659: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2660: 
line 2661: 
line 2662: " Plain text files, needs to be far down to not override others.  This avoids
line 2663: " the "conf" type being used if there is a line starting with '#'.
line 2664: au BufNewFile,BufRead *.txt,*.text^I^Isetf text
line 2665: 
line 2666: 
line 2667: " Use the filetype detect plugins.  They may overrule any of the previously
line 2668: " detected filetypes.
line 2669: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/
Searching for "/Users/leostera/.vim/ftdetect/*.vim"
chdir(/Users/leostera/.vim/ftdetect)
fchdir() to previous dir
line 2669: sourcing "/Users/leostera/.vim/ftdetect/clojure.vim"
line 1: au BufNewFile,BufRead *.clj setf clojure
line 2: au BufNewFile,BufRead *.cljs setf clojure
line 3: 
finished sourcing /Users/leostera/.vim/ftdetect/clojure.vim
continuing in /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
Searching for "/Users/leostera/.vim/bundle/vundle/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftdetect/*.vim"
chdir(/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftdetect)
fchdir() to previous dir
line 2669: sourcing "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftdetect/mustache.vim"
line 1: if has("autocmd")
line 2:   au  BufNewFile,BufRead *.mustache,*.hogan,*.hulk,*.hjs set filetype=html.mustache syntax=mustache | runtime! ftplugin/mustache.vim ftplugin/mustache*.vim ftplugin/mustache/*.vim
line 3:   au  BufNewFile,BufRead *.handlebars,*.hbs set filetype=html.handlebars syntax=mustache | runtime! ftplugin/mustache.vim ftplugin/mustache*.vim ftplugin/mustache/*.vim
line 4: endif
finished sourcing /Users/leostera/.vim/bundle/vim-mustache-handlebars/ftdetect/mustache.vim
continuing in /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
Searching for "/Users/leostera/.vim/bundle/vim-javascript/ftdetect/*.vim"
chdir(/Users/leostera/.vim/bundle/vim-javascript/ftdetect)
fchdir() to previous dir
line 2669: sourcing "/Users/leostera/.vim/bundle/vim-javascript/ftdetect/javascript.vim"
line 1: au BufNewFile,BufRead *.js setf javascript
line 2: au BufNewFile,BufRead *.jsm setf javascript
line 3: au BufNewFile,BufRead Jakefile setf javascript
line 4: 
line 5: fun! s:SelectJavascript()
line 10: au BufNewFile,BufRead * call s:SelectJavascript()
finished sourcing /Users/leostera/.vim/bundle/vim-javascript/ftdetect/javascript.vim
continuing in /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
Searching for "/Users/leostera/.vim/bundle/emmet-vim/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/ftdetect/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftdetect/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftdetect/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/ftdetect/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/ftdetect/*.vim"
line 2670: 
line 2671: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2672: " and started another one. Let's make sure it has ended to get to a consistent
line 2673: " state.
line 2674: augroup END
line 2675: 
line 2676: " Generic configuration file (check this last, it's just guessing!)
line 2682: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif
line 2683: 
line 2684: 
line 2685: " If the GUI is already running, may still need to install the Syntax menu.
line 2686: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2688: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2689:   source <sfile>:p:h/menu.vim
line 2690: endif
line 2691: 
line 2692: " Function called for testing all functions defined here.  These are
line 2693: " script-local, thus need to be executed here.
line 2694: " Returns a string with error messages (hopefully empty).
line 2695: func! TestFiletypeFuncs(testlist)
line 2706: 
line 2707: " Restore 'cpoptions'
line 2708: let &cpo = s:cpo_save
line 2709: unlet s:cpo_save
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in /Users/leostera/.vimrc
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/leostera/.vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/filetype.vim"
Searching for "ftplugin.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.v
Searching for "/Users/leostera/.vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/ftplugin.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 41: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
line 8: endif
line 9: let did_load_ftplugin = 1
line 10: 
line 11: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
line 13: 
line 14:   func! s:LoadFTPlugin()
line 35: augroup END
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim
continuing in /Users/leostera/.vimrc
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/ftplugin.vim"
Searching for "indent.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim
Searching for "/Users/leostera/.vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/indent.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/indent.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/indent.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/indent.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/indent.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/indent.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 41: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
line 8: endif
line 9: let did_indent_on = 1
line 10: 
line 11: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
line 31: augroup END
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim
continuing in /Users/leostera/.vimrc
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/indent.vim"
Searching for "/Users/leostera/.vim/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/indent.vim"
line 42: 
line 43: " General Options
line 44: " enables syntax highligtning
line 45: syntax on
line 45: so $VIMRUNTIME/syntax/syntax.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 45: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leost
Searching for "/Users/leostera/.vim/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/syntax/synload.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/syntax/synload.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/syntax/synload.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 19: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2012 Sep 25
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leos
Searching for "/Users/leostera/.vim/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/syntax/syncolor.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/syntax/syncolor.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 21: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim
continuing in /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/syntax/syncolor.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL)
line 68: au Syntax c,cpp,cs,idl,php if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
line 73:   execute "source " . mysyntaxfile
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim
continuing in /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim
continuing in /Users/leostera/.vimrc
line 46: " allow backspace over everything in insert mode
line 47: set backspace=eol,start,indent
line 48: " optimizes screen redrawing
line 49: set lazyredraw
line 50: " sets encoding to utf-8, we don't want ASCII anymore
line 51: set encoding=utf8
line 52: " allows unsaved background buffers and remember marks/undo for them too
line 53: set hidden
line 54: " remember more commands and search history
line 55: set history=10000
line 56: 
line 57: " Editing options
line 58: set number
line 59: set expandtab
line 60: set smarttab
line 61: set tabstop=2
line 62: set softtabstop=2
line 63: set shiftwidth=2
line 64: 
line 65: " Search Options
line 66: set hlsearch
line 67: set incsearch
line 68: set showmatch
line 69: " make searches case-sensitive only if they contain upper-case characters
line 70: set ignorecase smartcase
line 71: 
line 72: " highlight current line
line 73: set cursorline
line 74: set cmdheight=1
line 75: set switchbuf=useopen
line 76: set showtabline=2
line 77: set winwidth=79
line 78: 
line 79: " Store temporary files in a central spot
line 80: set backup
line 81: set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
line 82: set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
line 83: 
line 84: " Status bar options
line 85: set ls=2
line 86: 
line 87: let mapleader=","
line 88: 
line 89: " Splits
line 90: " Create splits quickly
line 91: nnoremap <leader>v <esc>:vsplit<cr><c-w>l
line 92: nnoremap <leader>h <esc>:split<cr>gg<c-w>j
line 93: " – navigation
line 94: " Move around splits with <c-hjkl>
line 95: nnoremap <c-j> <c-w>j
line 96: nnoremap <c-k> <c-w>k
line 97: nnoremap <c-h> <c-w>h
line 98: nnoremap <c-l> <c-w>l
line 99: 
line 100: " tab navigation
line 101: " move to the tab on the right
line 102: map tl :tabn<CR>
line 103: " move to the tab on the left
line 104: map th :tabp<CR>
line 105: " move a tab in the stack
line 106: map tm :tabm 
line 107: " make a new tab
line 108: map tt :tabnew 
line 109: " duplicate a tab
line 110: map td :tab split<CR>
line 111: map <C-S-Right> :tabn<CR>
line 112: imap <C-S-Right> <ESC>:tabn<CR>
line 113: map <C-S-Left> :tabp<CR>
line 114: imap <C-S-Left> <ESC>:tabp<CR>
line 115: 
line 116: " Utilities
line 117: " switch buffer
line 118: map <leader><leader> <C-^>
line 119: nnoremap <leader>w <esc>:w<cr>
line 120: nnoremap <leader>q <esc>:wq!<cr>
line 121: 
line 122: " Show darkred background for columns over 80
line 123: highlight OverLength ctermbg=darkred ctermfg=white guibg=#592929
line 124: match OverLength /\%80v.\+/
line 125: set colorcolumn=80
line 126: 
line 127: " CtrlP Fuzzy Find options
line 128: let g:ctrlp_working_path_mode = 0
line 132: let g:ctrlp_custom_ignore = { 'dir':  '\v[\/](\.git|deps|ebin|\.hg|\.svn|node_modules|components|tmp|\.tmp)$', 'file': '\.pyc$\|\.pyo$|\.DS_Store$|\.sassc$|\.css.sassc$', }
line 133: 
line 134: " fast recursive grep
line 135: command! -nargs=1 FastGrep silent exec 'lgrep! <q-args> ./**/*.*' | lopen
line 136: nmap <leader>r :FastGrep 
line 137: cnoremap %% <C-R>=expand('%:h').'/'<cr>
line 138: 
line 139: autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
line 140: autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1
line 141: autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
finished sourcing $HOME/.vimrc
Searching for "plugin/**/*.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera
Searching for "/Users/leostera/.vim/plugin/**/*.vim"
chdir(/Users/leostera/.vim/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/plugin/paredit.vim"
line 1: " paredit.vim:
line 2: "               Paredit mode for Slimv
line 3: " Version:      0.9.13
line 4: " Last Change:  01 Dec 2014
line 5: " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
line 6: " License:      This file is placed in the public domain.
line 7: "               No warranty, express or implied.
line 8: "               *** ***   Use At-Your-Own-Risk!   *** ***
line 9: "
line 10: " =====================================================================
line 11: "
line 12: "  Load Once:
line 13: if &cp || exists( 'g:paredit_loaded' )
line 14:     finish
line 15: endif
line 16: 
line 17: let g:paredit_loaded = 1
line 18: 
line 19: " Needed to load filetype and indent plugins
line 20: filetype plugin on
Searching for "filetype.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.v
Searching for "/Users/leostera/.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/filetype.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 20: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2014 Feb 26
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in /Users/leostera/.vim/plugin/paredit.vim
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/leostera/.vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/filetype.vim"
Searching for "ftplugin.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.v
Searching for "/Users/leostera/.vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/ftplugin.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 20: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim
continuing in /Users/leostera/.vim/plugin/paredit.vim
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/ftplugin.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/ftplugin.vim"
line 21: filetype indent on
Searching for "filetype.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.v
Searching for "/Users/leostera/.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/filetype.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 21: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2014 Feb 26
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in /Users/leostera/.vim/plugin/paredit.vim
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/leostera/.vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/filetype.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/filetype.vim"
Searching for "indent.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera/.vim
Searching for "/Users/leostera/.vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/indent.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/indent.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/indent.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/indent.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/indent.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/indent.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 21: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim
continuing in /Users/leostera/.vim/plugin/paredit.vim
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/indent.vim"
Searching for "/Users/leostera/.vim/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/indent.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/indent.vim"
line 22: 
line 23: " =====================================================================
line 24: "  Global variable definitions
line 25: " =====================================================================
line 26: 
line 27: " Paredit mode selector
line 28: if !exists( 'g:paredit_mode' )
line 29:     let g:paredit_mode = 1
line 30: endif
line 31: 
line 32: " Match delimiter this number of lines before and after cursor position
line 33: if !exists( 'g:paredit_matchlines' )
line 34:     let g:paredit_matchlines = 100
line 35: endif
line 36: 
line 37: " Use short keymaps, i.e. J instead of <Leader>J
line 38: if !exists( 'g:paredit_shortmaps' )
line 39:     let g:paredit_shortmaps = 0
line 40: endif
line 41: 
line 42: " Use smart jumping to the nearest paren, curly brace, or square bracket in
line 43: " clojure
line 44: if !exists( 'g:paredit_smartjump' )
line 45:     let g:paredit_smartjump = 0
line 46: endif
line 47: 
line 48: " Custom <Leader> for the Paredit plugin
line 49: if !exists( 'g:paredit_leader' )
line 50:     if exists( 'mapleader' )
line 51:         let g:paredit_leader = '<leader>'
line 52:     else
line 53:         let g:paredit_leader = ','
line 54:     endif
line 55: endif
line 56: 
line 57: " Use 'Electric Return', i.e. add double newlines if enter pressed before a closing paren
line 58: if !exists( 'g:paredit_electric_return' )
line 59:     let g:paredit_electric_return = 1
line 60: endif
line 61: 
line 62: " =====================================================================
line 63: "  Other variable definitions
line 64: " =====================================================================
line 65: 
line 66: " Skip matches inside string or comment or after '\'
line 67: let s:skip_sc = '(synIDattr(synID(line("."), col("."), 0), "name") =~ "[Ss]tring\\|[Cc]omment\\|[Ss]pecial\\|clojureRegexp\\|clojurePattern" || getline(line("."))[col(".")-2] == "\\")'
line 68: 
line 69: " Valid macro prefix characters
line 70: let s:any_macro_prefix   = "'" . '\|`\|#\|@\|\~\|,\|\^'
line 71: 
line 72: " Repeat count for some remapped edit functions (like 'd')
line 73: let s:repeat             = 0
line 74: 
line 75: let s:yank_pos           = []
line 76: 
line 77: " Filetypes with [] and {} pairs balanced as well
line 78: let s:fts_balancing_all_brackets = '.*\(clojure\|hy\|scheme\|racket\).*'
line 79: 
line 80: " =====================================================================
line 81: "  General utility functions
line 82: " =====================================================================
line 83: " Buffer specific initialization
line 84: function! PareditInitBuffer()
line 239: 
line 240: " Run the command normally but append a call to repeat#set afterwards
line 241: function! RepeatableMap(map_type, keys, command)
line 247: 
line 248: function! RepeatableNMap(keys, command)
line 251: 
line 252: function! RepeatableNNoRemap(keys, command)
line 255: 
line 256: " Include all prefix and special characters in 'iskeyword'
line 257: function! s:SetKeyword()
line 266: 
line 267: " General Paredit operator function
line 268: function! PareditOpfunc( func, type, visualmode )
line 347: 
line 348: " Set delete mode also saving repeat count
line 349: function! PareditSetDelete( count )
line 353: 
line 354: " General delete operator handling
line 355: function! PareditDelete( type, ... )
line 362: 
line 363: " General change operator handling
line 364: function! PareditChange( type, ... )
line 383: 
line 384: " Delete v:count number of lines
line 385: function! PareditDeleteLines()
line 393: 
line 394: " Change v:count number of lines
line 395: function! PareditChangeLines()
line 403: 
line 404: " Handle special change command, e.g. cw
line 405: " Check if we may revert to its original Vim function
line 406: " This way '.' can be used to repeat the command
line 407: function! PareditChangeSpec( cmd, dir )
line 440: 
line 441: " Paste text from put register in a balanced way
line 442: function! PareditPut( cmd )
line 471: 
line 472: " Toggle paredit mode
line 473: function! PareditToggle()
line 481: 
line 482: " Does the current syntax item match the given regular expression?
line 483: function! s:SynIDMatch( regexp, line, col, match_eol )
line 490: 
line 491: " Is the current cursor position inside a comment?
line 492: function! s:InsideComment( ... )
line 511: 
line 512: " Is the current cursor position inside a string?
line 513: function! s:InsideString( ... )
line 527: 
line 528: " Is this a Slimv or VimClojure REPL buffer?
line 529: function! s:IsReplBuffer()
line 536: 
line 537: " Get Slimv or VimClojure REPL buffer last command prompt position
line 538: " Return [0, 0] if this is not the REPL buffer
line 539: function! s:GetReplPromptPos()
line 555: 
line 556: " Is the current top level form balanced, i.e all opening delimiters
line 557: " have a matching closing delimiter
line 558: function! s:IsBalanced()
line 619: 
line 620: " Filter out all non-matched characters from the region
line 621: function! s:GetMatchedChars( lines, start_in_string, start_in_comment )
line 658: 
line 659: " Find unpaired matched characters by eliminating paired ones
line 660: function! s:Unbalanced( matched )
line 686: 
line 687: " Find opening matched character
line 688: function! PareditFindOpening( open, close, select )
line 705: 
line 706: " Find closing matched character
line 707: function! PareditFindClosing( open, close, select )
line 726: 
line 727: " Returns the nearest opening character to the cursor
line 728: " Used for smart jumping in Clojure
line 729: function! PareditSmartJumpOpening( select )
line 744: 
line 745: " Returns the nearest opening character to the cursor
line 746: " Used for smart jumping in Clojure
line 747: function! PareditSmartJumpClosing( select )
line 762: 
line 763: " Find defun start backwards
line 764: function! PareditFindDefunBck()
line 788: 
line 789: " Find defun start forward
line 790: function! PareditFindDefunFwd()
line 805: 
line 806: " Insert opening type of a paired character, like ( or [.
line 807: function! PareditInsertOpening( open, close )
line 828: 
line 829: " Re-gather electric returns up
line 830: function! s:ReGatherUp()
line 852: 
line 853: " Insert closing type of a paired character, like ) or ].
line 854: function! PareditInsertClosing( open, close )
line 910: 
line 911: " Insert an (opening or closing) double quote
line 912: function! PareditInsertQuotes()
line 938: 
line 939: " Handle <Enter> keypress, insert electric return if applicable
line 940: function! PareditEnter()
line 956: 
line 957: " Handle <BS> keypress
line 958: function! PareditBackspace( repl_mode )
line 998: 
line 999: " Handle <Del> keypress
line 1000: function! PareditDel()
line 1032: 
line 1033: " Initialize yank position list
line 1034: function! s:InitYankPos()
line 1038: 
line 1039: " Add position to the yank list
line 1040: function! s:AddYankPos( pos )
line 1043: 
line 1044: " Remove the head of yank position list and return it
line 1045: function! s:RemoveYankPos()
line 1054: 
line 1055: " Forward erasing a character in normal mode, do not check if current form balanced
line 1056: function! s:EraseFwd( count, startcol )
line 1106: 
line 1107: " Backward erasing a character in normal mode, do not check if current form balanced
line 1108: function! s:EraseBck( count )
line 1144: 
line 1145: " Forward erasing a character in normal mode
line 1146: function! PareditEraseFwd()
line 1159: 
line 1160: " Backward erasing a character in normal mode
line 1161: function! PareditEraseBck()
line 1174: 
line 1175: " Find beginning of previous element (atom or sub-expression) in a form
line 1176: " skip_whitespc: skip whitespaces before the previous element
line 1177: function! s:PrevElement( skip_whitespc )
line 1261: 
line 1262: " Find end of next element (atom or sub-expression) in a form
line 1263: " skip_whitespc: skip whitespaces after the next element
line 1264: function! s:NextElement( skip_whitespc )
line 1333: 
line 1334: " Move character from [l0, c0] to [l1, c1]
line 1335: " Set position to [l1, c1]
line 1336: function! s:MoveChar( l0, c0, l1, c1 )
line 1366: 
line 1367: " Find a paren nearby to move
line 1368: function! s:FindParenNearby()
line 1391: 
line 1392: " Reindent current form
line 1393: function! PareditReindentForm()
line 1401: 
line 1402: " Move delimiter one atom or s-expression to the left
line 1403: function! PareditMoveLeft()
line 1457: 
line 1458: " Move delimiter one atom or s-expression to the right
line 1459: function! PareditMoveRight()
line 1514: 
line 1515: " Find closing of the innermost structure: (...) or [...] or {...}
line 1516: " Return a list where first element is the closing character,
line 1517: " second and third is its position (line, column)
line 1518: function! s:FindClosing()
line 1562: 
line 1563: " Split list or string at the cursor position
line 1564: " Current symbol will be split into the second part
line 1565: function! PareditSplit()
line 1607: 
line 1608: " Join two neighboring lists or strings
line 1609: function! PareditJoin()
line 1638: 
line 1639: " Wrap current visual block in parens of the given kind
line 1640: function! s:WrapSelection( open, close )
line 1666: 
line 1667: " Wrap current visual block in parens of the given kind
line 1668: " Keep visual mode
line 1669: function! PareditWrapSelection( open, close )
line 1677: 
line 1678: " Wrap current symbol in parens of the given kind
line 1679: " If standing on a paren then wrap the whole s-expression
line 1680: " Stand on the opening paren (if not wrapping in "")
line 1681: function! PareditWrap( open, close )
line 1739: 
line 1740: " Splice current list into the containing list
line 1741: function! PareditSplice()
line 1764: 
line 1765: " Raise: replace containing form with the current symbol or sub-form
line 1766: function! PareditRaise()
line 1800: 
line 1801: " =====================================================================
line 1802: "  Autocommands
line 1803: " =====================================================================
line 1804: 
line 1805: if !exists("g:paredit_disable_lisp")
line 1806:     au FileType lisp      call PareditInitBuffer()
line 1807: endif
line 1808: 
line 1809: if !exists("g:paredit_disable_clojure")
line 1810:     au FileType *clojure* call PareditInitBuffer()
line 1811: endif
line 1812: 
line 1813: if !exists("g:paredit_disable_hy")
line 1814:     au FileType hy        call PareditInitBuffer()
line 1815: endif
line 1816: 
line 1817: if !exists("g:paredit_disable_scheme")
line 1818:     au FileType scheme    call PareditInitBuffer()
line 1819:     au FileType racket    call PareditInitBuffer()
line 1820: endif
line 1821: 
finished sourcing /Users/leostera/.vim/plugin/paredit.vim
Searching for "/Users/leostera/.vim/bundle/vundle/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/emmet-vim/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/emmet-vim/plugin/emmet.vim"
line 1: "=============================================================================
line 2: " File: emmet.vim
line 3: " Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
line 4: " Last Change: 28-Nov-2013.
line 5: " Version: 0.85
line 6: " WebPage: http://github.com/mattn/emmet-vim
line 7: " Description: vim plugins for HTML and CSS hi-speed coding.
line 8: " SeeAlso: http://emmet.io/
line 9: " Usage:
line 10: "
line 11: "   This is vim script support expanding abbreviation like emmet.
line 12: "   ref: http://emmet.io/
line 13: "
line 14: "   Type abbreviation
line 15: "      +-------------------------------------
line 16: "      | html:5_
line 17: "      +-------------------------------------
line 18: "   "_" is a cursor position. and type "<c-y>," (Ctrl+y and Comma)
line 19: "   NOTE: Don't worry about key map. you can change it easily.
line 20: "      +-------------------------------------
line 21: "      | <!DOCTYPE HTML>
line 22: "      | <html lang="en">
line 23: "      | <head>
line 24: "      |     <title></title>
line 25: "      |     <meta charset="UTF-8">
line 26: "      | </head>
line 27: "      | <body>
line 28: "      |      _
line 29: "      | </body>
line 30: "      | </html>
line 31: "      +-------------------------------------
line 32: "   Type following
line 33: "      +-------------------------------------
line 34: "      | div#foo$*2>div.bar
line 35: "      +-------------------------------------
line 36: "   And type "<c-y>,"
line 37: "      +-------------------------------------
line 38: "      |<div id="foo1">
line 39: "      |    <div class="bar">_</div>
line 40: "      |</div>
line 41: "      |<div id="foo2">
line 42: "      |    <div class="bar"></div>
line 43: "      |</div>
line 44: "      +-------------------------------------
line 45: "
line 46: " Tips:
line 47: "
line 48: "   You can customize behavior of expanding with overriding config.
line 49: "   This configuration will be marged at loading plugin.
line 50: "
line 51: "     let g:user_emmet_settings = {
line 52: "     \  'indentation' : '  ',
line 53: "     \  'perl' : {
line 54: "     \    'aliases' : {
line 55: "     \      'req' : 'require '
line 56: "     \    },
line 57: "     \    'snippets' : {
line 58: "     \      'use' : "use strict\nuse warnings\n\n",
line 59: "     \      'warn' : "warn \"|\";",
line 60: "     \    }
line 61: "     \  }
line 62: "     \}
line 63: "
line 64: "   You can set language attribute in html using 'emmet_settings.lang'.
line 65: "
line 66: " GetLatestVimScripts: 2981 1 :AutoInstall: emmet.vim
line 67: " script type: plugin
line 68: 
line 69: if &cp || v:version < 702 || (exists('g:loaded_emmet_vim') && g:loaded_emmet_vim)
line 70:   finish
line 71: endif
line 72: let g:loaded_emmet_vim = 1
line 73: 
line 74: let s:save_cpo = &cpo
line 75: set cpo&vim
line 76: 
line 77: if !exists('g:emmet_html5')
line 78:   let g:emmet_html5 = 1
line 79: endif
line 80: 
line 81: if !exists('g:emmet_docroot')
line 82:   let g:emmet_docroot = {}
line 83: endif
line 84: 
line 85: if !exists('g:emmet_debug')
line 86:   let g:emmet_debug = 0
line 87: endif
line 88: 
line 89: if !exists('g:emmet_curl_command')
line 90:   let g:emmet_curl_command = 'curl -s -L -A Mozilla/5.0'
line 91: endif
line 92: 
line 93: if exists('g:user_emmet_complete_tag') && g:user_emmet_complete_tag
line 94:   setlocal omnifunc=emmet#completeTag
line 95: endif
line 96: 
line 97: if !exists('g:user_emmet_leader_key')
line 98:   let g:user_emmet_leader_key = '<c-y>'
line 99: endif
line 100: 
line 101: function! s:install_plugin(mode, buffer)
line 154: 
line 155: command! -nargs=0 EmmetInstall call <SID>install_plugin(get(g:, 'user_emmet_mode', 'a'), 1)
line 156: 
line 157: if get(g:, 'user_emmet_install_global', 1)
line 158:   call s:install_plugin(get(g:, 'user_emmet_mode', 'a'), 0)
calling function <SNR>16_install_plugin('a', 0)

line 1:   let buffer = a:buffer ? '<buffer>' : ''
line 2:   let items = [ {'mode': 'i', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(3,"")<cr>'}, {'mode': 'v', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(2,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': ':call emmet#expandAbbr(1,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>'}, {'mode': 'n', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '
line 35: 
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-expand-abbr) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(3,"")<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: vnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(2,"")<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: vmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-expand-word) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>; <plug>(emmet-expand-word)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-expand-word) :call emmet#expandAbbr(1,"")<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>; <plug>(emmet-expand-word)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-update-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>u <plug>(emmet-update-tag)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-update-tag) :call emmet#updateTag()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>u <plug>(emmet-update-tag)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-balance-tag-inward) <esc>:call emmet#balanceTag(1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: vnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(2)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: vmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-balance-tag-outword) <esc>:call emmet#balanceTag(-1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: vnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-2)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: vmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-move-next) <esc>:call emmet#moveNextPrev(0)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>n <plug>(emmet-move-next)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-move-next) :call emmet#moveNextPrev(0)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>n <plug>(emmet-move-next)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-move-prev) <esc>:call emmet#moveNextPrev(1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>N <plug>(emmet-move-prev)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-move-prev) :call emmet#moveNextPrev(1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>N <plug>(emmet-move-prev)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-image-size) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#imageSize()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>i <plug>(emmet-image-size)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-image-size) :call emmet#imageSize()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>i <plug>(emmet-image-size)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-toogle-comment) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#toggleComment()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>/ <plug>(emmet-toogle-comment)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-toogle-comment) :call emmet#toggleComment()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>/ <plug>(emmet-toogle-comment)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-split-join-tag) <esc>:call emmet#splitJoinTag()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-split-join-tag) :call emmet#splitJoinTag()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-remove-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#removeTag()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-remove-tag) :call emmet#removeTag()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-anchorize-url) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(0)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-anchorize-url) :call emmet#anchorizeURL(0)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: inoremap  <plug>(emmet-anchorize-summary) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: imap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: nnoremap  <plug>(emmet-anchorize-summary) :call emmet#anchorizeURL(1)<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: nmap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: vnoremap  <plug>(emmet-merge-lines) :call emmet#mergeLines()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: vmap  <unique> <c-y>m <plug>(emmet-merge-lines)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 41: vnoremap  <plug>(emmet-code-pretty) :call emmet#codePretty()<cr>
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 49: vmap  <unique> <c-y>c <plug>(emmet-code-pretty)
line 50:     endif
line 51:   endfor
line 36:   for item in items
line 37:     if a:mode != 'a' && stridx(a:mode, item.mode) == -1
line 38:       continue
line 39:     endif
line 40:     if !hasmapto('<plug>(' . item.plug . ')', item.mode)
line 41:       exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 42:     endif
line 43:     if exists('g:' . item.var)
line 44:       let key = eval('g:' . item.var)
line 45:     else
line 46:       let key = g:user_emmet_leader_key . item.key
line 47:     endif
line 48:     if len(maparg(key, item.mode)) == 0
line 49:       exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 50:     endif
line 51:   endfor
function <SNR>16_install_plugin returning #0

continuing in /Users/leostera/.vim/bundle/emmet-vim/plugin/emmet.vim

line 159: endif
line 160: 
line 161: if get(g:, 'user_emmet_install_command', 1)
line 162:   command! -nargs=1 Emmet call emmet#expandAbbr(4, <q-args>)
line 163: endif
line 164: 
line 165: let &cpo = s:save_cpo
line 166: unlet s:save_cpo
line 167: 
line 168: " vim:set et:
finished sourcing /Users/leostera/.vim/bundle/emmet-vim/plugin/emmet.vim
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/vim-indent-guides/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim"
line 1: " Author:   Nate Kane <nathanaelkane AT gmail DOT com>
line 2: " Homepage: http://github.com/nathanaelkane/vim-indent-guides
line 3: 
line 4: if exists('g:loaded_indent_guides') || &cp
line 5:   finish
line 6: endif
line 7: let g:loaded_indent_guides = 1
line 8: call indent_guides#define_default_highlights()
Searching for "autoload/indent_guides.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Use
Searching for "/Users/leostera/.vim/autoload/indent_guides.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/indent_guides.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/indent_guides.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/indent_guides.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/indent_guides.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim"
chdir(/Users/leostera/.vim/bundle/vim-indent-guides/autoload)
fchdir() to previous dir
line 8: sourcing "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim"
line 1: " Author:   Nate Kane <nathanaelkane AT gmail DOT com>
line 2: " Homepage: http://github.com/nathanaelkane/vim-indent-guides
line 3: 
line 4: "
line 5: " Toggles the indent guides on and off.
line 6: "
line 7: function! indent_guides#toggle()
line 16: 
line 17: "
line 18: " Called from autocmds, keeps indent guides enabled or disabled when entering
line 19: " other buffers and windows.
line 20: "
line 21: function! indent_guides#process_autocmds()
line 28: 
line 29: "
line 30: " Enables the indent guides for the current buffer and any other buffer upon
line 31: " entering it.
line 32: "
line 33: function! indent_guides#enable()
line 60: 
line 61: "
line 62: " Disables the indent guides for the current buffer and any other buffer upon
line 63: " entering it.
line 64: "
line 65: function! indent_guides#disable()
line 69: 
line 70: "
line 71: " Clear all highlight matches for the current window.
line 72: "
line 73: function! indent_guides#clear_matches()
line 88: 
line 89: "
line 90: " Automagically calculates and defines the indent highlight colors.
line 91: "
line 92: function! indent_guides#highlight_colors()
line 101: 
line 102: "
line 103: " Defines some basic indent highlight colors that work for Terminal Vim and
line 104: " gVim when colors can't be automatically calculated.
line 105: "
line 106: function! indent_guides#basic_highlight_colors()
line 113: 
line 114: "
line 115: " Automagically calculates and defines the indent highlight colors for gui
line 116: " vim.
line 117: "
line 118: function! indent_guides#gui_highlight_colors()
line 146: 
line 147: "
line 148: " Takes a color and darkens or lightens it depending on whether a dark or light
line 149: " colorscheme is being used.
line 150: "
line 151: function! indent_guides#lighten_or_darken_color(color)
line 162: 
line 163: "
line 164: " Define default highlights.
line 165: "
line 166: function! indent_guides#define_default_highlights()
line 170: 
line 171: "
line 172: " Init the w:indent_guides_matches variable.
line 173: "
line 174: function! indent_guides#init_matches()
line 177: 
line 178: "
line 179: " We need to initialize these vars every time a buffer is entered while the
line 180: " plugin is enabled.
line 181: "
line 182: function! indent_guides#init_script_vars()
line 219: 
line 220: "
line 221: " Calculate the indent guide size. Ensures the guide size is less than or
line 222: " equal to the actual indent size, otherwise some weird things can occur.
line 223: "
line 224: " NOTE: Currently, this only works when soft-tabs are being used.
line 225: "
line 226: function! indent_guides#calculate_guide_size()
line 235: 
line 236: "
line 237: " Captures and returns the output of highlight group definitions.
line 238: "
line 239: " Example: indent_guides#capture_highlight('normal')
line 240: " Returns: 'Normal xxx guifg=#323232 guibg=#ffffff'
line 241: "
line 242: function! indent_guides#capture_highlight(group_name)
line 250: 
line 251: "
line 252: " Returns a regex pattern for highlighting an indent level.
line 253: "
line 254: " Example: indent_guides#indent_highlight_pattern(' ', 1, 4)
line 255: " Returns: /^ *\%1v\zs *\%5v\ze/
line 256: "
line 257: " Example: indent_guides#indent_highlight_pattern('\s', 5, 2)
line 258: " Returns: /^\s*\%5v\zs\s*\%7v\ze/
line 259: "
line 260: " Example: indent_guides#indent_highlight_pattern('\t', 9, 2)
line 261: " Returns: /^\t*\%9v\zs\t*\%11v\ze/
line 262: "
line 263: function! indent_guides#indent_highlight_pattern(indent_pattern, column_start, indent_size)
line 269: 
line 270: "
line 271: " Detect if any of the buffer filetypes should be excluded.
line 272: "
line 273: function! indent_guides#exclude_filetype()
finished sourcing /Users/leostera/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim
continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim
calling function indent_guides#define_default_highlights()

line 1:   hi default clear IndentGuidesOdd
line 2:   hi default clear IndentGuidesEven
function indent_guides#define_default_highlights returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 9: 
line 10: function! s:IndentGuidesToggle()
line 13: 
line 14: function! s:IndentGuidesEnable()
line 17: 
line 18: function! s:IndentGuidesDisable()
line 21: 
line 22: " Commands
line 23: command! -bar IndentGuidesToggle  call s:IndentGuidesToggle()
line 24: command! -bar IndentGuidesEnable  call s:IndentGuidesEnable()
line 25: command! -bar IndentGuidesDisable call s:IndentGuidesDisable()
line 26: 
line 27: "
line 28: " Initializes a given variable to a given value. The variable is only
line 29: " initialized if it does not exist prior.
line 30: "
line 31: function s:InitVariable(var, value)
line 40: 
line 41: " Fixed global variables
line 42: let g:indent_guides_autocmds_enabled         = 0
line 43: let g:indent_guides_color_hex_pattern        = '#[0-9A-Fa-f]\{6\}'
line 44: let g:indent_guides_color_hex_guibg_pattern  = 'guibg=\zs' . g:indent_guides_color_hex_pattern . '\ze'
line 45: let g:indent_guides_color_name_guibg_pattern = "guibg='\\?\\zs[0-9A-Za-z ]\\+\\ze'\\?"
line 46: 
line 47: " Configurable global variables
line 48: call s:InitVariable('g:indent_guides_indent_levels', 30)
calling function <SNR>17_InitVariable('g:indent_guides_indent_levels', 30)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_indent_levels = 30
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 49: call s:InitVariable('g:indent_guides_auto_colors', 1)
calling function <SNR>17_InitVariable('g:indent_guides_auto_colors', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_auto_colors = 1
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 50: call s:InitVariable('g:indent_guides_color_change_percent', 10) " ie. 10%
calling function <SNR>17_InitVariable('g:indent_guides_color_change_percent', 10)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_color_change_percent = 10
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 51: call s:InitVariable('g:indent_guides_guide_size', 0)
calling function <SNR>17_InitVariable('g:indent_guides_guide_size', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_guide_size = 0
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 52: call s:InitVariable('g:indent_guides_start_level', 1)
calling function <SNR>17_InitVariable('g:indent_guides_start_level', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_start_level = 1
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 53: call s:InitVariable('g:indent_guides_enable_on_vim_startup', 0)
calling function <SNR>17_InitVariable('g:indent_guides_enable_on_vim_startup', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_enable_on_vim_startup = 0
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 54: call s:InitVariable('g:indent_guides_debug', 0)
calling function <SNR>17_InitVariable('g:indent_guides_debug', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_debug = 0
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 55: call s:InitVariable('g:indent_guides_space_guides', 1)
calling function <SNR>17_InitVariable('g:indent_guides_space_guides', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_space_guides = 1
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 56: call s:InitVariable('g:indent_guides_soft_pattern', '\s')
calling function <SNR>17_InitVariable('g:indent_guides_soft_pattern', '\s')

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 3: let g:indent_guides_soft_pattern = '\s'
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 57: call s:InitVariable('g:indent_guides_default_mapping', 1)
calling function <SNR>17_InitVariable('g:indent_guides_default_mapping', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:value) == type("")
line 3:       exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
line 4:     else
line 5:       exec 'let ' . a:var . ' = ' .  a:value
line 5: let g:indent_guides_default_mapping = 1
line 6:     endif
line 7:   endif
function <SNR>17_InitVariable returning #0

continuing in /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim

line 58: 
line 59: if !exists('g:indent_guides_exclude_filetypes')
line 60:   let g:indent_guides_exclude_filetypes = ['help']
line 61: endif
line 62: 
line 63: " Default mapping
line 65: if !hasmapto('<Plug>IndentGuidesToggle', 'n') && maparg('<Leader>ig', 'n') == '' && g:indent_guides_default_mapping != 0
line 66:   nmap <silent><unique> <Leader>ig <Plug>IndentGuidesToggle
line 67: endif
line 68: 
line 69: " Plug mappings
line 70: nnoremap <unique><script> <Plug>IndentGuidesToggle  :IndentGuidesToggle<CR>
line 71: nnoremap <unique><script> <Plug>IndentGuidesEnable  :IndentGuidesEnable<CR>
line 72: nnoremap <unique><script> <Plug>IndentGuidesDisable :IndentGuidesDisable<CR>
line 73: 
line 74: " Auto commands
line 75: augroup indent_guides
line 76:   autocmd!
line 77: 
line 78:   if g:indent_guides_enable_on_vim_startup
line 79:     autocmd VimEnter * :IndentGuidesEnable
line 80:   endif
line 81: 
line 82:   autocmd BufEnter,WinEnter,FileType * call indent_guides#process_autocmds()
line 83: 
line 84:   " Trigger BufEnter and process modelines.
line 85:   autocmd ColorScheme * doautocmd indent_guides BufEnter
line 86: augroup END
finished sourcing /Users/leostera/.vim/bundle/vim-indent-guides/plugin/indent_guides.vim
Searching for "/Users/leostera/.vim/bundle/syntastic/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim"
line 1: if exists("g:loaded_syntastic_notifier_autoloclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/balloons.vim"
line 1: if exists("g:loaded_syntastic_notifier_balloons") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/checker.vim"
line 1: if exists("g:loaded_syntastic_checker") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/checker.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/cursor.vim"
line 1: if exists("g:loaded_syntastic_notifier_cursor") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim"
line 1: if exists("g:loaded_syntastic_notifier_highlighting") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/loclist.vim"
line 1: if exists("g:loaded_syntastic_loclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/modemap.vim"
line 1: if exists("g:loaded_syntastic_modemap") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim"
line 1: if exists("g:loaded_syntastic_notifiers") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/registry.vim"
line 1: if exists("g:loaded_syntastic_registry") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/registry.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/signs.vim"
line 1: if exists("g:loaded_syntastic_notifier_signs") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/signs.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim"
line 1: "============================================================================
line 2: "File:        syntastic.vim
line 3: "Description: Vim plugin for on the fly syntax checking.
line 4: "License:     This program is free software. It comes without any warranty,
line 5: "             to the extent permitted by applicable law. You can redistribute
line 6: "             it and/or modify it under the terms of the Do What The Fuck You
line 7: "             Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "             See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: "============================================================================
line 11: 
line 12: if exists("g:loaded_syntastic_plugin")
line 13:     finish
line 14: endif
line 15: let g:loaded_syntastic_plugin = 1
line 16: 
line 17: if has('reltime')
line 18:     let g:syntastic_start = reltime()
line 19:     lockvar! g:syntastic_start
line 20: endif
line 21: 
line 22: let g:syntastic_version = '3.5.0-7'
line 23: lockvar g:syntastic_version
line 24: 
line 25: " Sanity checks {{{1
line 26: 
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 33: 
line 34: let s:running_windows = syntastic#util#isRunningWindows()
Searching for "autoload/syntastic/util.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Us
Searching for "/Users/leostera/.vim/autoload/syntastic/util.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/syntastic/util.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/syntastic/util.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/syntastic/util.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/syntastic/util.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/syntastic/util.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/syntastic/util.vim"
chdir(/Users/leostera/.vim/bundle/syntastic/autoload/syntastic)
fchdir() to previous dir
line 34: sourcing "/Users/leostera/.vim/bundle/syntastic/autoload/syntastic/util.vim"
line 1: if exists('g:loaded_syntastic_util_autoload') || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_util_autoload = 1
line 5: 
line 6: let s:save_cpo = &cpo
line 7: set cpo&vim
line 8: 
line 9: " Public functions {{{1
line 10: 
line 11: function! syntastic#util#isRunningWindows() " {{{2
line 14: 
line 15: function! syntastic#util#DevNull() " {{{2
line 21: 
line 22: " Get directory separator
line 23: function! syntastic#util#Slash() abort " {{{2
line 26: 
line 27: "search the first 5 lines of the file for a magic number and return a map
line 28: "containing the args and the executable
line 29: "
line 30: "e.g.
line 31: "
line 32: "#!/usr/bin/perl -f -bar
line 33: "
line 34: "returns
line 35: "
line 36: "{'exe': '/usr/bin/perl', 'args': ['-f', '-bar']}
line 37: function! syntastic#util#parseShebang() " {{{2
line 50: 
line 51: " Get the value of a variable.  Allow local variables to override global ones.
line 52: function! syntastic#util#var(name, ...) " {{{2
line 58: 
line 59: " Parse a version string.  Return an array of version components.
line 60: function! syntastic#util#parseVersion(version) " {{{2
line 63: 
line 64: " Run 'command' in a shell and parse output as a version string.
line 65: " Returns an array of version components.
line 66: function! syntastic#util#getVersion(command) " {{{2
line 69: 
line 70: " Verify that the 'installed' version is at least the 'required' version.
line 71: "
line 72: " 'installed' and 'required' must be arrays. If they have different lengths,
line 73: " the "missing" elements will be assumed to be 0 for the purposes of checking.
line 74: "
line 75: " See http://semver.org for info about version numbers.
line 76: function! syntastic#util#versionIsAtLeast(installed, required) " {{{2
line 79: 
line 80: " Almost lexicographic comparison of two lists of integers. :) If lists
line 81: " have different lengths, the "missing" elements are assumed to be 0.
line 82: function! syntastic#util#compareLexi(a, b) " {{{2
line 93: 
line 94: " strwidth() was added in Vim 7.3; if it doesn't exist, we use strlen()
line 95: " and hope for the best :)
line 96: let s:width = function(exists('*strwidth') ? 'strwidth' : 'strlen')
line 97: lockvar s:width
line 98: 
line 99: function! syntastic#util#screenWidth(str, tabstop) " {{{2
line 108: 
line 109: "print as much of a:msg as possible without "Press Enter" prompt appearing
line 110: function! syntastic#util#wideMsg(msg) " {{{2
line 132: 
line 133: " Check whether a buffer is loaded, listed, and not hidden
line 134: function! syntastic#util#bufIsActive(buffer) " {{{2
line 151: 
line 152: " start in directory a:where and walk up the parent folders until it
line 153: " finds a file matching a:what; return path to that file
line 154: function! syntastic#util#findInParent(what, where) " {{{2
line 184: 
line 185: " Returns unique elements in a list
line 186: function! syntastic#util#unique(list) " {{{2
line 197: 
line 198: " A less noisy shellescape()
line 199: function! syntastic#util#shescape(string) " {{{2
line 202: 
line 203: " A less noisy shellescape(expand())
line 204: function! syntastic#util#shexpand(string) " {{{2
line 207: 
line 208: " decode XML entities
line 209: function! syntastic#util#decodeXMLEntities(string) " {{{2
line 218: 
line 219: function! syntastic#util#redraw(full) " {{{2
line 226: 
line 227: function! syntastic#util#dictFilter(errors, filter) " {{{2
line 237: 
line 238: " Return a [high, low] list of integers, representing the time
line 239: " (hopefully high resolution) since program start
line 240: " TODO: This assumes reltime() returns a list of integers.
line 241: function! syntastic#util#stamp() " {{{2
line 244: 
line 245: " }}}1
line 246: 
line 247: " Private functions {{{1
line 248: 
line 249: function! s:_translateFilter(filters) " {{{2
line 264: 
line 265: function! s:_translateElement(key, term) " {{{2
line 280: 
line 281: " }}}1
line 282: 
line 283: let &cpo = s:save_cpo
line 284: unlet s:save_cpo
line 285: 
line 286: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/autoload/syntastic/util.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
calling function syntastic#util#isRunningWindows()

line 1:     return has('win16') || has('win32') || has('win64')
function syntastic#util#isRunningWindows returning #0

continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim

line 35: lockvar s:running_windows
line 36: 
line 37: if !s:running_windows && executable('uname')
line 38:     try
line 39:         let s:uname = system('uname')
Calling shell to execute: "(uname) > /var/folders/zs/xl3rmn054_l6td2l5g20vkc00000gn/T/vf2Zzoe/0"
line 40:     catch /\m^Vim\%((\a\+)\)\=:E484/
line 41:         call syntastic#log#error("your shell " . &shell . " doesn't use traditional UNIX syntax for redirections")
line 42:         finish
line 43:     endtry
line 44:     lockvar s:uname
line 45: endif
line 46: 
line 47: " }}}1
line 48: 
line 49: " Defaults {{{1
line 50: 
line 80: let g:syntastic_defaults = { 'aggregate_errors':         0, 'always_populate_loc_list': 0, 'auto_jump':                0, 'auto_loc_list':            2, 'bash_hack':                1, 'check_on_open':            0, 'check_on_wq':              1, 'cursor_columns':           1, 'debug':                    0, 'echo_current_error':       1, 'enable_balloons':          1, 'enable_highlighting':      1, 'enable_signs':             1, 'error_symbol':             '>>', 'exit_checks':              !(s:running_windows && &shell =~? '\m\<cmd\.exe$'), 'filetype_map':             {}, 'full_redraws':             !(has('gui_running') || has('gui_macvim')), 'id_checkers':              1, 'ignore_extensions':        '\c\v^([gx]?z|lzma|bz2)$', 'ignore_files':             [], 'loc_list_height':          10, 'quiet_messages':           {}, 'reuse_loc_lists':          0, 'sort_aggregated_errors':   1, 'stl_format':               '[Syntax: line:%F (%t)]', 'style_error_symbol':       'S>', 'style_warning_symbol':     'S>',
line 81: lockvar! g:syntastic_defaults
line 82: 
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 88: 
line 89: if exists("g:syntastic_quiet_warnings")
line 90:     call syntastic#log#oneTimeWarn("variable g:syntastic_quiet_warnings is deprecated, please use let g:syntastic_quiet_messages = {'level': 'warnings'} instead")
line 91:     if g:syntastic_quiet_warnings
line 92:         let s:quiet_warnings = get(g:syntastic_quiet_messages, 'type', [])
line 93:         if type(s:quiet_warnings) != type([])
line 94:             let s:quiet_warnings = [s:quiet_warnings]
line 95:         endif
line 96:         call add(s:quiet_warnings, 'warnings')
line 97:         let g:syntastic_quiet_messages['type'] = s:quiet_warnings
line 98:     endif
line 99: endif
line 100: 
line 101: " }}}1
line 102: 
line 103: " Debug {{{1
line 104: 
line 114: let s:debug_dump_options = [ 'shell', 'shellcmdflag', 'shellpipe', 'shellquote', 'shellredir', 'shellslash', 'shelltemp', 'shellxquote' ]
line 115: if v:version > 703 || (v:version == 703 && has('patch446'))
line 116:     call add(s:debug_dump_options, 'shellxescape')
line 117: endif
line 118: lockvar! s:debug_dump_options
line 119: 
line 120: " debug constants
line 121: let     g:SyntasticDebugTrace         = 1
line 122: lockvar g:SyntasticDebugTrace
line 123: let     g:SyntasticDebugLoclist       = 2
line 124: lockvar g:SyntasticDebugLoclist
line 125: let     g:SyntasticDebugNotifications = 4
line 126: lockvar g:SyntasticDebugNotifications
line 127: let     g:SyntasticDebugAutocommands  = 8
line 128: lockvar g:SyntasticDebugAutocommands
line 129: let     g:SyntasticDebugVariables     = 16
line 130: lockvar g:SyntasticDebugVariables
line 131: 
line 132: " }}}1
line 133: 
line 134: runtime! plugin/syntastic/*.vim
Searching for "plugin/syntastic/*.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/l
Searching for "/Users/leostera/.vim/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/*.vim"
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim"
line 1: if exists("g:loaded_syntastic_notifier_autoloclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_autoloclist = 1
line 5: 
line 6: let g:SyntasticAutoloclistNotifier = {}
line 7: 
line 8: " Public methods {{{1
line 9: "
line 10: function! g:SyntasticAutoloclistNotifier.New() " {{{2
line 14: 
line 15: function! g:SyntasticAutoloclistNotifier.refresh(loclist) " {{{2
line 19: 
line 20: function! g:SyntasticAutoloclistNotifier.AutoToggle(loclist) " {{{2
line 35: 
line 36: " }}}1
line 37: 
line 38: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/balloons.vim"
line 1: if exists("g:loaded_syntastic_notifier_balloons") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_balloons = 1
line 5: 
line 6: if !has('balloon_eval')
line 7:     let g:syntastic_enable_balloons = 0
line 8: endif
line 9: 
line 10: let g:SyntasticBalloonsNotifier = {}
line 11: 
line 12: " Public methods {{{1
line 13: 
line 14: function! g:SyntasticBalloonsNotifier.New() " {{{2
line 18: 
line 19: function! g:SyntasticBalloonsNotifier.enabled() " {{{2
line 22: 
line 23: " Update the error balloons
line 24: function! g:SyntasticBalloonsNotifier.refresh(loclist) " {{{2
line 42: 
line 43: " Reset the error balloons
line 44: " @vimlint(EVL103, 1, a:loclist)
line 45: function! g:SyntasticBalloonsNotifier.reset(loclist) " {{{2
line 52: " @vimlint(EVL103, 0, a:loclist)
line 53: 
line 54: " }}}1
line 55: 
line 56: " Private functions {{{1
line 57: 
line 58: function! SyntasticBalloonsExprNotifier() " {{{2
line 64: 
line 65: " }}}1
line 66: 
line 67: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/checker.vim"
line 1: if exists("g:loaded_syntastic_checker") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_checker = 1
line 5: 
line 6: let g:SyntasticChecker = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticChecker.New(args) " {{{2
line 39: 
line 40: function! g:SyntasticChecker.getFiletype() " {{{2
line 43: 
line 44: function! g:SyntasticChecker.getName() " {{{2
line 47: 
line 48: function! g:SyntasticChecker.getExec() " {{{2
line 55: 
line 56: function! g:SyntasticChecker.getExecEscaped() " {{{2
line 59: 
line 60: function! g:SyntasticChecker.getLocListRaw() " {{{2
line 74: 
line 75: function! g:SyntasticChecker.getLocList() " {{{2
line 78: 
line 79: function! g:SyntasticChecker.getWantSort() " {{{2
line 82: 
line 83: function! g:SyntasticChecker.setWantSort(val) " {{{2
line 86: 
line 87: function! g:SyntasticChecker.makeprgBuild(opts) " {{{2
line 99: 
line 100: function! g:SyntasticChecker.isAvailable() " {{{2
line 106: 
line 107: " }}}1
line 108: 
line 109: " Private methods {{{1
line 110: 
line 111: function! g:SyntasticChecker._quietMessages(errors) " {{{2
line 135: 
line 136: function! g:SyntasticChecker._populateHighlightRegexes(errors) " {{{2
line 148: 
line 149: function! g:SyntasticChecker._getOpt(opts, basename, name, default) " {{{2
line 157: 
line 158: function! g:SyntasticChecker._shescape(opt) " {{{2
line 167: 
line 168: " }}}1
line 169: 
line 170: " Non-method functions {{{1
line 171: 
line 172: function! SyntasticCheckerIsAvailableDefault() dict " {{{2
line 175: 
line 176: " }}}1
line 177: 
line 178: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/checker.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/cursor.vim"
line 1: if exists("g:loaded_syntastic_notifier_cursor") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_cursor = 1
line 5: 
line 6: let g:SyntasticCursorNotifier = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticCursorNotifier.New() " {{{2
line 14: 
line 15: function! g:SyntasticCursorNotifier.enabled() " {{{2
line 18: 
line 19: function! g:SyntasticCursorNotifier.refresh(loclist) " {{{2
line 29: 
line 30: " @vimlint(EVL103, 1, a:loclist)
line 31: function! g:SyntasticCursorNotifier.reset(loclist) " {{{2
line 37: " @vimlint(EVL103, 0, a:loclist)
line 38: 
line 39: " }}}1
line 40: 
line 41: " Private methods {{{1
line 42: 
line 43: function! SyntasticRefreshCursor() " {{{2
line 91: 
line 92: " }}}1
line 93: 
line 94: " Private functions {{{1
line 95: 
line 96: function! s:_isSameIndex(line, old_line, column, idx, messages) " {{{2
line 115: 
line 116: function! s:_findIndex(column, messages) " {{{2
line 135: 
line 136: " }}}1
line 137: 
line 138: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim"
line 1: if exists("g:loaded_syntastic_notifier_highlighting") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_highlighting = 1
line 5: 
line 6: " Highlighting requires getmatches introduced in 7.1.040
line 7: let s:has_highlighting = v:version > 701 || (v:version == 701 && has('patch040'))
line 8: lockvar s:has_highlighting
line 9: 
line 10: let g:SyntasticHighlightingNotifier = {}
line 11: 
line 12: let s:setup_done = 0
line 13: 
line 14: " Public methods {{{1
line 15: 
line 16: function! g:SyntasticHighlightingNotifier.New() " {{{2
line 27: 
line 28: function! g:SyntasticHighlightingNotifier.enabled() " {{{2
line 31: 
line 32: " Sets error highlights in the cuirrent window
line 33: function! g:SyntasticHighlightingNotifier.refresh(loclist) " {{{2
line 61: 
line 62: " Remove all error highlights from the window
line 63: " @vimlint(EVL103, 1, a:loclist)
line 64: function! g:SyntasticHighlightingNotifier.reset(loclist) " {{{2
line 70: " @vimlint(EVL103, 0, a:loclist)
line 71: 
line 72: " }}}1
line 73: 
line 74: " Private methods {{{1
line 75: 
line 76: " One time setup: define our own highlighting
line 77: function! g:SyntasticHighlightingNotifier._setup() " {{{2
line 93: 
line 94: function! g:SyntasticHighlightingNotifier._reset() " {{{2
line 101: 
line 102: " }}}1
line 103: 
line 104: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/loclist.vim"
line 1: if exists("g:loaded_syntastic_loclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_loclist = 1
line 5: 
line 6: let g:SyntasticLoclist = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticLoclist.New(rawLoclist) " {{{2
line 29: 
line 30: function! g:SyntasticLoclist.current() " {{{2
line 36: 
line 37: function! g:SyntasticLoclist.extend(other) " {{{2
line 42: 
line 43: function! g:SyntasticLoclist.sort() " {{{2
line 54: 
line 55: function! g:SyntasticLoclist.isEmpty() " {{{2
line 58: 
line 59: function! g:SyntasticLoclist.isNewerThan(stamp) " {{{2
line 66: 
line 67: function! g:SyntasticLoclist.copyRaw() " {{{2
line 70: 
line 71: function! g:SyntasticLoclist.getRaw() " {{{2
line 74: 
line 75: function! g:SyntasticLoclist.getBuffers() " {{{2
line 78: 
line 79: function! g:SyntasticLoclist.getCursorColumns() " {{{2
line 82: 
line 83: function! g:SyntasticLoclist.getStatuslineFlag() " {{{2
line 135: 
line 136: function! g:SyntasticLoclist.getFirstIssue() " {{{2
line 139: 
line 140: function! g:SyntasticLoclist.getName() " {{{2
line 143: 
line 144: function! g:SyntasticLoclist.setName(name) " {{{2
line 147: 
line 148: function! g:SyntasticLoclist.getOwner() " {{{2
line 151: 
line 152: function! g:SyntasticLoclist.setOwner(buffer) " {{{2
line 155: 
line 156: function! g:SyntasticLoclist.deploy() " {{{2
line 163: 
line 164: function! g:SyntasticLoclist.destroy() " {{{2
line 169: 
line 170: function! g:SyntasticLoclist.decorate(tag) " {{{2
line 175: 
line 176: function! g:SyntasticLoclist.errors() " {{{2
line 182: 
line 183: function! g:SyntasticLoclist.warnings() " {{{2
line 189: 
line 190: " Legacy function.  Syntastic no longer calls it, but we keep it
line 191: " around because other plugins (f.i. powerline) depend on it.
line 192: function! g:SyntasticLoclist.hasErrorsOrWarningsToDisplay() " {{{2
line 195: 
line 196: " cache used by EchoCurrentError()
line 197: function! g:SyntasticLoclist.messages(buf) " {{{2
line 241: 
line 242: "Filter the list and return new native loclist
line 243: "e.g.
line 244: "  .filter({'bufnr': 10, 'type': 'e'})
line 245: "
line 246: "would return all errors for buffer 10.
line 247: "
line 248: "Note that all comparisons are done with ==?
line 249: function! g:SyntasticLoclist.filter(filters) " {{{2
line 255: 
line 256: function! g:SyntasticLoclist.setloclist() " {{{2
line 265: 
line 266: "display the cached errors for this buf in the location list
line 267: function! g:SyntasticLoclist.show() " {{{2
line 297: 
line 298: " }}}1
line 299: 
line 300: " Non-method functions {{{1
line 301: 
line 302: function! SyntasticLoclistHide() " {{{2
line 306: 
line 307: " }}}1
line 308: 
line 309: " Private functions {{{1
line 310: 
line 311: function! s:_translate(key, val) " {{{2
line 314: 
line 315: function! s:_setScreenColumn(item) " {{{2
line 331: 
line 332: function! s:_removeShadowedItems(errors) " {{{2
line 363: 
line 364: function! s:_compareErrorItemsByColumns(a, b) " {{{2
line 381: 
line 382: function! s:_compareErrorItemsByLines(a, b) " {{{2
line 397: 
line 398: " }}}1
line 399: 
line 400: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/modemap.vim"
line 1: if exists("g:loaded_syntastic_modemap") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_modemap = 1
line 5: 
line 6: let g:SyntasticModeMap = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticModeMap.Instance() " {{{2
line 18: 
line 19: function! g:SyntasticModeMap.synch() " {{{2
line 30: 
line 31: function! g:SyntasticModeMap.allowsAutoChecking(filetype) " {{{2
line 40: 
line 41: function! g:SyntasticModeMap.isPassive() " {{{2
line 44: 
line 45: function! g:SyntasticModeMap.toggleMode() " {{{2
line 60: 
line 61: function! g:SyntasticModeMap.echoMode() " {{{2
line 64: 
line 65: function! g:SyntasticModeMap.modeInfo(...) " {{{2
line 85: 
line 86: " }}}1
line 87: 
line 88: " Private methods {{{1
line 89: 
line 90: function! g:SyntasticModeMap._isOneFiletypeActive(filetypes) " {{{2
line 93: 
line 94: function! g:SyntasticModeMap._noFiletypesArePassive(filetypes) " {{{2
line 97: 
line 98: " }}}1
line 99: 
line 100: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim"
line 1: if exists("g:loaded_syntastic_notifiers") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifiers = 1
line 5: 
line 6: let g:SyntasticNotifiers = {}
line 7: 
line 8: let s:notifier_types = ['signs', 'balloons', 'highlighting', 'cursor', 'autoloclist']
line 9: lockvar! s:notifier_types
line 10: 
line 11: let s:persistent_notifiers = ['signs', 'balloons']
line 12: lockvar! s:persistent_notifiers
line 13: 
line 14: " Public methods {{{1
line 15: 
line 16: function! g:SyntasticNotifiers.Instance() " {{{2
line 24: 
line 25: function! g:SyntasticNotifiers.refresh(loclist) " {{{2
line 50: 
line 51: function! g:SyntasticNotifiers.reset(loclist) " {{{2
line 69: 
line 70: " }}}1
line 71: 
line 72: " Private methods {{{1
line 73: 
line 74: function! g:SyntasticNotifiers._initNotifiers() " {{{2
line 83: 
line 84: " }}}1
line 85: 
line 86: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/registry.vim"
line 1: if exists("g:loaded_syntastic_registry") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_registry = 1
line 5: 
line 6: " Initialisation {{{1
line 7: 
line 93: let s:defaultCheckers = { 'actionscript':['mxmlc'], 'ada':         ['gcc'], 'applescript': ['osacompile'], 'arduino':     ['avrgcc'], 'asciidoc':    ['asciidoc'], 'asm':         ['gcc'], 'bro':         ['bro'], 'bemhtml':     ['bemhtmllint'], 'c':           ['gcc'], 'cabal':       ['cabal'], 'chef':        ['foodcritic'], 'co':          ['coco'], 'cobol':       ['cobc'], 'coffee':      ['coffee', 'coffeelint'], 'coq':         ['coqtop'], 'cpp':         ['gcc'], 'cs':          ['mcs'], 'css':         ['csslint'], 'cucumber':    ['cucumber'], 'cuda':        ['nvcc'], 'd':           ['dmd'], 'dart':        ['dartanalyzer'], 'docbk':       ['xmllint'], 'dustjs':      ['swiffer'], 'elixir':      [], 'erlang':      ['escript'], 'eruby':       ['ruby'], 'fortran':     ['gfortran'], 'glsl':        ['cgc'], 'go':          ['go'], 'haml':        ['haml'], 'handlebars':  ['handlebars'], 'haskell':     ['ghc_mod', 'hdevtools', 'hlint'], 'haxe':        ['haxe'], 'hss':         ['hss'], 'html':        ['tidy'], 'j
line 94: lockvar! s:defaultCheckers
line 95: 
line 100: let s:defaultFiletypeMap = { 'gentoo-metadata': 'xml', 'lhaskell': 'haskell', 'litcoffee': 'coffee' }
line 101: lockvar! s:defaultFiletypeMap
line 102: 
line 103: let g:SyntasticRegistry = {}
line 104: 
line 105: " }}}1
line 106: 
line 107: " Public methods {{{1
line 108: 
line 109: " Note: Handling of filetype aliases: all public methods take aliases as
line 110: " parameters, all private methods take normalized filetypes.  Public methods
line 111: " are thus supposed to normalize filetypes before calling private methods.
line 112: 
line 113: function! g:SyntasticRegistry.Instance() " {{{2
line 121: 
line 122: function! g:SyntasticRegistry.CreateAndRegisterChecker(args) " {{{2
line 127: 
line 128: " Given a list of checker names hints_list, return a map name --> checker.
line 129: " If hints_list is empty, user settings are are used instead. Checkers are
line 130: " not checked for availability (that is, the corresponding IsAvailable() are
line 131: " not run).
line 132: function! g:SyntasticRegistry.getCheckers(ftalias, hints_list) " {{{2
line 152: 
line 153: " Same as getCheckers(), but keep only the checkers available.  This runs the
line 154: " corresponding IsAvailable() functions for all checkers.
line 155: function! g:SyntasticRegistry.getCheckersAvailable(ftalias, hints_list) " {{{2
line 158: 
line 159: function! g:SyntasticRegistry.getKnownFiletypes() " {{{2
line 174: 
line 175: function! g:SyntasticRegistry.getNamesOfAvailableCheckers(ftalias) " {{{2
line 180: 
line 181: function! g:SyntasticRegistry.echoInfoFor(ftalias_list) " {{{2
line 207: 
line 208: " }}}1
line 209: 
line 210: " Private methods {{{1
line 211: 
line 212: function! g:SyntasticRegistry._registerChecker(checker) abort " {{{2
line 225: 
line 226: function! g:SyntasticRegistry._filterCheckersByName(checkers_map, list) " {{{2
line 229: 
line 230: function! g:SyntasticRegistry._loadCheckersFor(filetype) " {{{2
line 241: 
line 242: " Check for obsolete variable g:syntastic_<filetype>_checker
line 243: function! g:SyntasticRegistry._checkDeprecation(filetype) " {{{2
line 249: 
line 250: " }}}1
line 251: 
line 252: " Private functions {{{1
line 253: 
line 254: "resolve filetype aliases, and replace - with _ otherwise we cant name
line 255: "syntax checker functions legally for filetypes like "gentoo-metadata"
line 256: function! s:_normaliseFiletype(ftalias) " {{{2
line 262: 
line 263: " }}}1
line 264: 
line 265: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/registry.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/leostera/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/Users/leostera/.vim/bundle/syntastic/plugin/syntastic/signs.vim"
line 1: if exists("g:loaded_syntastic_notifier_signs") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_signs = 1
line 5: 
line 6: " Initialisation {{{1
line 7: 
line 8: " start counting sign ids at 5000, start here to hopefully avoid conflicting
line 9: " with any other code that places signs (not sure if this precaution is
line 10: " actually needed)
line 11: let s:first_sign_id = 5000
line 12: let s:next_sign_id = s:first_sign_id
line 13: 
line 14: let g:SyntasticSignsNotifier = {}
line 15: 
line 16: let s:setup_done = 0
line 17: 
line 18: " }}}1
line 19: 
line 20: " Public methods {{{1
line 21: 
line 22: function! g:SyntasticSignsNotifier.New() " {{{2
line 33: 
line 34: function! g:SyntasticSignsNotifier.enabled() " {{{2
line 37: 
line 38: function! g:SyntasticSignsNotifier.refresh(loclist) " {{{2
line 46: 
line 47: " }}}1
line 48: 
line 49: " Private methods {{{1
line 50: 
line 51: " One time setup: define our own sign types and highlighting
line 52: function! g:SyntasticSignsNotifier._setup() " {{{2
line 84: 
line 85: " Place signs by all syntax errors in the buffer
line 86: function! g:SyntasticSignsNotifier._signErrors(loclist) " {{{2
line 117: 
line 118: " Remove the signs with the given ids from this buffer
line 119: function! g:SyntasticSignsNotifier._removeSigns(ids) " {{{2
line 127: 
line 128: " Get all the ids of the SyntaxError signs in the buffer
line 129: function! g:SyntasticSignsNotifier._bufSignIds() " {{{2
line 135: 
line 136: " }}}1
line 137: 
line 138: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic/signs.vim
continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
Searching for "/Users/leostera/.vim/bundle/vim-surround/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/plugin/syntastic/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/plugin/syntastic/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/syntastic/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/plugin/syntastic/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/plugin/syntastic/*.vim"
line 135: 
line 136: let s:registry = g:SyntasticRegistry.Instance()
calling function 74()

line 1:     if !exists('s:SyntasticRegistryInstance')
line 2:         let s:SyntasticRegistryInstance = copy(self)
line 3:         let s:SyntasticRegistryInstance._checkerMap = {}
line 4:     endif
line 5: 
line 6:     return s:SyntasticRegistryInstance
function 74 returning {'getCheckers': function('76'), 'getC...eateAndRegisterChecker': function('75')}

continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim

line 137: let s:notifiers = g:SyntasticNotifiers.Instance()
calling function 70()

line 1:     if !exists('s:SyntasticNotifiersInstance')
line 2:         let s:SyntasticNotifiersInstance = copy(self)
line 3:         call s:SyntasticNotifiersInstance._initNotifiers()
calling function 70..73()

line 1:     let self._notifier = {}
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 70..73..85()

line 1:     let newObj = copy(self)
line 2: 
line 3:     if !s:setup_done
line 4:         call self._setup()
calling function 70..73..85..88()

line 1:     if has('signs')
line 2:         if !hlexists('SyntasticErrorSign')
line 3:             highlight link SyntasticErrorSign error
line 4:         endif
line 5:         if !hlexists('SyntasticWarningSign')
line 6:             highlight link SyntasticWarningSign todo
line 7:         endif
line 8:         if !hlexists('SyntasticStyleErrorSign')
line 9:             highlight link SyntasticStyleErrorSign SyntasticErrorSign
line 10:         endif
line 11:         if !hlexists('SyntasticStyleWarningSign')
line 12:             highlight link SyntasticStyleWarningSign SyntasticWarningSign
line 13:         endif
line 14:         if !hlexists('SyntasticStyleErrorLine')
line 15:             highlight link SyntasticStyleErrorLine SyntasticErrorLine
line 16:         endif
line 17:         if !hlexists('SyntasticStyleWarningLine')
line 18:             highlight link SyntasticStyleWarningLine SyntasticWarningLine
line 19:         endif
line 20: 
line 21:         " define the signs used to display syntax and style errors/warns
line 22:         exe 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
line 22: sign define SyntasticError text=>> texthl=SyntasticErrorSign linehl=SyntasticErrorLine
line 24:         exe 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
line 24: sign define SyntasticWarning text=>> texthl=SyntasticWarningSign linehl=SyntasticWarningLine
line 26:         exe 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
line 26: sign define SyntasticStyleError text=S> texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine
line 28:         exe 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
line 28: sign define SyntasticStyleWarning text=S> texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine
line 30:     endif
function 70..73..85..88 returning #0

continuing in function 70..73..85

line 5:         let s:setup_done = 1
line 6:         lockvar s:setup_done
line 7:     endif
line 8: 
line 9:     return newObj
function 70..73..85 returning {'_signErrors': function('89'), '_buf...nction('85'), 'refresh': function('87')}

continuing in function 70..73

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 70..73..6()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 70..73..6 returning {'enabled': function('7'), 'reset': f...function('6'), 'refresh': function('8')}

continuing in function 70..73

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 70..73..29()

line 1:     let newObj = copy(self)
line 2: 
line 3:     if !s:setup_done
line 4:         call self._setup()
calling function 70..73..29..33()

line 1:     if s:has_highlighting
line 2:         if !hlexists('SyntasticError')
line 3:             highlight link SyntasticError SpellBad
line 4:         endif
line 5:         if !hlexists('SyntasticWarning')
line 6:             highlight link SyntasticWarning SpellCap
line 7:         endif
line 8:         if !hlexists('SyntasticStyleError')
line 9:             highlight link SyntasticStyleError SyntasticError
line 10:         endif
line 11:         if !hlexists('SyntasticStyleWarning')
line 12:             highlight link SyntasticStyleWarning SyntasticWarning
line 13:         endif
line 14:     endif
function 70..73..29..33 returning #0

continuing in function 70..73..29

line 5:         let s:setup_done = 1
line 6:         lockvar s:setup_done
line 7:     endif
line 8: 
line 9:     return newObj
function 70..73..29 returning {'_reset': function('34'), 'enabled':...nction('29'), 'refresh': function('31')}

continuing in function 70..73

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 70..73..25()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 70..73..25 returning {'enabled': function('26'), 'reset': ...nction('25'), 'refresh': function('27')}

continuing in function 70..73

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 70..73..3()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 70..73..3 returning {'AutoToggle': function('5'), 'New': function('3'), 'refresh': function('4')}

continuing in function 70..73

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
line 5:     endfor
line 6: 
line 7:     let self._enabled_types = copy(s:notifier_types)
function 70..73 returning #0

continuing in function 70

line 4:     endif
line 5: 
line 6:     return s:SyntasticNotifiersInstance
function 70 returning {'_notifier': {'signs': {'_signErrors...nction('72'), 'refresh': function('71')}

continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim

line 138: let s:modemap = g:SyntasticModeMap.Instance()
calling function 61()

line 1:     if !exists('s:SyntasticModeMapInstance')
line 2:         let s:SyntasticModeMapInstance = copy(self)
line 3:         call s:SyntasticModeMapInstance.synch()
calling function 61..62()

line 1:     if exists('g:syntastic_mode_map')
line 2:         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
line 3:         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
line 4:         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
line 5:     else
line 6:         let self._mode = 'active'
line 7:         let self._activeFiletypes = []
line 8:         let self._passiveFiletypes = []
line 9:     endif
function 61..62 returning #0

continuing in function 61

line 4:     endif
line 5: 
line 6:     return s:SyntasticModeMapInstance
function 61 returning {'_passiveFiletypes': [], '_activeFil... '_isOneFiletypeActive': function('68')}

continuing in /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim

line 139: 
line 140: " Commands {{{1
line 141: 
line 142: " @vimlint(EVL103, 1, a:cursorPos)
line 143: " @vimlint(EVL103, 1, a:cmdLine)
line 144: " @vimlint(EVL103, 1, a:argLead)
line 145: function! s:CompleteCheckerName(argLead, cmdLine, cursorPos) " {{{2
line 152: " @vimlint(EVL103, 0, a:cursorPos)
line 153: " @vimlint(EVL103, 0, a:cmdLine)
line 154: " @vimlint(EVL103, 0, a:argLead)
line 155: 
line 156: 
line 157: " @vimlint(EVL103, 1, a:cursorPos)
line 158: " @vimlint(EVL103, 1, a:cmdLine)
line 159: " @vimlint(EVL103, 1, a:argLead)
line 160: function! s:CompleteFiletypes(argLead, cmdLine, cursorPos) " {{{2
line 163: " @vimlint(EVL103, 0, a:cursorPos)
line 164: " @vimlint(EVL103, 0, a:cmdLine)
line 165: " @vimlint(EVL103, 0, a:argLead)
line 166: 
line 167: command! SyntasticToggleMode call s:ToggleMode()
line 170: command! -nargs=* -complete=custom,s:CompleteCheckerName SyntasticCheck call s:UpdateErrors(0, <f-args>) <bar> call syntastic#util#redraw(g:syntastic_full_redraws)
line 171: command! Errors call s:ShowLocList()
line 174: command! -nargs=? -complete=custom,s:CompleteFiletypes SyntasticInfo call s:modemap.modeInfo(<f-args>) | call s:registry.echoInfoFor(s:resolveFiletypes(<f-args>))
line 177: command! SyntasticReset call s:ClearCache() | call s:notifiers.refresh(g:SyntasticLoclist.New([]))
line 178: command! SyntasticSetLoclist call g:SyntasticLoclist.current().setloclist()
line 179: 
line 180: " }}}1
line 181: 
line 182: " Autocommands and hooks {{{1
line 183: 
line 184: augroup syntastic
line 185:     autocmd BufReadPost * call s:BufReadPostHook()
line 186:     autocmd BufWritePost * call s:BufWritePostHook()
line 187:     autocmd BufEnter * call s:BufEnterHook()
line 188: augroup END
line 189: 
line 190: if v:version > 703 || (v:version == 703 && has('patch544'))
line 191:     " QuitPre was added in Vim 7.3.544
line 192:     augroup syntastic
line 193:         autocmd QuitPre * call s:QuitPreHook()
line 194:     augroup END
line 195: endif
line 196: 
line 197: function! s:BufReadPostHook() " {{{2
line 204: 
line 205: function! s:BufWritePostHook() " {{{2
line 210: 
line 211: function! s:BufEnterHook() " {{{2
line 229: 
line 230: function! s:QuitPreHook() " {{{2
line 236: 
line 237: " }}}1
line 238: 
line 239: " Main {{{1
line 240: 
line 241: "refresh and redraw all the error info for this buf when saving or reading
line 242: function! s:UpdateErrors(auto_invoked, ...) " {{{2
line 290: 
line 291: "clear the loc list for the buffer
line 292: function! s:ClearCache() " {{{2
line 296: 
line 297: "detect and cache all syntax errors in this buffer
line 298: function! s:CacheErrors(checker_names) " {{{2
line 388: 
line 389: function! s:ToggleMode() " {{{2
line 395: 
line 396: "display the cached errors for this buf in the location list
line 397: function! s:ShowLocList() " {{{2
line 400: 
line 401: "Emulates the :lmake command. Sets up the make environment according to the
line 402: "options given, runs make, resets the environment, returns the location list
line 403: "
line 404: "a:options can contain the following keys:
line 405: "    'makeprg'
line 406: "    'errorformat'
line 407: "
line 408: "The corresponding options are set for the duration of the function call. They
line 409: "are set with :let, so dont escape spaces.
line 410: "
line 411: "a:options may also contain:
line 412: "   'defaults' - a dict containing default values for the returned errors
line 413: "   'subtype' - all errors will be assigned the given subtype
line 414: "   'preprocess' - a function to be applied to the error file before parsing errors
line 415: "   'postprocess' - a list of functions to be applied to the error list
line 416: "   'cwd' - change directory to the given path before running the checker
line 417: "   'env' - environment variables to set before running the checker
line 418: "   'returns' - a list of valid exit codes for the checker
line 419: " @vimlint(EVL102, 1, l:env_save)
line 420: function! SyntasticMake(options) " {{{2
line 528: " @vimlint(EVL102, 0, l:env_save)
line 529: 
line 530: "return a string representing the state of buffer according to
line 531: "g:syntastic_stl_format
line 532: "
line 533: "return '' if no errors are cached for the buffer
line 534: function! SyntasticStatuslineFlag() " {{{2
line 537: 
line 538: " }}}1
line 539: 
line 540: " Utilities {{{1
line 541: 
line 542: function! s:resolveFiletypes(...) " {{{2
line 546: 
line 547: function! s:ignoreFile(filename) " {{{2
line 556: 
line 557: " Skip running in special buffers
line 558: function! s:skipFile() " {{{2
line 568: 
line 569: " Take a list of errors and add default values to them from a:options
line 570: function! s:addToErrors(errors, options) " {{{2
line 581: 
line 582: " The script changes &shellredir and &shell to stop the screen flicking when
line 583: " shelling out to syntax checkers. Not all OSs support the hacks though.
line 584: function! s:bashHack() " {{{2
line 600: 
line 601: function! s:uname() " {{{2
line 608: 
line 609: " }}}1
line 610: 
line 611: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/plugin/syntastic.vim
Searching for "/Users/leostera/.vim/bundle/vim-surround/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/vim-surround/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/vim-surround/plugin/surround.vim"
line 1: " surround.vim - Surroundings
line 2: " Author:       Tim Pope <http://tpo.pe/>
line 3: " Version:      2.0
line 4: " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
line 5: 
line 6: if exists("g:loaded_surround") || &cp || v:version < 700
line 7:   finish
line 8: endif
line 9: let g:loaded_surround = 1
line 10: 
line 11: " Input functions {{{1
line 12: 
line 13: function! s:getchar()
line 20: 
line 21: function! s:inputtarget()
line 35: 
line 36: function! s:inputreplacement()
line 47: 
line 48: function! s:beep()
line 52: 
line 53: function! s:redraw()
line 57: 
line 58: " }}}1
line 59: 
line 60: " Wrapping functions {{{1
line 61: 
line 62: function! s:extractbefore(str)
line 69: 
line 70: function! s:extractafter(str)
line 77: 
line 78: function! s:fixindent(str,spc)
line 87: 
line 88: function! s:process(string)
line 126: 
line 127: function! s:wrap(string,char,type,...)
line 291: 
line 292: function! s:wrapreg(reg,char,...)
line 299: " }}}1
line 300: 
line 301: function! s:insert(...) " {{{1
line 343: 
line 344: function! s:reindent() " {{{1
line 349: 
line 350: function! s:dosurround(...) " {{{1
line 462: 
line 463: function! s:changesurround() " {{{1
line 474: 
line 475: function! s:opfunc(type,...) " {{{1
line 537: 
line 538: function! s:opfunc2(arg)
line 541: 
line 542: function! s:closematch(str) " {{{1
line 557: 
line 558: nnoremap <silent> <Plug>SurroundRepeat .
line 559: nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
line 560: nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
line 561: nnoremap <silent> <Plug>Yssurround :<C-U>call <SID>opfunc(v:count1)<CR>
line 562: nnoremap <silent> <Plug>YSsurround :<C-U>call <SID>opfunc2(v:count1)<CR>
line 563: " <C-U> discards the numerical argument but there's not much we can do with it
line 564: nnoremap <silent> <Plug>Ysurround  :<C-U>set opfunc=<SID>opfunc<CR>g@
line 565: nnoremap <silent> <Plug>YSurround  :<C-U>set opfunc=<SID>opfunc2<CR>g@
line 566: vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
line 567: vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
line 568: inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
line 569: inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
line 570: 
line 571: if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
line 572:   nmap ds  <Plug>Dsurround
line 573:   nmap cs  <Plug>Csurround
line 574:   nmap ys  <Plug>Ysurround
line 575:   nmap yS  <Plug>YSurround
line 576:   nmap yss <Plug>Yssurround
line 577:   nmap ySs <Plug>YSsurround
line 578:   nmap ySS <Plug>YSsurround
line 579:   xmap S   <Plug>VSurround
line 580:   xmap gS  <Plug>VgSurround
line 581:   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
line 582:     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
line 583:       imap    <C-S> <Plug>Isurround
line 584:     endif
line 585:     imap      <C-G>s <Plug>Isurround
line 586:     imap      <C-G>S <Plug>ISurround
line 587:   endif
line 588: endif
line 589: 
line 590: " vim:set ft=vim sw=2 sts=2 et:
finished sourcing /Users/leostera/.vim/bundle/vim-surround/plugin/surround.vim
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/vim-fugitive/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim"
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.1
line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
line 5: 
line 6: if exists('g:loaded_fugitive') || &cp
line 7:   finish
line 8: endif
line 9: let g:loaded_fugitive = 1
line 10: 
line 11: if !exists('g:fugitive_git_executable')
line 12:   let g:fugitive_git_executable = 'git'
line 13: endif
line 14: 
line 15: " Section: Utility
line 16: 
line 17: function! s:function(name) abort
line 20: 
line 21: function! s:sub(str,pat,rep) abort
line 24: 
line 25: function! s:gsub(str,pat,rep) abort
line 28: 
line 29: function! s:winshell() abort
line 32: 
line 33: function! s:shellesc(arg) abort
line 42: 
line 43: function! s:fnameescape(file) abort
line 50: 
line 51: function! s:throw(string) abort
line 55: 
line 56: function! s:warn(str) abort
line 62: 
line 63: function! s:shellslash(path) abort
line 70: 
line 71: let s:git_versions = {}
line 72: 
line 73: function! fugitive#git_version(...) abort
Searching for "autoload/fugitive.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/le
Searching for "/Users/leostera/.vim/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/autoload/fugitive.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/autoload/fugitive.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/autoload/fugitive.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/autoload/fugitive.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/autoload/fugitive.vim"
not found in 'runtimepath': "autoload/fugitive.vim"
line 79: 
line 80: function! s:recall() abort
line 97: 
line 98: function! s:add_methods(namespace, method_names) abort
line 103: 
line 104: let s:commands = []
line 105: function! s:command(definition) abort
line 108: 
line 109: function! s:define_commands() abort
line 114: 
line 115: augroup fugitive_utility
line 116:   autocmd!
line 117:   autocmd User Fugitive call s:define_commands()
line 118: augroup END
line 119: 
line 120: let s:abstract_prototype = {}
line 121: 
line 122: " Section: Initialization
line 123: 
line 124: function! fugitive#is_git_dir(path) abort
line 128: 
line 129: function! fugitive#extract_git_dir(path) abort
line 169: 
line 170: function! fugitive#detect(path) abort
line 199: 
line 200: augroup fugitive
line 201:   autocmd!
line 202:   autocmd BufNewFile,BufReadPost * call fugitive#detect(expand('<amatch>:p'))
line 203:   autocmd FileType           netrw call fugitive#detect(expand('%:p'))
line 204:   autocmd User NERDTreeInit,NERDTreeNewRoot call fugitive#detect(b:NERDTreeRoot.path.str())
line 205:   autocmd VimEnter * if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 206:   autocmd CmdWinEnter * call fugitive#detect(expand('#:p'))
line 207:   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 208: augroup END
line 209: 
line 210: " Section: Repository
line 211: 
line 212: let s:repo_prototype = {}
line 213: let s:repos = {}
line 214: 
line 215: function! s:repo(...) abort
line 228: 
line 229: function! fugitive#repo(...) abort
line 232: 
line 233: function! s:repo_dir(...) dict abort
line 236: 
line 237: function! s:repo_configured_tree() dict abort
line 254: 
line 255: function! s:repo_tree(...) dict abort
line 267: 
line 268: function! s:repo_bare() dict abort
line 275: 
line 276: function! s:repo_translate(spec) dict abort
line 320: 
line 321: function! s:repo_head(...) dict abort
line 336: 
line 337: call s:add_methods('repo',['dir','configured_tree','tree','bare','translate','head'])
calling function <SNR>32_add_methods('repo', ['dir', 'configured_tree', 'tree', 'bare', 'translate', 'head'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_dir')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_dir')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_configured_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_configured_tree')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_tree')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_bare')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_bare')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_translate')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_translate')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_head')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_head')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 338: 
line 339: function! s:repo_git_command(...) dict abort
line 343: 
line 344: function! s:repo_git_chomp(...) dict abort
line 347: 
line 348: function! s:repo_git_chomp_in_tree(...) dict abort
line 358: 
line 359: function! s:repo_rev_parse(rev) dict abort
line 366: 
line 367: call s:add_methods('repo',['git_command','git_chomp','git_chomp_in_tree','rev_parse'])
calling function <SNR>32_add_methods('repo', ['git_command', 'git_chomp', 'git_chomp_in_tree', 'rev_parse'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_git_command')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_git_command')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_git_chomp')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_git_chomp')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_git_chomp_in_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_git_chomp_in_tree')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_rev_parse')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_rev_parse')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 368: 
line 369: function! s:repo_dirglob(base) dict abort
line 375: 
line 376: function! s:repo_superglob(base) dict abort
line 413: 
line 414: call s:add_methods('repo',['dirglob','superglob'])
calling function <SNR>32_add_methods('repo', ['dirglob', 'superglob'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_dirglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_dirglob')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_superglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_superglob')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 415: 
line 416: function! s:repo_config(conf) dict abort
line 419: 
line 420: function! s:repo_user() dict abort
line 425: 
line 426: function! s:repo_aliases() dict abort
line 435: 
line 436: call s:add_methods('repo',['config', 'user', 'aliases'])
calling function <SNR>32_add_methods('repo', ['config', 'user', 'aliases'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_config')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_config')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_user')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_user')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_aliases')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_aliases')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 437: 
line 438: function! s:repo_keywordprg() dict abort
line 446: 
line 447: call s:add_methods('repo',['keywordprg'])
calling function <SNR>32_add_methods('repo', ['keywordprg'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_keywordprg')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_keywordprg')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 448: 
line 449: " Section: Buffer
line 450: 
line 451: let s:buffer_prototype = {}
line 452: 
line 453: function! s:buffer(...) abort
line 461: 
line 462: function! fugitive#buffer(...) abort
line 465: 
line 466: function! s:buffer_getvar(var) dict abort
line 469: 
line 470: function! s:buffer_setvar(var,value) dict abort
line 473: 
line 474: function! s:buffer_getline(lnum) dict abort
line 477: 
line 478: function! s:buffer_repo() dict abort
line 481: 
line 482: function! s:buffer_type(...) dict abort
line 506: 
line 507: if has('win32')
line 508: 
line 509:   function! s:buffer_spec() dict abort
line 517: 
line 518: else
line 519: 
line 520:   function! s:buffer_spec() dict abort
line 524: 
line 525: endif
line 526: 
line 527: function! s:buffer_name() dict abort
line 530: 
line 531: function! s:buffer_commit() dict abort
line 534: 
line 535: function! s:buffer_path(...) dict abort
line 546: 
line 547: function! s:buffer_rev() dict abort
line 561: 
line 562: function! s:buffer_sha1() dict abort
line 569: 
line 570: function! s:buffer_expand(rev) dict abort
line 587: 
line 588: function! s:buffer_containing_commit() dict abort
line 597: 
line 598: function! s:buffer_up(...) dict abort
line 621: 
line 622: call s:add_methods('buffer',['getvar','setvar','getline','repo','type','spec','name','commit','path','rev','sha1','expand','containing_commit','up'])
calling function <SNR>32_add_methods('buffer', ['getvar', 'setvar', 'getline', 'repo...1', 'expand', 'containing_commit', 'up'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_getvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_getvar')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_setvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_setvar')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_getline')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_getline')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_repo')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_repo')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_type')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_type')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_spec')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_spec')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_name')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_name')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_commit')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_path')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_path')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_rev')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_rev')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_sha1')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_sha1')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_expand')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_expand')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_containing_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_containing_commit')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_up')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_up')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 623: 
line 624: " Section: Git
line 625: 
line 626: call s:command("-bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)")
calling function <SNR>32_command('-bang -nargs=? -complete=customlist,...te Git :execute s:Git(<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 627: 
line 628: function! s:ExecuteInTree(cmd) abort
line 638: 
line 639: function! s:Git(bang, args) abort
line 652: 
line 653: function! fugitive#git_commands() abort
line 659: 
line 660: function! s:GitComplete(A, L, P) abort
line 668: 
line 669: " Section: Gcd, Glcd
line 670: 
line 671: function! s:DirComplete(A,L,P) abort
line 675: 
line 676: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>32_command('-bar -bang -nargs=? -complete=custom...ir(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 677: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>32_command('-bar -bang -nargs=? -complete=custom...ir(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 678: 
line 679: " Section: Gstatus
line 680: 
line 681: call s:command("-bar Gstatus :execute s:Status()")
calling function <SNR>32_command('-bar Gstatus :execute s:Status()')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 682: augroup fugitive_status
line 683:   autocmd!
line 684:   if !has('win32')
line 685:     autocmd FocusGained,ShellCmdPost * call fugitive#reload_status()
line 686:   endif
line 687: augroup END
line 688: 
line 689: function! s:Status() abort
line 700: 
line 701: function! fugitive#reload_status() abort
line 733: 
line 734: function! s:stage_info(lnum) abort
line 759: 
line 760: function! s:StageNext(count) abort
line 766: 
line 767: function! s:StagePrevious(count) abort
line 777: 
line 778: function! s:StageReloadSeek(target,lnum1,lnum2) abort
line 789: 
line 790: function! s:StageUndo() abort
line 811: 
line 812: function! s:StageDiff(diff) abort
line 830: 
line 831: function! s:StageDiffEdit() abort
line 853: 
line 854: function! s:StageToggle(lnum1,lnum2) abort
line 918: 
line 919: function! s:StagePatch(lnum1,lnum2) abort
line 964: 
line 965: " Section: Gcommit
line 966: 
line 967: call s:command("-nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)")
calling function <SNR>32_command('-nargs=? -complete=customlist,s:Comm...ete Gcommit :execute s:Commit(<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 968: 
line 969: function! s:Commit(args, ...) abort
line 1051: 
line 1052: function! s:CommitComplete(A,L,P) abort
line 1060: 
line 1061: function! s:FinishCommit() abort
line 1069: 
line 1070: " Section: Gmerge, Gpull
line 1071: 
line 1073: call s:command("-nargs=? -bang -complete=custom,s:RevisionComplete Gmerge " . "execute s:Merge('merge', <bang>0, <q-args>)")
calling function <SNR>32_command('-nargs=? -bang -complete=custom,s:Re...e s:Merge(''merge'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1075: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpull " . "execute s:Merge('pull --progress', <bang>0, <q-args>)")
calling function <SNR>32_command('-nargs=? -bang -complete=custom,s:Re...''pull --progress'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1076: 
line 1077: function! s:RevisionComplete(A, L, P) abort
line 1081: 
line 1082: function! s:RemoteComplete(A, L, P) abort
line 1093: 
line 1094: function! fugitive#cwindow() abort
line 1104: 
line 1111: let s:common_efm = '' . '%+Egit:%.%#,' . '%+Eusage:%.%#,' . '%+Eerror:%.%#,' . '%+Efatal:%.%#,' . '%-G%.%#%\e[K%.%#,' . '%-G%.%#%\r%.%\+'
line 1112: 
line 1113: function! s:Merge(cmd, bang, args) abort
line 1188: 
line 1189: " Section: Ggrep, Glog
line 1190: 
line 1191: if !exists('g:fugitive_summary_format')
line 1192:   let g:fugitive_summary_format = '%s'
line 1193: endif
line 1194: 
line 1195: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)")
calling function <SNR>32_command('-bang -nargs=? -complete=customlist,...ecute s:Grep(''grep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1196: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)")
calling function <SNR>32_command('-bang -nargs=? -complete=customlist,...cute s:Grep(''lgrep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1197: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -range=0 -comple...'grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1198: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -range=0 -comple...lgrep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1199: 
line 1200: function! s:Grep(cmd,bang,arg) abort
line 1238: 
line 1239: function! s:Log(cmd, line1, line2, ...) abort
line 1276: 
line 1277: " Section: Gedit, Gpedit, Gsplit, Gvsplit, Gtabedit, Gread
line 1278: 
line 1279: function! s:Edit(cmd,bang,...) abort
line 1355: 
line 1356: function! s:EditComplete(A,L,P) abort
line 1359: 
line 1360: function! s:EditRunComplete(A,L,P) abort
line 1367: 
line 1368: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...ecute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1369: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...ecute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1370: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...cute s:Edit(''pedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1371: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...cute s:Edit(''split'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1372: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...ute s:Edit(''vsplit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1373: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...te s:Edit(''tabedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1374: call s:command("-bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -count -complete...' : <count>).''read'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1375: 
line 1376: " Section: Gwrite, Gwq
line 1377: 
line 1378: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...rite :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1379: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...e Gw :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1380: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)")
calling function <SNR>32_command('-bar -bang -nargs=* -complete=custom...ete Gwq :execute s:Wq(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1381: 
line 1382: function! s:Write(force,...) abort
line 1518: 
line 1519: function! s:Wq(force,...) abort
line 1531: 
line 1532: augroup fugitive_commit
line 1533:   autocmd!
line 1534:   autocmd VimLeavePre,BufDelete COMMIT_EDITMSG execute s:sub(s:FinishCommit(), '^echoerr (.*)', 'echohl ErrorMsg|echo \1|echohl NONE')
line 1535: augroup END
line 1536: 
line 1537: " Section: Gpush, Gfetch
line 1538: 
line 1539: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)")
calling function <SNR>32_command('-nargs=? -bang -complete=custom,s:Re...ispatch(''<bang>'', ''push ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1540: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)")
calling function <SNR>32_command('-nargs=? -bang -complete=custom,s:Re...spatch(''<bang>'', ''fetch ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1541: 
line 1542: function! s:Dispatch(bang, args)
line 1565: 
line 1566: " Section: Gdiff
line 1567: 
line 1568: call s:command("-bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<f-args>)")
calling function <SNR>32_command('-bang -bar -nargs=* -complete=custom...te Gdiff :execute s:Diff('''',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1569: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<f-args>)")
calling function <SNR>32_command('-bar -nargs=* -complete=customlist,s...cute s:Diff(''keepalt vert '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1570: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<f-args>)")
calling function <SNR>32_command('-bar -nargs=* -complete=customlist,s... :execute s:Diff(''keepalt '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1571: 
line 1572: augroup fugitive_diff
line 1573:   autocmd!
line 1577:   autocmd BufWinLeave * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 1581:   autocmd BufWinEnter * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
line 1582: augroup END
line 1583: 
line 1584: function! s:can_diffoff(buf) abort
line 1589: 
line 1590: function! fugitive#can_diffoff(buf) abort
line 1593: 
line 1594: function! s:diff_modifier(count) abort
line 1606: 
line 1607: function! s:diff_window_count() abort
line 1614: 
line 1615: function! s:diff_restore() abort
line 1629: 
line 1630: function! s:diffthis() abort
line 1636: 
line 1637: function! s:diffoff() abort
line 1645: 
line 1646: function! s:diffoff_all(dir) abort
line 1659: 
line 1660: function! s:buffer_compare_age(commit) dict abort
line 1679: 
line 1680: call s:add_methods('buffer',['compare_age'])
calling function <SNR>32_add_methods('buffer', ['compare_age'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:buffer_compare_age')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_buffer_compare_age')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1681: 
line 1682: function! s:Diff(vert,...) abort
line 1746: 
line 1747: " Section: Gmove, Gremove
line 1748: 
line 1749: function! s:Move(force,destination) abort
line 1782: 
line 1783: function! s:MoveComplete(A,L,P) abort
line 1792: 
line 1793: function! s:Remove(force) abort
line 1814: 
line 1815: augroup fugitive_remove
line 1816:   autocmd!
line 1820:   autocmd User Fugitive if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 1821: augroup END
line 1822: 
line 1823: " Section: Gblame
line 1824: 
line 1825: augroup fugitive_blame
line 1826:   autocmd!
line 1827:   autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame
line 1828:   autocmd FileType fugitiveblame setlocal nomodeline | if exists('b:git_dir') | let &l:keywordprg = s:repo().keywordprg() | endif
line 1829:   autocmd Syntax fugitiveblame call s:BlameSyntax()
line 1830:   autocmd User Fugitive if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
line 1831:   autocmd ColorScheme,GUIEnter * call s:RehighlightBlame()
line 1832: augroup END
line 1833: 
line 1834: function! s:linechars(pattern) abort
line 1843: 
line 1844: function! s:Blame(bang,line1,line2,count,args) abort
line 1959: 
line 1960: function! s:BlameCommit(cmd) abort
line 2000: 
line 2001: function! s:BlameJump(suffix) abort
line 2034: 
line 2035: let s:hash_colors = {}
line 2036: 
line 2037: function! s:BlameSyntax() abort
line 2085: 
line 2086: function! s:RehighlightBlame() abort
line 2095: 
line 2096: " Section: Gbrowse
line 2097: 
line 2098: call s:command("-bar -bang -range -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)")
calling function <SNR>32_command('-bar -bang -range -nargs=* -complete...rowse(<bang>0,<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>32_command returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 2099: 
line 2100: function! s:Browse(bang,line1,count,...) abort
line 2211: 
line 2212: function! s:github_url(opts, ...) abort
line 2273: 
line 2274: function! s:instaweb_url(opts) abort
line 2314: 
line 2315: if !exists('g:fugitive_browse_handlers')
line 2316:   let g:fugitive_browse_handlers = []
line 2317: endif
line 2318: 
line 2320: call extend(g:fugitive_browse_handlers, [s:function('s:github_url'), s:function('s:instaweb_url')])
calling function <SNR>32_function('s:github_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_function returning function('<SNR>32_github_url')

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

calling function <SNR>32_function('s:instaweb_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_function returning function('<SNR>32_instaweb_url')

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 2321: 
line 2322: " Section: File access
line 2323: 
line 2324: function! s:ReplaceCmd(cmd,...) abort
line 2363: 
line 2364: function! s:BufReadIndex() abort
line 2439: 
line 2440: function! s:FileRead() abort
line 2456: 
line 2457: function! s:BufReadIndexFile() abort
line 2477: 
line 2478: function! s:BufWriteIndexFile() abort
line 2508: 
line 2509: function! s:BufReadObject() abort
line 2590: 
line 2591: augroup fugitive_files
line 2592:   autocmd!
line 2599:   autocmd BufReadCmd  index{,.lock} if fugitive#is_git_dir(expand('<amatch>:p:h')) |   exe s:BufReadIndex() | elseif filereadable(expand('<amatch>')) |   read <amatch> |   1delete | endif
line 2600:   autocmd FileReadCmd fugitive://**//[0-3]/**          exe s:FileRead()
line 2601:   autocmd BufReadCmd  fugitive://**//[0-3]/**          exe s:BufReadIndexFile()
line 2602:   autocmd BufWriteCmd fugitive://**//[0-3]/**          exe s:BufWriteIndexFile()
line 2603:   autocmd BufReadCmd  fugitive://**//[0-9a-f][0-9a-f]* exe s:BufReadObject()
line 2604:   autocmd FileReadCmd fugitive://**//[0-9a-f][0-9a-f]* exe s:FileRead()
line 2608:   autocmd FileType git if exists('b:git_dir') |  call s:JumpInit() | endif
line 2609: augroup END
line 2610: 
line 2611: " Section: Temp files
line 2612: 
line 2613: if !exists('s:temp_files')
line 2614:   let s:temp_files = {}
line 2615: endif
line 2616: 
line 2617: augroup fugitive_temp
line 2618:   autocmd!
line 2627:   autocmd BufNewFile,BufReadPost * if has_key(s:temp_files,tolower(expand('<afile>:p'))) |   let b:git_dir = s:temp_files[tolower(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 2628: augroup END
line 2629: 
line 2630: " Section: Go to file
line 2631: 
line 2632: function! s:JumpInit() abort
line 2650: 
line 2651: function! s:GF(mode) abort
line 2822: 
line 2823: " Section: Statusline
line 2824: 
line 2825: function! s:repo_head_ref() dict abort
line 2831: 
line 2832: call s:add_methods('repo',['head_ref'])
calling function <SNR>32_add_methods('repo', ['head_ref'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>32_add_methods..<SNR>32_function('s:repo_head_ref')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>32_add_methods..<SNR>32_function returning function('<SNR>32_repo_head_ref')

continuing in function <SNR>32_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>32_add_methods returning #0

continuing in /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 2833: 
line 2834: function! fugitive#statusline(...) abort
line 2849: 
line 2850: function! fugitive#head(...) abort
line 2857: 
line 2858: " Section: Folding
line 2859: 
line 2860: function! fugitive#foldtext() abort
line 2898: 
line 2899: augroup fugitive_foldtext
line 2900:   autocmd!
line 2904:   autocmd User Fugitive if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif
line 2905: augroup END
finished sourcing /Users/leostera/.vim/bundle/vim-fugitive/plugin/fugitive.vim
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/vim-gitgutter/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim"
line 1: scriptencoding utf-8
line 2: 
line 3: if exists('g:loaded_gitgutter') || !executable('git') || !has('signs') || &cp
line 4:   finish
line 5: endif
line 6: let g:loaded_gitgutter = 1
line 7: 
line 8: " Initialisation {{{
line 9: 
line 10: " Realtime sign updates require Vim 7.3.105+.
line 11: if v:version < 703 || (v:version == 703 && !has("patch105"))
line 12:   let g:gitgutter_realtime = 0
line 13: endif
line 14: 
line 15: " Eager updates require gettabvar()/settabvar().
line 16: if !exists("*gettabvar")
line 17:   let g:gitgutter_eager = 0
line 18: endif
line 19: 
line 20: function! s:set(var, default)
line 29: 
line 30: call s:set('g:gitgutter_enabled',               1)
calling function <SNR>33_set('g:gitgutter_enabled', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_enabled = 1
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 31: call s:set('g:gitgutter_max_signs',           500)
calling function <SNR>33_set('g:gitgutter_max_signs', 500)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_max_signs = 500
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 32: call s:set('g:gitgutter_signs',                 1)
calling function <SNR>33_set('g:gitgutter_signs', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_signs = 1
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 33: call s:set('g:gitgutter_highlight_lines',       0)
calling function <SNR>33_set('g:gitgutter_highlight_lines', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_highlight_lines = 0
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 34: call s:set('g:gitgutter_sign_column_always',    0)
calling function <SNR>33_set('g:gitgutter_sign_column_always', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_sign_column_always = 0
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 35: call s:set('g:gitgutter_realtime',              1)
calling function <SNR>33_set('g:gitgutter_realtime', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_realtime = 1
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 36: call s:set('g:gitgutter_eager',                 1)
calling function <SNR>33_set('g:gitgutter_eager', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_eager = 1
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 37: call s:set('g:gitgutter_sign_added',            '+')
calling function <SNR>33_set('g:gitgutter_sign_added', '+')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_added = '+'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 38: call s:set('g:gitgutter_sign_modified',         '~')
calling function <SNR>33_set('g:gitgutter_sign_modified', '~')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_modified = '~'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 39: call s:set('g:gitgutter_sign_removed',          '_')
calling function <SNR>33_set('g:gitgutter_sign_removed', '_')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed = '_'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 40: call s:set('g:gitgutter_sign_removed_first_line', '‾')
calling function <SNR>33_set('g:gitgutter_sign_removed_first_line', '‾')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed_first_line = '‾'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 41: call s:set('g:gitgutter_sign_modified_removed', '~_')
calling function <SNR>33_set('g:gitgutter_sign_modified_removed', '~_')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_modified_removed = '~_'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 42: call s:set('g:gitgutter_diff_args',             '')
calling function <SNR>33_set('g:gitgutter_diff_args', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_diff_args = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 43: call s:set('g:gitgutter_escape_grep',           0)
calling function <SNR>33_set('g:gitgutter_escape_grep', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_escape_grep = 0
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 44: call s:set('g:gitgutter_map_keys',              1)
calling function <SNR>33_set('g:gitgutter_map_keys', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_map_keys = 1
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 45: call s:set('g:gitgutter_avoid_cmd_prompt_on_windows', 1)
calling function <SNR>33_set('g:gitgutter_avoid_cmd_prompt_on_windows', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_avoid_cmd_prompt_on_windows = 1
line 6:     endif
line 7:   endif
function <SNR>33_set returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 46: 
line 47: call gitgutter#highlight#define_sign_column_highlight()
Searching for "autoload/gitgutter/highlight.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/afte
Searching for "/Users/leostera/.vim/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/gitgutter/highlight.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim"
chdir(/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 47: sourcing "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim"
line 1: function! gitgutter#highlight#define_sign_column_highlight()
line 4: 
line 5: function! gitgutter#highlight#define_highlights()
line 32: 
line 33: function! gitgutter#highlight#define_signs()
line 45: 
line 46: function! gitgutter#highlight#define_sign_text()
line 53: 
line 54: function! gitgutter#highlight#define_sign_text_highlights()
line 73: 
line 74: function! gitgutter#highlight#define_sign_line_highlights()
line 89: 
line 90: function! gitgutter#highlight#get_background_colors(group)
line 104: 
line 105: function! gitgutter#highlight#match_highlight(highlight, pattern)
finished sourcing /Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim
continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim
calling function gitgutter#highlight#define_sign_column_highlight()

line 1:   highlight default link SignColumn LineNr
function gitgutter#highlight#define_sign_column_highlight returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 48: call gitgutter#highlight#define_highlights()
calling function gitgutter#highlight#define_highlights()

line 1:   let [guibg, ctermbg] = gitgutter#highlight#get_background_colors('SignColumn')
calling function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors('SignColumn')

line 1:   redir => highlight
line 2:   silent execute 'silent highlight ' . a:group
line 2: silent highlight SignColumn
SignColumn     xxx term=standout ctermfg=4 ctermbg=248 guifg=DarkBlue guibg=Grey
line 3:   redir END
line 4: 
line 5:   let link_matches = matchlist(highlight, 'links to \(\S\+\)')
line 6:   if len(link_matches) > 0 " follow the link
line 7:     return gitgutter#highlight#get_background_colors(link_matches[1])
line 8:   endif
line 9: 
line 10:   let ctermbg = gitgutter#highlight#match_highlight(highlight, 'ctermbg=\([0-9A-Za-z]\+\)')
calling function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors..gitgutter#highlight#match_highlight('
line 2:   silent execute ''silent ...arkBlue guibg=Grey
line 3:   redir END', 'ctermbg=\([0-9A-Za-z]\+\)')

line 1:   let matches = matchlist(a:highlight, a:pattern)
line 2:   if len(matches) == 0
line 3:     return 'NONE'
line 4:   endif
line 5:   return matches[1]
function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors..gitgutter#highlight#match_highlight returning '248'

continuing in function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors

line 11:   let guibg   = gitgutter#highlight#match_highlight(highlight, 'guibg=\([#0-9A-Za-z]\+\)')
calling function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors..gitgutter#highlight#match_highlight('
line 2:   silent execute ''silent ...arkBlue guibg=Grey
line 3:   redir END', 'guibg=\([#0-9A-Za-z]\+\)')

line 1:   let matches = matchlist(a:highlight, a:pattern)
line 2:   if len(matches) == 0
line 3:     return 'NONE'
line 4:   endif
line 5:   return matches[1]
function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors..gitgutter#highlight#match_highlight returning 'Grey'

continuing in function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors

line 12:   return [guibg, ctermbg]
function gitgutter#highlight#define_highlights..gitgutter#highlight#get_background_colors returning ['Grey', '248']

continuing in function gitgutter#highlight#define_highlights

line 2: 
line 3:   " Highlights used by the signs.
line 4: 
line 5:   execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
line 5: highlight GitGutterAddDefault    guifg=#009900 guibg=Grey ctermfg=2 ctermbg=248
line 6:   execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
line 6: highlight GitGutterChangeDefault guifg=#bbbb00 guibg=Grey ctermfg=3 ctermbg=248
line 7:   execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
line 7: highlight GitGutterDeleteDefault guifg=#ff2222 guibg=Grey ctermfg=1 ctermbg=248
line 8:   highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
line 9: 
line 10:   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 10: highlight GitGutterAddInvisible    guifg=bg guibg=Grey ctermfg=248 ctermbg=248
line 11:   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 11: highlight GitGutterChangeInvisible guifg=bg guibg=Grey ctermfg=248 ctermbg=248
line 12:   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 12: highlight GitGutterDeleteInvisible guifg=bg guibg=Grey ctermfg=248 ctermbg=248
line 13:   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisble
line 14: 
line 15:   highlight default link GitGutterAdd          GitGutterAddDefault
line 16:   highlight default link GitGutterChange       GitGutterChangeDefault
line 17:   highlight default link GitGutterDelete       GitGutterDeleteDefault
line 18:   highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
line 19: 
line 20:   " Highlights used for the whole line.
line 21: 
line 22:   highlight default link GitGutterAddLine          DiffAdd
line 23:   highlight default link GitGutterChangeLine       DiffChange
line 24:   highlight default link GitGutterDeleteLine       DiffDelete
line 25:   highlight default link GitGutterChangeDeleteLine GitGutterChangeLineDefault
function gitgutter#highlight#define_highlights returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 49: call gitgutter#highlight#define_signs()
calling function gitgutter#highlight#define_signs()

line 1:   sign define GitGutterLineAdded
line 2:   sign define GitGutterLineModified
line 3:   sign define GitGutterLineRemoved
line 4:   sign define GitGutterLineRemovedFirstLine
line 5:   sign define GitGutterLineModifiedRemoved
line 6:   sign define GitGutterDummy
line 7: 
line 8:   call gitgutter#highlight#define_sign_text()
calling function gitgutter#highlight#define_signs..gitgutter#highlight#define_sign_text()

line 1:   execute "sign define GitGutterLineAdded           text=" . g:gitgutter_sign_added
line 1: sign define GitGutterLineAdded           text=+
line 2:   execute "sign define GitGutterLineModified        text=" . g:gitgutter_sign_modified
line 2: sign define GitGutterLineModified        text=~
line 3:   execute "sign define GitGutterLineRemoved         text=" . g:gitgutter_sign_removed
line 3: sign define GitGutterLineRemoved         text=_
line 4:   execute "sign define GitGutterLineRemovedFirstLine text=" . g:gitgutter_sign_removed_first_line
line 4: sign define GitGutterLineRemovedFirstLine text=‾
line 5:   execute "sign define GitGutterLineModifiedRemoved text=" . g:gitgutter_sign_modified_removed
line 5: sign define GitGutterLineModifiedRemoved text=~_
function gitgutter#highlight#define_signs..gitgutter#highlight#define_sign_text returning #0

continuing in function gitgutter#highlight#define_signs

line 9:   call gitgutter#highlight#define_sign_text_highlights()
calling function gitgutter#highlight#define_signs..gitgutter#highlight#define_sign_text_highlights()

line 1:   " Once a sign's text attribute has been defined, it cannot be undefined or
line 2:   " set to an empty value.  So to make signs' text disappear (when toggling
line 3:   " off or disabling) we make them invisible by setting their foreground colours
line 4:   " to the background's.
line 5:   if g:gitgutter_signs
line 6:     sign define GitGutterLineAdded           texthl=GitGutterAdd
line 7:     sign define GitGutterLineModified        texthl=GitGutterChange
line 8:     sign define GitGutterLineRemoved         texthl=GitGutterDelete
line 9:     sign define GitGutterLineRemovedFirstLine texthl=GitGutterDelete
line 10:     sign define GitGutterLineModifiedRemoved texthl=GitGutterChangeDelete
line 11:   else
line 12:     sign define GitGutterLineAdded           texthl=GitGutterAddInvisible
line 13:     sign define GitGutterLineModified        texthl=GitGutterChangeInvisible
line 14:     sign define GitGutterLineRemoved         texthl=GitGutterDeleteInvisible
line 15:     sign define GitGutterLineRemovedFirstLine texthl=GitGutterDeleteInvisible
line 16:     sign define GitGutterLineModifiedRemoved texthl=GitGutterChangeDeleteInvisible
line 17:   endif
function gitgutter#highlight#define_signs..gitgutter#highlight#define_sign_text_highlights returning #0

continuing in function gitgutter#highlight#define_signs

line 10:   call gitgutter#highlight#define_sign_line_highlights()
calling function gitgutter#highlight#define_signs..gitgutter#highlight#define_sign_line_highlights()

line 1:   if g:gitgutter_highlight_lines
line 2:     sign define GitGutterLineAdded           linehl=GitGutterAddLine
line 3:     sign define GitGutterLineModified        linehl=GitGutterChangeLine
line 4:     sign define GitGutterLineRemoved         linehl=GitGutterDeleteLine
line 5:     sign define GitGutterLineRemovedFirstLine linehl=GitGutterDeleteLine
line 6:     sign define GitGutterLineModifiedRemoved linehl=GitGutterChangeDeleteLine
line 7:   else
line 8:     sign define GitGutterLineAdded           linehl=
line 9:     sign define GitGutterLineModified        linehl=
line 10:     sign define GitGutterLineRemoved         linehl=
line 11:     sign define GitGutterLineRemovedFirstLine linehl=
line 12:     sign define GitGutterLineModifiedRemoved linehl=
line 13:   endif
function gitgutter#highlight#define_signs..gitgutter#highlight#define_sign_line_highlights returning #0

continuing in function gitgutter#highlight#define_signs

function gitgutter#highlight#define_signs returning #0

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim

line 50: 
line 51: " }}}
line 52: 
line 53: " Primary functions {{{
line 54: 
line 55: command GitGutterAll call gitgutter#all()
line 56: command GitGutter    call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)
line 57: 
line 58: command GitGutterDisable call gitgutter#disable()
line 59: command GitGutterEnable  call gitgutter#enable()
line 60: command GitGutterToggle  call gitgutter#toggle()
line 61: 
line 62: " }}}
line 63: 
line 64: " Line highlights {{{
line 65: 
line 66: command GitGutterLineHighlightsDisable call gitgutter#line_highlights_disable()
line 67: command GitGutterLineHighlightsEnable  call gitgutter#line_highlights_enable()
line 68: command GitGutterLineHighlightsToggle  call gitgutter#line_highlights_toggle()
line 69: 
line 70: " }}}
line 71: 
line 72: " Signs {{{
line 73: 
line 74: command GitGutterSignsEnable  call gitgutter#signs_enable()
line 75: command GitGutterSignsDisable call gitgutter#signs_disable()
line 76: command GitGutterSignsToggle  call gitgutter#signs_toggle()
line 77: 
line 78: " }}}
line 79: 
line 80: " Hunks {{{
line 81: 
line 82: command -count=1 GitGutterNextHunk call gitgutter#hunk#next_hunk(<count>)
line 83: command -count=1 GitGutterPrevHunk call gitgutter#hunk#prev_hunk(<count>)
line 84: 
line 85: command GitGutterStageHunk   call gitgutter#stage_hunk()
line 86: command GitGutterRevertHunk  call gitgutter#revert_hunk()
line 87: command GitGutterPreviewHunk call gitgutter#preview_hunk()
line 88: 
line 89: " Returns the git-diff hunks for the file or an empty list if there
line 90: " aren't any hunks.
line 91: "
line 92: " The return value is a list of lists.  There is one inner list per hunk.
line 93: "
line 94: "   [
line 95: "     [from_line, from_count, to_line, to_count],
line 96: "     [from_line, from_count, to_line, to_count],
line 97: "     ...
line 98: "   ]
line 99: "
line 100: " where:
line 101: "
line 102: " `from`  - refers to the staged file
line 103: " `to`    - refers to the working tree's file
line 104: " `line`  - refers to the line number where the change starts
line 105: " `count` - refers to the number of lines the change covers
line 106: function! GitGutterGetHunks()
line 109: 
line 110: " Returns an array that contains a summary of the current hunk status.
line 111: " The format is [ added, modified, removed ], where each value represents
line 112: " the number of lines added/modified/removed respectively.
line 113: function! GitGutterGetHunkSummary()
line 116: 
line 117: " }}}
line 118: 
line 119: command GitGutterDebug call gitgutter#debug#debug()
line 120: 
line 121: " Maps {{{
line 122: 
line 123: nnoremap <silent> <expr> <Plug>GitGutterNextHunk &diff ? ']c' : ":\<C-U>execute v:count1 . 'GitGutterNextHunk'\<CR>"
line 124: nnoremap <silent> <expr> <Plug>GitGutterPrevHunk &diff ? '[c' : ":\<C-U>execute v:count1 . 'GitGutterPrevHunk'\<CR>"
line 125: 
line 126: if g:gitgutter_map_keys
line 127:   if !hasmapto('<Plug>GitGutterPrevHunk') && maparg('[c', 'n') ==# ''
line 128:     nmap [c <Plug>GitGutterPrevHunk
line 129:   endif
line 130:   if !hasmapto('<Plug>GitGutterNextHunk') && maparg(']c', 'n') ==# ''
line 131:     nmap ]c <Plug>GitGutterNextHunk
line 132:   endif
line 133: endif
line 134: 
line 135: 
line 136: nnoremap <silent> <Plug>GitGutterStageHunk   :GitGutterStageHunk<CR>
line 137: nnoremap <silent> <Plug>GitGutterRevertHunk  :GitGutterRevertHunk<CR>
line 138: nnoremap <silent> <Plug>GitGutterPreviewHunk :GitGutterPreviewHunk<CR>
line 139: 
line 140: if g:gitgutter_map_keys
line 141:   if !hasmapto('<Plug>GitGutterStageHunk') && maparg('<Leader>hs', 'n') ==# ''
line 142:     nmap <Leader>hs <Plug>GitGutterStageHunk
line 143:   endif
line 144:   if !hasmapto('<Plug>GitGutterRevertHunk') && maparg('<Leader>hr', 'n') ==# ''
line 145:     nmap <Leader>hr <Plug>GitGutterRevertHunk
line 146:   endif
line 147:   if !hasmapto('<Plug>GitGutterPreviewHunk') && maparg('<Leader>hp', 'n') ==# ''
line 148:     nmap <Leader>hp <Plug>GitGutterPreviewHunk
line 149:   endif
line 150: endif
line 151: 
line 152: " }}}
line 153: 
line 154: " Autocommands {{{
line 155: 
line 156: augroup gitgutter
line 157:   autocmd!
line 158: 
line 159:   if g:gitgutter_realtime
line 160:     autocmd CursorHold,CursorHoldI * call gitgutter#process_buffer(gitgutter#utility#current_file(), 1)
line 161:   endif
line 162: 
line 163:   if g:gitgutter_eager
line 169:     autocmd BufEnter,BufWritePost,FileChangedShellPost *  if gettabvar(tabpagenr(), 'gitgutter_didtabenter')|   call settabvar(tabpagenr(), 'gitgutter_didtabenter', 0)| else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
line 172:     autocmd TabEnter *  call settabvar(tabpagenr(), 'gitgutter_didtabenter', 1)| call gitgutter#all()
line 173:     if !has('gui_win32')
line 174:       autocmd FocusGained * call gitgutter#all()
line 175:     endif
line 176:   else
line 177:     autocmd BufRead,BufWritePost,FileChangedShellPost * call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)
line 178:   endif
line 179: 
line 180:   autocmd ColorScheme * call gitgutter#highlight#define_sign_column_highlight() | call gitgutter#highlight#define_highlights()
line 181: 
line 182:   " Disable during :vimgrep
line 183:   autocmd QuickFixCmdPre  *vimgrep* let g:gitgutter_enabled = 0
line 184:   autocmd QuickFixCmdPost *vimgrep* let g:gitgutter_enabled = 1
line 185: augroup END
line 186: 
line 187: " }}}
line 188: 
line 189: " vim:set et sw=2 fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/ctrlp.vim/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim"
line 1: " =============================================================================
line 2: " File:          plugin/ctrlp.vim
line 3: " Description:   Fuzzy file, buffer, mru, tag, etc finder.
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: " GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip
line 7: 
line 8: if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
line 9: ^Ifini
line 10: en
line 11: let g:loaded_ctrlp = 1
line 12: 
line 15: let [g:ctrlp_lines, g:ctrlp_allfiles, g:ctrlp_alltags, g:ctrlp_alldirs, g:ctrlp_allmixes, g:ctrlp_buftags, g:ctrlp_ext_vars, g:ctrlp_builtins] = [[], [], [], [], {}, {}, [], 2]
line 16: 
line 17: if !exists('g:ctrlp_map') | let g:ctrlp_map = '<c-p>' | en
line 17:  let g:ctrlp_map = '<c-p>' | en
line 17:  en
line 18: if !exists('g:ctrlp_cmd') | let g:ctrlp_cmd = 'CtrlP' | en
line 18:  let g:ctrlp_cmd = 'CtrlP' | en
line 18:  en
line 19: 
line 20: com! -n=? -com=dir CtrlP         cal ctrlp#init(0, { 'dir': <q-args> })
line 21: com! -n=? -com=dir CtrlPMRUFiles cal ctrlp#init(2, { 'dir': <q-args> })
line 22: 
line 23: com! -bar CtrlPBuffer   cal ctrlp#init(1)
line 24: com! -n=? CtrlPLastMode cal ctrlp#init(-1, { 'args': <q-args> })
line 25: 
line 26: com! -bar CtrlPClearCache     cal ctrlp#clr()
line 27: com! -bar CtrlPClearAllCaches cal ctrlp#clra()
line 28: 
line 29: com! -bar ClearCtrlPCache     cal ctrlp#clr()
line 30: com! -bar ClearAllCtrlPCaches cal ctrlp#clra()
line 31: 
line 32: com! -bar CtrlPCurWD   cal ctrlp#init(0, { 'mode': '' })
line 33: com! -bar CtrlPCurFile cal ctrlp#init(0, { 'mode': 'c' })
line 34: com! -bar CtrlPRoot    cal ctrlp#init(0, { 'mode': 'r' })
line 35: 
line 36: if g:ctrlp_map != '' && !hasmapto(':<c-u>'.g:ctrlp_cmd.'<cr>', 'n')
line 37: ^Iexe 'nn <silent>' g:ctrlp_map ':<c-u>'.g:ctrlp_cmd.'<cr>'
line 37: nn <silent> <c-p> :<c-u>CtrlP<cr>
line 38: en
line 39: 
line 40: cal ctrlp#mrufiles#init()
Searching for "autoload/ctrlp/mrufiles.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Us
Searching for "/Users/leostera/.vim/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim"
chdir(/Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp)
fchdir() to previous dir
line 40: sourcing "/Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim"
line 1: " =============================================================================
line 2: " File:          autoload/ctrlp/mrufiles.vim
line 3: " Description:   Most Recently Used Files extension
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: 
line 7: " Static variables {{{1
line 8: let [s:mrbs, s:mrufs] = [[], []]
line 9: 
line 10: fu! ctrlp#mrufiles#opts()
line 23: cal ctrlp#mrufiles#opts()
calling function ctrlp#mrufiles#opts()

line 1: ^Ilet [pref, opts] = ['g:ctrlp_mruf_', { 'max': ['s:max', 250], 'include': ['s:in', ''], 'exclude': ['s:ex', ''], 'case_sensitive': ['s:cseno', 1], 'relative': ['s:re', 0], 'save_on_update': ['s:soup', 1], }]
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
function ctrlp#mrufiles#opts returning #0

continuing in /Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim

line 24: " Utilities {{{1
line 25: fu! s:excl(fn)
line 28: 
line 29: fu! s:mergelists()
line 35: 
line 36: fu! s:chop(mrufs)
line 40: 
line 41: fu! s:reformat(mrufs, ...)
line 56: 
line 57: fu! s:record(bufnr)
line 67: 
line 68: fu! s:addtomrufs(fname)
line 83: 
line 84: fu! s:savetofile(mrufs)
line 87: " Public {{{1
line 88: fu! ctrlp#mrufiles#refresh(...)
line 101: 
line 102: fu! ctrlp#mrufiles#remove(files)
line 113: 
line 114: fu! ctrlp#mrufiles#add(fn)
line 119: 
line 120: fu! ctrlp#mrufiles#list(...)
line 124: 
line 125: fu! ctrlp#mrufiles#bufs()
line 128: 
line 129: fu! ctrlp#mrufiles#tgrel()
line 132: 
line 133: fu! ctrlp#mrufiles#cachefile()
line 140: 
line 141: fu! ctrlp#mrufiles#init()
line 152: "}}}
line 153: 
line 154: " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
finished sourcing /Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim
continuing in /Users/leostera/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim
calling function ctrlp#mrufiles#init()

line 1: ^Iif !has('autocmd') | retu | en
line 1:  retu | en
line 1:  en
line 2: ^Ilet s:locked = 0
line 3: ^Iaug CtrlPMRUF
line 4: ^I^Iau!
line 5: ^I^Iau BufAdd,BufEnter,BufLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
line 6: ^I^Iau QuickFixCmdPre  *vimgrep* let s:locked = 1
line 7: ^I^Iau QuickFixCmdPost *vimgrep* let s:locked = 0
line 8: ^I^Iau VimLeavePre * cal s:savetofile(s:mergelists())
line 9: ^Iaug END
function ctrlp#mrufiles#init returning #0

continuing in /Users/leostera/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim

line 41: 
line 42: com! -bar CtrlPTag      cal ctrlp#init(ctrlp#tag#id())
line 43: com! -bar CtrlPQuickfix cal ctrlp#init(ctrlp#quickfix#id())
line 44: 
line 46: com! -n=? -com=dir CtrlPDir cal ctrlp#init(ctrlp#dir#id(), { 'dir': <q-args> })
line 47: 
line 49: com! -n=? -com=buffer CtrlPBufTag cal ctrlp#init(ctrlp#buffertag#cmd(0, <q-args>))
line 50: 
line 51: com! -bar CtrlPBufTagAll cal ctrlp#init(ctrlp#buffertag#cmd(1))
line 52: com! -bar CtrlPRTS       cal ctrlp#init(ctrlp#rtscript#id())
line 53: com! -bar CtrlPUndo      cal ctrlp#init(ctrlp#undo#id())
line 54: 
line 56: com! -n=? -com=buffer CtrlPLine cal ctrlp#init(ctrlp#line#cmd(1, <q-args>))
line 57: 
line 59: com! -n=? -com=buffer CtrlPChange cal ctrlp#init(ctrlp#changes#cmd(0, <q-args>))
line 60: 
line 61: com! -bar CtrlPChangeAll   cal ctrlp#init(ctrlp#changes#cmd(1))
line 62: com! -bar CtrlPMixed       cal ctrlp#init(ctrlp#mixed#id())
line 63: com! -bar CtrlPBookmarkDir cal ctrlp#init(ctrlp#bookmarkdir#id())
line 64: 
line 66: com! -n=? -com=dir CtrlPBookmarkDirAdd cal ctrlp#call('ctrlp#bookmarkdir#add', <q-args>)
line 67: 
line 68: " vim:ts=2:sw=2:sts=2
finished sourcing /Users/leostera/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/vim-multiple-cursors/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/vim-multiple-cursors/plugin/multiple_cursors.vim"
line 1: "===============================================================================
line 2: " File: multiple_cursors.vim
line 3: " Author: Terry Ma
line 4: " Description: Emulate Sublime Text's multi selection feature 
line 5: " Potential Features:
line 6: " - Create a blinking cursor effect? Good place to do it would be instead of
line 7: "   waiting for user input, cycle through the highlight
line 8: " - Integrate with the status line? Maybe show a special multicursor mode?
line 9: " - Support mouse? Ctrl/Cmd click to set cursor?
line 10: "===============================================================================
line 11: let s:save_cpo = &cpo
line 12: set cpo&vim
line 13: 
line 14: function! s:init_settings(settings)
line 27: 
line 28: " Settings
line 34: let s:settings = { 'exit_from_visual_mode': 1, 'exit_from_insert_mode': 1, 'use_default_mapping': 1, 'debug_latency': 0, }
line 35: 
line 41: let s:settings_if_default = { 'quit_key': '<Esc>', 'next_key': '<C-n>', 'prev_key': '<C-p>', 'skip_key': '<C-x>', }
line 42: 
line 43: call s:init_settings(s:settings)
calling function <SNR>37_init_settings({'exit_from_visual_mode': 1, 'exit_fr...g_latency': 0, 'use_default_mapping': 1})

line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_exit_from_visual_mode=get(g:, 'multi_cursor_exit_from_visual_mode', 1)
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_exit_from_insert_mode=get(g:, 'multi_cursor_exit_from_insert_mode', 1)
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_debug_latency=get(g:, 'multi_cursor_debug_latency', 0)
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_use_default_mapping=get(g:, 'multi_cursor_use_default_mapping', 1)
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 11:   endfor
function <SNR>37_init_settings returning #0

continuing in /Users/leostera/.vim/bundle/vim-multiple-cursors/plugin/multiple_cursors.vim

line 44: 
line 45: if g:multi_cursor_use_default_mapping
line 46:   call s:init_settings(s:settings_if_default)
calling function <SNR>37_init_settings({'quit_key': '<Esc>', 'next_key': '<C...prev_key': '<C-p>', 'skip_key': '<C-x>'})

line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_quit_key=get(g:, 'multi_cursor_quit_key', "<Esc>")
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_next_key=get(g:, 'multi_cursor_next_key', "<C-n>")
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_prev_key=get(g:, 'multi_cursor_prev_key', "<C-p>")
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 10: let g:multi_cursor_skip_key=get(g:, 'multi_cursor_skip_key', "<C-x>")
line 11:   endfor
line 1:   for [key, value] in items(a:settings)
line 2:     let sub = ''
line 3:     if type(value) == 0
line 4:       let sub = '%d'
line 5:     elseif type(value) == 1
line 6:       let sub = '"%s"'
line 7:     endif
line 8:     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
line 10:     exec printf(fmt, key, key, value)
line 11:   endfor
function <SNR>37_init_settings returning #0

continuing in /Users/leostera/.vim/bundle/vim-multiple-cursors/plugin/multiple_cursors.vim

line 47: endif
line 48: 
line 49: if !exists('g:multi_cursor_start_key') && exists('g:multi_cursor_next_key')
line 50:   let g:multi_cursor_start_key = g:multi_cursor_next_key
line 51: endif
line 52: 
line 53: " External mappings
line 54: if exists('g:multi_cursor_start_key')
line 56:   exec 'nnoremap <silent> '.g:multi_cursor_start_key.' :call multiple_cursors#new("n")<CR>'
line 56: nnoremap <silent> <C-n> :call multiple_cursors#new("n")<CR>
line 58:   exec 'xnoremap <silent> '.g:multi_cursor_start_key.' :<C-u>call multiple_cursors#new("v")<CR>'
line 58: xnoremap <silent> <C-n> :<C-u>call multiple_cursors#new("v")<CR>
line 59: endif
line 60: 
line 61: " Commands
line 63: command! -nargs=1 -range=% MultipleCursorsFind  call multiple_cursors#find(<line1>, <line2>, <q-args>)
line 64: 
line 65: let &cpo = s:save_cpo
line 66: unlet s:save_cpo
finished sourcing /Users/leostera/.vim/bundle/vim-multiple-cursors/plugin/multiple_cursors.vim
Searching for "/Users/leostera/.vim/bundle/powerline/plugin/**/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/plugin/**/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/**/*.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/getscriptPlugin.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2010 Mar 10
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 30:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 31:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 32:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 33:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 34:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 35:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 36:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 37:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 38:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 39:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 40:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 41:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 42:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 43:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 44: augroup END
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/gzip.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2013 May 08
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: augroup matchparen
line 22:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: function! s:Highlight_Matching_Pair()
line 160: 
line 161: " Define commands that will disable and enable the plugin.
line 163: command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen | au! matchparen
line 164: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
line 165: 
line 166: let &cpo = s:cpo_save
line 167: unlet s:cpo_save
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IJan 22, 2014
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v151"
line 24: if v:version < 702
line 25:  echohl WarningMsg
line 26:  echo "***warning*** you need vim version 7.2 for this version of netrw"
line 27:  echohl None
line 28:  finish
line 29: endif
line 30: if v:version < 703 || (v:version == 703 && !has("patch465"))
line 31:  echohl WarningMsg
line 32:  echo "***warning*** this version of netrw needs vim 7.3.465 or later"
line 33:  echohl Normal
line 34:  finish
line 35: endif
line 36: let s:keepcpo = &cpo
line 37: set cpo&vim
line 38: "DechoRemOn
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " Public Interface: {{{1
line 42: 
line 43: " Local Browsing Autocmds: {{{2
line 44: augroup FileExplorer
line 45:  au!
line 46:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 47:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 48:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 49:  if has("win32") || has("win95") || has("win64") || has("win16")
line 50:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 51:  endif
line 52: augroup END
line 53: 
line 54: " Network Browsing Reading Writing: {{{2
line 55: augroup Network
line 56:  au!
line 57:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))
line 58:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 59:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 60:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 61:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 62:  try
line 63:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 64:  catch /^Vim\%((\a\+)\)\=:E216/
line 65:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 66:  endtry
line 67: augroup END
line 68: 
line 69: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 70: com! -count=1 -nargs=*^INread^I^Icall netrw#SavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#RestorePosn()
line 71: com! -range=% -nargs=*^INwrite^I^Icall netrw#SavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#RestorePosn()
line 72: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 73: com! -nargs=*^I        Nsource^I^Icall netrw#SavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#RestorePosn()
line 74: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)
line 75: 
line 76: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 77: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 78: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 79: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 80: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 81: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 82: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 83: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 84: com! -nargs=* -bar       ^I  -complete=dir Lexplore^Icall netrw#Lexplore(<q-args>)
line 85: 
line 86: " Commands: NetrwSettings {{{2
line 87: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 88: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 89: 
line 90: " Maps:
line 91: if !exists("g:netrw_nogx") && maparg('gx','n') == ""
line 92:  if !hasmapto('<Plug>NetrwBrowseX')
line 93:   nmap <unique> gx <Plug>NetrwBrowseX
line 94:  endif
line 95:  nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cfile>"),0)<cr>
line 96: endif
line 97: 
line 98: " ---------------------------------------------------------------------
line 99: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 100: fun! s:LocalBrowse(dirname)
line 142: 
line 143: " ---------------------------------------------------------------------
line 144: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 145: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 146: "             them, which checks if they're directories and will create a directory
line 147: "             listing when appropriate.
line 148: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 149: "             has already been called.
line 150: fun! s:VimEnter(dirname)
line 158: 
line 159: " ---------------------------------------------------------------------
line 160: " NetrwStatusLine: {{{1
line 161: fun! NetrwStatusLine()
line 172: 
line 173: " ------------------------------------------------------------------------
line 174: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 175: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 176: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 177: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 178: fun! NetUserPass(...)
line 202: 
line 203: " ------------------------------------------------------------------------
line 204: " Modelines And Restoration: {{{1
line 205: let &cpo= s:keepcpo
line 206: unlet s:keepcpo
line 207: " vim:ts=8 fdm=marker
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/rrhelper.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
line 11: endif
line 12: let loaded_spellfile_plugin = 1
line 13: 
line 14: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/spellfile.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 46: augroup END
line 47: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 48: 
line 49: " ---------------------------------------------------------------------
line 50: " Restoration And Modelines: {{{1
line 51: " vim: fdm=marker
line 52: let &cpo= s:keepcpo
line 53: unlet s:keepcpo
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/tarPlugin.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2013 Jul 08
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: " TODO: {{{
line 9: "   * Options for generating the CSS in external style sheets. New :TOcss
line 10: "     command to convert the current color scheme into a (mostly) generic CSS
line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 12: "     by Erik Falor
line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 15: "     term) to use for the styling. Suggestion by "nacitar".
line 16: "   * Add way to override or specify which RGB colors map to the color numbers
line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 18: "   * Disable filetype detection until after all processing is done.
line 19: "   * Add option for not generating the hyperlink on stuff that looks like a
line 20: "     URL? Or just color the link to fit with the colorscheme (and only special
line 21: "     when hovering)?
line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 23: "     regions is turned on. Possible solution: Add normal text line numbers with
line 24: "     display:none, set to display:inline for print style sheets, and hide
line 25: "     <input> elements for print, to allow Opera printing multiple pages (and
line 26: "     other uncopyable areas?). May need to make the new text invisible to IE
line 27: "     with conditional comments to prevent copying it, IE for some reason likes
line 28: "     to copy hidden text. Other browsers too?
line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 31: "     on Windows). Perhaps it is font related?
line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 34: "     on diff lines though.
line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 38: "     accepted to modify it.
line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 42: "     does not show the whole diff filler as it is supposed to?
line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 44: "     invalid content. Can/should anything be done about this? Maybe a separate
line 45: "     plugin to correct 'isprint' based on encoding?
line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 48: "   * Font auto-detection similar to
line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 50: "     platforms.
line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 53: "^I- listchars support
line 54: "^I- full-line background highlight
line 55: "^I- other?
line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 57: "     free with full-line background highlight above).
line 58: "   * Restore open/closed folds and cursor position after processing each file
line 59: "     with option not to restore for speed increase.
line 60: "   * Add extra meta info (generation time, etc.)?
line 61: "   * Tidy up so we can use strict doctype in even more situations
line 62: "   * Implementation detail: add threshold for writing the lines to the html
line 63: "     buffer before we're done (5000 or so lines should do it)
line 64: "   * TODO comments for code cleanup scattered throughout
line 65: "}}}
line 66: 
line 67: if exists('g:loaded_2html_plugin')
line 68:   finish
line 69: endif
line 70: let g:loaded_2html_plugin = 'vim7.4_v1'
line 71: 
line 72: "
line 73: " Changelog: {{{
line 74: "   7.4_v1  (this version): Fix modeline mangling for new "Vim:" format, and
line 75: "^I^I^I    also for version-specific modelines like "vim>703:".
line 76: "
line 77: "   7.3 updates: {{{
line 78: "   7.3_v14 (ad6996a23e3e): Allow suppressing line number anchors using
line 79: "^I^I^I    g:html_line_ids=0. Allow customizing
line 80: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 81: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 82: "^I^I^I    is started.
line 83: "   7.3_v13 (2eb30f341e8d): Keep foldmethod at manual in the generated file and
line 84: "^I^I^I    insert modeline to set it to manual.
line 85: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 86: "^I^I^I    duplicate of one buffer instead of including both.
line 87: "^I^I^I    Add anchors to each line so you can put '#L123'
line 88: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 89: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 90: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 91: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 92: "^I^I^I    Allow TOhtml to chain together with other commands
line 93: "^I^I^I    using |.
line 94: "   7.3_v12 (9910cbff5f16): Fix modeline mangling to also work for when multiple
line 95: "^I^I^I    highlight groups make up the start-of-modeline text.
line 96: "^I^I^I    Improve render time of page with uncopyable regions
line 97: "^I^I^I    by not using one-input-per-char. Change name of
line 98: "^I^I^I    uncopyable option from html_unselectable to
line 99: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 100: "^I^I^I    default to inserting invalid markup for uncopyable
line 101: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 102: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 103: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 104: "^I^I^I    eliminate post-processing substitute commands in
line 105: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 106: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 107: "^I^I^I    speed improvements. Fix modeline mangling in
line 108: "^I^I^I    generated output so it works for text in the first
line 109: "^I^I^I    column. Fix missing line number and fold column in
line 110: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 111: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 112: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 113: "^I^I^I    the new default foldtext added in v11, as the patch
line 114: "^I^I^I    adding it has not yet been included in Vim.
line 115: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 116: "^I^I^I    Brabandt in
line 117: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 118: "^I^I^I    This patch has not yet been included in Vim, thus
line 119: "^I^I^I    these changes are removed in the next version.
line 120: "   7.3_v10 (fd09a9c8468e): Fix error E684 when converting a range wholly inside
line 121: "^I^I^I    multiple nested folds with dynamic folding on.
line 122: "^I^I^I    Also fix problem with foldtext in this situation.
line 123: "   7.3_v9  (0877b8d6370e): Add html_pre_wrap option active with html_use_css
line 124: "^I^I^I    and without html_no_pre, default value same as
line 125: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 126: "^I^I^I    'fileencoding' for converted document encoding if
line 127: "^I^I^I    'buftype' indicates a special buffer which isn't
line 128: "^I^I^I    written.
line 129: "   7.3_v8  (85c5a72551e2): Add html_expand_tabs option to allow leaving tab
line 130: "^I^I^I    characters in generated output (Andy Spencer).
line 131: "^I^I^I    Escape text that looks like a modeline so Vim
line 132: "^I^I^I    doesn't use anything in the converted HTML as a
line 133: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 134: "^I^I^I    before the conversion range. Remove fold column when
line 135: "^I^I^I    there are no folds.
line 136: "   7.3_v7  (840c3cadb842): see betas released on vim_dev below:
line 137: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 138: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 139: "^I^I^I    supported by all major browsers according to
line 140: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 141: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 142: "^I^I^I    HTML encoding to Vim encoding detection be
line 143: "^I^I^I    case-insensitive for built-in pairs.
line 144: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 145: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 146: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 147: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 148: "^I^I^I    file matches its indicated charset. Add charsets for
line 149: "^I^I^I    all of Vim's natively supported encodings.
line 150: "   7.3_v6  (0d3f0e3d289b): Really fix bug with 'nowrapscan', 'magic' and other
line 151: "^I^I^I    user settings interfering with diff mode generation,
line 152: "^I^I^I    trailing whitespace (e.g. line number column) when
line 153: "^I^I^I    using html_no_pre, and bugs when using
line 154: "^I^I^I    html_hover_unfold.
line 155: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 156: "^I^I^I    folds in diff mode when first line was folded.
line 157: "   7.3_v4  (7e008c174cc3): Bugfixes, especially for xhtml markup, and diff mode
line 158: "   7.3_v3  (a29075150aee): Refactor option handling and make html_use_css
line 159: "^I^I^I    default to true when not set to anything. Use strict
line 160: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 161: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 162: "^I^I^I    when using this option. Add meta tag for settings.
line 163: "   7.3_v2  (80229a724a11): Fix syntax highlighting in diff mode to use both the
line 164: "^I^I^I    diff colors and the normal syntax colors
line 165: "   7.3_v1  (e7751177126b): Add conceal support and meta tags in output
line 166: "   Pre-v1 baseline: Mercurial changeset 3c9324c0800e
line 167: "}}}
line 168: "}}}
line 169: 
line 170: " Define the :TOhtml command when:
line 171: " - 'compatible' is not set
line 172: " - this plugin was not already loaded
line 173: " - user commands are available. {{{
line 174: if !&cp && !exists(":TOhtml") && has("user_commands")
line 175:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 176: endif "}}}
line 177: 
line 178: " Make sure any patches will probably use consistent indent
line 179: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/tohtml.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell, Jr.
line 3: " Copyright: (c) 2004-2010 by Charles E. Campbell, Jr.
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v35"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -ra   -complete=file -na=+ -bang MkVimball^I^I^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -na=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -na=0                VimballList^I^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -na=* -complete=dir  RmVimball^I^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
line 30: au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
line 31: au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 32: au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
line 33: au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
line 34: au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 35: 
line 36: " =====================================================================
line 37: " Restoration And Modelines: {{{1
line 38: " vim: fdm=marker
line 39: let &cpo= s:keepcpo
line 40: unlet s:keepcpo
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/vimballPlugin.vim
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IJun 07, 2013
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v27"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext= '*.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/zipPlugin.vim
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/**/*.vim"
chdir(/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin)
fchdir() to previous dir
sourcing "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim"
line 1: if exists('g:powerline_loaded')
line 2:     finish
line 3: endif
line 4: let g:powerline_loaded = 1
line 5: 
line 6: if exists('g:powerline_pycmd')
line 7: ^Ilet s:pycmd = substitute(g:powerline_pycmd, '\v\C^(py)%[thon](3?)$', '\1\2', '')
line 8: ^Iif s:pycmd is# 'py'
line 9: ^I^Ilet s:has_python = has('python')
line 10: ^I^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'pyeval')
line 11: ^Ielseif s:pycmd is# 'py3'
line 12: ^I^Ilet s:has_python = has('python3')
line 13: ^I^Ilet s:pyeval = 'py3eval'
line 14: ^I^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'py3eval')
line 15: ^Ielse
line 16: ^I^Iif !exists('g:powerline_pyeval')
line 17: ^I^I^Iechohl ErrorMsg
line 18: ^I^I^I^Iechomsg 'g:powerline_pycmd was set to an unknown values, but g:powerline_pyeval'
line 19: ^I^I^I^Iechomsg 'was not set. You should either set g:powerline_pycmd to "py3" or "py",'
line 20: ^I^I^I^Iechomsg 'specify g:powerline_pyeval explicitly or unset both and let powerline'
line 21: ^I^I^I^Iechomsg 'figure them out.'
line 22: ^I^I^Iechohl None
line 23: ^I^I^Iunlet s:pycmd
line 24: ^I^I^Ifinish
line 25: ^I^Iendif
line 26: ^I^Ilet s:pyeval = g:powerline_pyeval
line 27: ^I^Ilet s:has_python = 1
line 28: ^Iendif
line 29: elseif has('python')
line 30: ^Ilet s:has_python = 1
line 31: ^Ilet s:pycmd = 'py'
line 32: ^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'pyeval')
line 33: elseif has('python3')
line 34: ^Ilet s:has_python = 1
line 35: ^Ilet s:pycmd = 'py3'
line 36: ^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'py3eval')
line 37: else
line 38: ^Ilet s:has_python = 0
line 39: endif
line 40: 
line 41: if !s:has_python
line 42: ^Iif !exists('g:powerline_no_python_error')
line 43: ^I^Iechohl ErrorMsg
line 44: ^I^I^Iechomsg 'You need vim compiled with Python 2.6, 2.7 or 3.2 and later support'
line 45: ^I^I^Iechomsg 'for Powerline to work. Please consult the documentation for more'
line 46: ^I^I^Iechomsg 'details.'
line 47: ^I^Iechohl None
line 48: ^Iendif
line 49: ^Iunlet s:has_python
line 50: ^Ifinish
line 51: endif
line 52: unlet s:has_python
line 53: 
line 54: let s:import_cmd = 'from powerline.vim import VimPowerline'
line 55: function s:rcmd(s)
line 62: try
line 63: ^Ilet s:can_replace_pyeval = !exists('g:powerline_pyeval')
line 64: ^Icall s:rcmd("try:")
calling function <SNR>48_rcmd('try:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 65: ^Icall s:rcmd("^Ipowerline_appended_path = None")
calling function <SNR>48_rcmd('	powerline_appended_path = None')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 66: ^Icall s:rcmd("^Itry:")
calling function <SNR>48_rcmd('	try:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 67: ^Icall s:rcmd("^I^I".s:import_cmd."")
calling function <SNR>48_rcmd('		from powerline.vim import VimPowerline')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 68: ^Icall s:rcmd("^Iexcept ImportError:")
calling function <SNR>48_rcmd('	except ImportError:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 69: ^Icall s:rcmd("^I^Iimport sys, vim")
calling function <SNR>48_rcmd('		import sys, vim')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 70: ^Icall s:rcmd("^I^Ipowerline_appended_path = vim.eval('expand(\"<sfile>:h:h:h:h:h\")')")
calling function <SNR>48_rcmd('		powerline_appended_path = vim.eval(''expand("<sfile>:h:h:h:h:h")'')')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 71: ^Icall s:rcmd("^I^Isys.path.append(powerline_appended_path)")
calling function <SNR>48_rcmd('		sys.path.append(powerline_appended_path)')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 72: ^Icall s:rcmd("^I^I".s:import_cmd."")
calling function <SNR>48_rcmd('		from powerline.vim import VimPowerline')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 73: ^Icall s:rcmd("^Iimport vim")
calling function <SNR>48_rcmd('	import vim')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 74: ^Icall s:rcmd("^IVimPowerline().setup(pyeval=vim.eval('s:pyeval'), pycmd=vim.eval('s:pycmd'), can_replace_pyeval=int(vim.eval('s:can_replace_pyeval')))")
calling function <SNR>48_rcmd('	VimPowerline().setup(pyeval=vim.ev...nt(vim.eval(''s:can_replace_pyeval'')))')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 75: ^Icall s:rcmd("^Idel VimPowerline")
calling function <SNR>48_rcmd('	del VimPowerline')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 76: ^Icall s:rcmd("except Exception:")
calling function <SNR>48_rcmd('except Exception:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 77: ^Icall s:rcmd("^Iimport traceback, sys")
calling function <SNR>48_rcmd('	import traceback, sys')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 78: ^Icall s:rcmd("^Itraceback.print_exc(file=sys.stdout)")
calling function <SNR>48_rcmd('	traceback.print_exc(file=sys.stdout)')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 79: ^Icall s:rcmd("^Iraise")
calling function <SNR>48_rcmd('	raise')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>48_rcmd returning #0

continuing in /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim

line 80: ^Iexecute s:pycmd s:pystr
line 80: py try:^@^Ipowerline_appended_path = None^@^Itry:^@^I^Ifrom powerline.vim import VimPowerline^@^Iexcept ImportError:^@^I^Iimport sys, vim^@^I^Ipowerline_appended_path = vim.eval('expand("<sfile>:h:h:h:h:h")')^@^I^Isys.path.append(powerline_appended_path)^@^I^Ifrom powerline.vim import VimPowerline^@^Iimport vim^@^IVimPowerline().setup(pyeval=vim.eval('s:pyeval'), pycmd=vim.eval('s:pycmd'), can_replace_pyeval=int(vim.eval('s:can_replace_pyeval')))^@^Idel VimPowerline^@except Exception:^@^Iimport traceback, sys^@^Itraceback.print_exc(file=sys.stdout)^@^Iraise^@
line 80: set statusline=%!pyeval('powerline.new_window()')
line 80: set tabline=%!pyeval('powerline.tabline()')
line 80: ^@^Ifunction! Powerline_plugin_ctrlp_main(...)^@^I^Ilet b:powerline_ctrlp_type = 'main'^@^I^Ilet b:powerline_ctrlp_args = a:000^@^Iendfunction
line 80: ^Ifunction! Powerline_plugin_ctrlp_main(...)^@^I^Ilet b:powerline_ctrlp_type = 'main'^@^I^Ilet b:powerline_ctrlp_args = a:000^@^Iendfunction
line 80: ^@^Ifunction! Powerline_plugin_ctrlp_prog(...)^@^I^Ilet b:powerline_ctrlp_type = 'prog'^@^I^Ilet b:powerline_ctrlp_args = a:000^@^Iendfunction
line 80: ^Ifunction! Powerline_plugin_ctrlp_prog(...)^@^I^Ilet b:powerline_ctrlp_type = 'prog'^@^I^Ilet b:powerline_ctrlp_args = a:000^@^Iendfunction
line 80: ^@^I^Ilet g:ctrlp_status_func = {'main': 'Powerline_plugin_ctrlp_main', 'prog': 'Powerline_plugin_ctrlp_prog'}^@^I
line 80: ^I^Ilet g:ctrlp_status_func = {'main': 'Powerline_plugin_ctrlp_main', 'prog': 'Powerline_plugin_ctrlp_prog'}^@^I
line 80: ^I
line 80: augroup Powerline
line 80: ^Iautocmd! ColorScheme * :py powerline.reset_highlight()
line 80: ^Iautocmd! VimLeavePre * :py powerline.shutdown()
line 80: augroup END
line 81: ^Iunlet s:pystr
line 82: ^Ilet s:launched = 1
line 83: finally
line 84: ^Iunlet s:can_replace_pyeval
line 85: ^Iunlet s:import_cmd
line 86: ^Iif !exists('s:launched')
line 87: ^I^Iunlet s:pystr
line 88: ^I^Iechohl ErrorMsg
line 89: ^I^I^Iechomsg 'An error occurred while importing powerline package.'
line 90: ^I^I^Iechomsg 'This could be caused by invalid sys.path setting,'
line 91: ^I^I^Iechomsg 'or by an incompatible Python version (powerline requires'
line 92: ^I^I^Iechomsg 'Python 2.6, 2.7 or 3.2 and later to work). Please consult'
line 93: ^I^I^Iechomsg 'the troubleshooting section in the documentation for'
line 94: ^I^I^Iechomsg 'possible solutions.'
line 95: ^I^I^Iif s:pycmd is# 'py' && has('python3')
line 96: ^I^I^I^Iechomsg 'If powerline on your system is installed for python 3 only you'
line 97: ^I^I^I^Iechomsg 'should set g:powerline_pycmd to "py3" to make it load correctly.'
line 98: ^I^I^Iendif
line 99: ^I^Iechohl None
line 100: ^I^Icall s:rcmd("def powerline_troubleshoot():")
line 101: ^I^Icall s:rcmd("^Iimport sys")
line 102: ^I^Icall s:rcmd("^Iimport vim")
line 103: ^I^Icall s:rcmd("^Iif sys.version_info < (2, 6):")
line 104: ^I^Icall s:rcmd("^I^Iprint('Too old python version: ' + sys.version + ' (first supported is 2.6)')")
line 105: ^I^Icall s:rcmd("^Ielif sys.version_info[0] == 3 and sys.version_info[1] < 2:")
line 106: ^I^Icall s:rcmd("^I^Iprint('Too old python 3 version: ' + sys.version + ' (first supported is 3.2)')")
line 107: ^I^Icall s:rcmd("^Itry:")
line 108: ^I^Icall s:rcmd("^I^Iimport powerline")
line 109: ^I^Icall s:rcmd("^Iexcept ImportError:")
line 110: ^I^Icall s:rcmd("^I^Iprint('Unable to import powerline, is it installed?')")
line 111: ^I^Icall s:rcmd("^Ielse:")
line 112: ^I^Icall s:rcmd("^I^Iif not vim.eval('expand(\"<sfile>\")').startswith('/usr/'):")
line 113: ^I^Icall s:rcmd("^I^I^Iimport os")
line 114: ^I^Icall s:rcmd("^I^I^Ipowerline_dir = os.path.realpath(os.path.normpath(powerline.__file__))")
line 115: ^I^Icall s:rcmd("^I^I^Ipowerline_dir = os.path.dirname(powerline.__file__)")
line 116: ^I^Icall s:rcmd("^I^I^Ithis_dir = os.path.realpath(os.path.normpath(vim.eval('expand(\"<sfile>:p\")')))")
line 117: ^I^Icall s:rcmd("^I^I^Ithis_dir = os.path.dirname(this_dir)")  " powerline/bindings/vim/plugin
line 118: ^I^Icall s:rcmd("^I^I^Ithis_dir = os.path.dirname(this_dir)")  " powerline/bindings/vim
line 119: ^I^Icall s:rcmd("^I^I^Ithis_dir = os.path.dirname(this_dir)")  " powerline/bindings
line 120: ^I^Icall s:rcmd("^I^I^Ithis_dir = os.path.dirname(this_dir)")  " powerline
line 121: ^I^Icall s:rcmd("^I^I^Iif os.path.basename(this_dir) != 'powerline':")
line 122: ^I^Icall s:rcmd("^I^I^I^Iprint('Check your installation:')")
line 123: ^I^Icall s:rcmd("^I^I^I^Iprint('this script is not in powerline[/bindings/vim/plugin] directory,')")
line 124: ^I^Icall s:rcmd("^I^I^I^Iprint('neither it is installed system-wide')")
line 125: ^I^Icall s:rcmd("^I^I^Ireal_powerline_dir = os.path.realpath(powerline_dir)")
line 126: ^I^Icall s:rcmd("^I^I^Ireal_this_dir = os.path.realpath(this_dir)")
line 127: ^I^Icall s:rcmd("^I^I^Ithis_dir_par = os.path.dirname(real_this_dir)")
line 128: ^I^Icall s:rcmd("^I^I^Ipowerline_appended_path = globals().get('powerline_appended_path')")
line 129: ^I^Icall s:rcmd("^I^I^Iif powerline_appended_path is not None and this_dir_par != powerline_appended_path:")
line 130: ^I^Icall s:rcmd("^I^I^I^Iprint('Check your installation: this script is symlinked somewhere')")
line 131: ^I^Icall s:rcmd("^I^I^I^Iprint('where powerline is not present: {0!r} != {1!r}.'.format(")
line 132: ^I^Icall s:rcmd("^I^I^I^I^Ireal_this_dir, powerline_appended_path))")
line 133: ^I^Icall s:rcmd("^I^I^Ielif real_powerline_dir != real_this_dir:")
line 134: ^I^Icall s:rcmd("^I^I^I^Iprint('It appears that you have two powerline versions installed:')")
line 135: ^I^Icall s:rcmd("^I^I^I^Iprint('one in ' + real_powerline_dir + ', other in ' + real_this_dir + '.')")
line 136: ^I^Icall s:rcmd("^I^I^I^Iprint('You should remove one of this. Check out troubleshooting section,')")
line 137: ^I^Icall s:rcmd("^I^I^I^Iprint('it contains some information about the alternatives.')")
line 138: ^I^Icall s:rcmd("try:")
line 139: ^I^Icall s:rcmd("^Ipowerline_troubleshoot()")
line 140: ^I^Icall s:rcmd("finally:")
line 141: ^I^Icall s:rcmd("^Idel powerline_troubleshoot")
line 142: ^I^Iexecute s:pycmd s:pystr
line 143: ^I^Iunlet s:pystr
line 144: ^I^Iunlet s:pycmd
line 145: ^I^Iunlet s:pyeval
line 146: ^I^Idelfunction s:rcmd
line 147: ^I^Ifinish
line 148: ^Ielse
line 149: ^I^Iunlet s:launched
line 150: ^Iendif
line 151: ^Iunlet s:pycmd
line 152: ^Iunlet s:pyeval
line 153: ^Idelfunction s:rcmd
line 154: endtry
finished sourcing /Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/plugin/powerline.vim
Searching for "/Users/leostera/.vim/bundle/vundle/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/plugin/**/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/plugin/**/*.vim"
Reading viminfo file "/Users/leostera/.viminfo" info oldfiles
"test.lisp" 
"test.lisp" 1L, 41C
Reading viminfo file "/Users/leostera/.viminfo" marks
Executing BufRead Auto commands for "*.lisp"
autocommand setf lisp

line 0: setf lisp
Executing FileType Auto commands for "*"
autocommand call s:LoadFTPlugin()

line 0: call s:LoadFTPlugin()
calling function <SNR>10_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17: ^Iexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 17: runtime! ftplugin/lisp.vim ftplugin/lisp_*.vim ftplugin/lisp/*.vim
Searching for "ftplugin/lisp.vim ftplugin/lisp_*.vim ftplugin/lisp/*.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/b
Searching for "/Users/leostera/.vim/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/ftplugin/lisp/*.vim"
chdir(/Users/leostera/.vim/ftplugin/lisp)
fchdir() to previous dir
line 17: sourcing "/Users/leostera/.vim/ftplugin/lisp/slimv-lisp.vim"
line 1: " slimv-lisp.vim:
line 2: "               Lisp filetype plugin for Slimv
line 3: " Version:      0.9.13
line 4: " Last Change:  04 May 2014
line 5: " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
line 6: " License:      This file is placed in the public domain.
line 7: "               No warranty, express or implied.
line 8: "               *** ***   Use At-Your-Own-Risk!   *** ***
line 9: "
line 10: " =====================================================================
line 11: "
line 12: "  Load Once:
line 13: if exists("b:did_ftplugin") || exists("g:slimv_disable_lisp")
line 14:     finish
line 15: endif
line 16: 
line 17: " Handle cases when lisp dialects explicitly use the lisp filetype plugins
line 18: if &ft == "clojure" && exists("g:slimv_disable_clojure")
line 19:     finish
line 20: endif
line 21: 
line 22: if &ft == "scheme" && exists("g:slimv_disable_scheme")
line 23:     finish
line 24: endif
line 25: 
line 26: " ---------- Begin part loaded once ----------
line 27: if !exists( 'g:slimv_lisp_loaded' )
line 28: 
line 29: let g:slimv_lisp_loaded = 1
line 30: 
line 31: " Descriptor array for various lisp implementations
line 32: " The structure of an array element is:
line 33: "     [ executable, implementation, platform, search path]
line 34: " where:
line 35: "     executable  - may contain wildcards but only if a search path is present
line 36: "     platform    - 'w' (Windows) or 'l' (Linux = non-Windows), '' for all
line 37: "     search path - commma separated list, may contain wildcard characters
line 62: let s:lisp_desc = [ [ 'sbcl',         'sbcl',      '',    '' ], [ 'clisp',        'clisp',     '',    '' ], [ 'gcl',          'clisp',     '',    '' ], [ 'cmucl',        'cmu',       '',    '' ], [ 'ecl',          'ecl',       '',    '' ], [ 'acl',          'allegro',   '',    '' ], [ 'mlisp',        'allegro',   '',    '' ], [ 'mlisp8',       'allegro',   '',    '' ], [ 'alisp',        'allegro',   '',    '' ], [ 'alisp8',       'allegro',   '',    '' ], [ 'lwl',          'lispworks', '',    '' ], [ 'ccl',          'clozure',   '',    '' ], [ 'wx86cl64',     'clozure',   'w64', '' ], [ 'wx86cl',       'clozure',   'w',   '' ], [ 'lx86cl',       'clozure',   'l',   '' ], [ '*lisp.exe',    'clisp',     'w',   'c:/*lisp*,c:/*lisp*/*,c:/*lisp*/bin/*,c:/Program Files/*lisp*,c:/Program Files/*lisp*/*,c:/Program Files/*lisp*/bin/*' ], [ 'gcl.exe',      'clisp',     'w',   'c:/gcl*,c:/Program Files/gcl*' ], [ 'cmucl.exe',    'cmu',       'w',   'c:/cmucl*,c:/Program Files/cmucl*' ], [ '*lisp*.exe',   'alleg
line 63: 
line 64: " Try to autodetect Lisp executable
line 65: " Returns list [Lisp executable, Lisp implementation]
line 66: function! SlimvAutodetect( preferred )
line 91: 
line 92: " Try to find out the Lisp implementation
line 93: function! SlimvImplementation()
line 121: 
line 122: " Try to autodetect SWANK and build the command to load the SWANK server
line 123: function! SlimvSwankLoader()
line 151: 
line 152: " Filetype specific initialization for the REPL buffer
line 153: function! SlimvInitRepl()
line 156: 
line 157: " Lookup symbol in the list of Lisp Hyperspec symbol databases
line 158: function! SlimvHyperspecLookup( word, exact, all )
line 185: 
line 186: " Source Slimv general part
line 187: runtime ftplugin/**/slimv.vim
Searching for "ftplugin/**/slimv.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/le
Searching for "/Users/leostera/.vim/ftplugin/**/slimv.vim"
chdir(/Users/leostera/.vim/ftplugin)
fchdir() to previous dir
line 187: sourcing "/Users/leostera/.vim/ftplugin/slimv.vim"
line 1: " slimv.vim:    The Superior Lisp Interaction Mode for VIM
line 2: " Version:      0.9.13
line 3: " Last Change:  01 Dec 2014
line 4: " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
line 5: " License:      This file is placed in the public domain.
line 6: "               No warranty, express or implied.
line 7: "               *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " =====================================================================
line 10: "
line 11: "  Load Once:
line 12: if &cp || exists( 'g:slimv_loaded' )
line 13:     finish
line 14: endif
line 15: 
line 16: let g:slimv_loaded = 1
line 17: 
line 18: let g:slimv_windows = 0
line 19: let g:slimv_cygwin  = 0
line 20: let g:slimv_osx     = 0
line 21: 
line 22: if has( 'win32' ) || has( 'win95' ) || has( 'win64' ) || has( 'win16' )
line 23:     let g:slimv_windows = 1
line 24: elseif has( 'win32unix' )
line 25:     let g:slimv_cygwin = 1
line 26: elseif has( 'macunix' )
line 27:     let g:slimv_osx = 1
line 28: endif
line 29: 
line 30: 
line 31: " =====================================================================
line 32: "  Functions used by global variable definitions
line 33: " =====================================================================
line 34: 
line 35: " Convert Cygwin path to Windows path, if needed
line 36: function! s:Cygpath( path )
line 45: 
line 46: " Find swank.py in the Vim ftplugin directory (if not given in vimrc)
line 47: if !exists( 'g:swank_path' )
line 48:     let plugins = split( globpath( &runtimepath, 'ftplugin/**/swank.py'), '\n' )
line 49:     if len( plugins ) > 0
line 50:         let g:swank_path = s:Cygpath( plugins[0] )
calling function <SNR>50_Cygpath('/Users/leostera/.vim/ftplugin/swank.py')

line 1:     let path = a:path
line 2:     if g:slimv_cygwin
line 3:         let path = system( 'cygpath -w ' . path )
line 4:         let path = substitute( path, "\n", "", "g" )
line 5:         let path = substitute( path, "\\", "/", "g" )
line 6:     endif
line 7:     return path
function <SNR>50_Cygpath returning '/Users/leostera/.vim/ftplugin/swank.py'

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 51:     else
line 52:         let g:swank_path = 'swank.py'
line 53:     endif
line 54: endif
line 55: 
line 56: " Get the filetype (Lisp dialect) used by Slimv
line 57: function! SlimvGetFiletype()
line 71: 
line 72: " Try to autodetect SWANK and build the command to start the SWANK server
line 73: function! SlimvSwankCommand()
line 118: 
line 119: " =====================================================================
line 120: "  Global variable definitions
line 121: " =====================================================================
line 122: 
line 123: " Host name or IP address of the SWANK server
line 124: if !exists( 'g:swank_host' )
line 125:     let g:swank_host = 'localhost'
line 126: endif
line 127: 
line 128: " TCP port number to use for the SWANK server
line 129: if !exists( 'g:swank_port' )
line 130:     let g:swank_port = 4005
line 131: endif
line 132: 
line 133: " Find Lisp (if not given in vimrc)
line 134: if !exists( 'g:slimv_lisp' )
line 135:     let lisp = ['', '']
line 136:     if exists( 'g:slimv_preferred' )
line 137:         let lisp = SlimvAutodetect( tolower(g:slimv_preferred) )
line 138:     endif
line 139:     if lisp[0] == ''
line 140:         let lisp = SlimvAutodetect( '' )
calling function SlimvAutodetect('')

line 1:     for lisp in s:lisp_desc
line 2:         if     lisp[2] =~ 'w' && !g:slimv_windows
line 3:             " Valid only on Windows
line 4:         elseif lisp[2] == 'w64' && $ProgramW6432 == ''
line 5:             " Valid only on 64 bit Windows
line 6:         elseif lisp[2] == 'l' &&  g:slimv_windows
line 7:             " Valid only on Linux
line 8:         elseif a:preferred != '' && a:preferred != lisp[1]
line 9:             " Not the preferred implementation
line 10:         elseif lisp[3] != ''
line 11:             " A search path is given
line 12:             let lisps = split( globpath( lisp[3], lisp[0] ), '\n' )
line 13:             if len( lisps ) > 0
line 14:                 return [lisps[0], lisp[1]]
line 15:             endif
line 16:         else
line 17:             " Single executable is given without path
line 18:             if executable( lisp[0] )
line 19:                 return lisp[0:1]
function SlimvAutodetect returning ['sbcl', 'sbcl']

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 141:     endif
line 142:     let g:slimv_lisp = lisp[0]
line 143:     if !exists( 'g:slimv_impl' )
line 144:         let g:slimv_impl = lisp[1]
line 145:     endif
line 146: endif
line 147: 
line 148: " Try to find out the Lisp implementation
line 149: " if not autodetected and not given in vimrc
line 150: if !exists( 'g:slimv_impl' )
line 151:     let g:slimv_impl = SlimvImplementation()
line 152: endif
line 153: 
line 154: " REPL buffer name
line 155: if !exists( 'g:slimv_repl_name' )
line 156:     let g:slimv_repl_name = 'REPL'
line 157: endif
line 158: 
line 159: " SLDB buffer name
line 160: if !exists( 'g:slimv_sldb_name' )
line 161:     let g:slimv_sldb_name = 'SLDB'
line 162: endif
line 163: 
line 164: " INSPECT buffer name
line 165: if !exists( 'g:slimv_inspect_name' )
line 166:     let g:slimv_inspect_name = 'INSPECT'
line 167: endif
line 168: 
line 169: " THREADS buffer name
line 170: if !exists( 'g:slimv_threads_name' )
line 171:     let g:slimv_threads_name = 'THREADS'
line 172: endif
line 173: 
line 174: " Shall we open REPL buffer in split window?
line 175: if !exists( 'g:slimv_repl_split' )
line 176:     let g:slimv_repl_split = 1
line 177: endif
line 178: 
line 179: " Wrap long lines in REPL buffer
line 180: if !exists( 'g:slimv_repl_wrap' )
line 181:     let g:slimv_repl_wrap = 1
line 182: endif
line 183: 
line 184: " Wrap long lines in SLDB buffer
line 185: if !exists( 'g:slimv_sldb_wrap' )
line 186:     let g:slimv_sldb_wrap = 0
line 187: endif
line 188: 
line 189: " Maximum number of lines echoed from the evaluated form
line 190: if !exists( 'g:slimv_echolines' )
line 191:     let g:slimv_echolines = 4
line 192: endif
line 193: 
line 194: " Syntax highlighting for the REPL buffer
line 195: if !exists( 'g:slimv_repl_syntax' )
line 196:     let g:slimv_repl_syntax = 1
line 197: endif
line 198: 
line 199: " Specifies the behaviour of insert mode <CR>, <Up>, <Down> in the REPL buffer:
line 200: " 1: <CR>   evaluates,      <Up>/<Down>     brings up command history
line 201: " 0: <C-CR> evaluates,      <C-Up>/<C-Down> brings up command history,
line 202: "    <CR>   opens new line, <Up>/<Down>     moves cursor up/down
line 203: if !exists( 'g:slimv_repl_simple_eval' )
line 204:     let g:slimv_repl_simple_eval = 1
line 205: endif
line 206: 
line 207: " Alternative value (in msec) for 'updatetime' while the REPL buffer is changing
line 208: if !exists( 'g:slimv_updatetime' )
line 209:     let g:slimv_updatetime = 500
line 210: endif
line 211: 
line 212: " Slimv keybinding set (0 = no keybindings)
line 213: if !exists( 'g:slimv_keybindings' )
line 214:     let g:slimv_keybindings = 1
line 215: endif
line 216: 
line 217: " Append Slimv menu to the global menu (0 = no menu)
line 218: if !exists( 'g:slimv_menu' )
line 219:     let g:slimv_menu = 1
line 220: endif
line 221: 
line 222: " Build the ctags command capable of generating lisp tags file
line 223: " The command can be run with execute 'silent !' . g:slimv_ctags
line 224: if !exists( 'g:slimv_ctags' )
line 225:     let ctags = split( globpath( '$vim,$vimruntime', 'ctags.exe' ), '\n' )
Calling shell to execute: "unset nonomatch; print -N >/var/folders/zs/xl3rmn054_l6td2l5g20vkc00000gn/T/vf2Zzoe/1 \$vim/ctags.exe"
Calling shell to execute: "unset nonomatch; print -N >/var/folders/zs/xl3rmn054_l6td2l5g20vkc00000gn/T/vf2Zzoe/2 \$vimruntime/ctags.exe"
line 226:     if len( ctags ) > 0
line 227:         " Remove -a option to regenerate every time
line 228:         let g:slimv_ctags = '"' . ctags[0] . '" -a --language-force=lisp *.lisp *.clj'
line 229:     endif
line 230: endif
line 231: 
line 232: " Package/namespace handling
line 233: if !exists( 'g:slimv_package' )
line 234:     let g:slimv_package = 1
line 235: endif
line 236: 
line 237: " General timeout for various startup and connection events (seconds)
line 238: if !exists( 'g:slimv_timeout' )
line 239:     let g:slimv_timeout = 20
line 240: endif
line 241: 
line 242: " Use balloonexpr to display symbol description
line 243: if !exists( 'g:slimv_balloon' )
line 244:     let g:slimv_balloon = 1
line 245: endif
line 246: 
line 247: " Shall we use simple or fuzzy completion?
line 248: if !exists( 'g:slimv_simple_compl' )
line 249:     let g:slimv_simple_compl = 0
line 250: endif
line 251: 
line 252: " Custom <Leader> for the Slimv plugin
line 253: if !exists( 'g:slimv_leader' )
line 254:     if exists( 'mapleader' ) && mapleader != ' '
line 255:         let g:slimv_leader = mapleader
line 256:     else
line 257:         let g:slimv_leader = ','
line 258:     endif
line 259: endif
line 260: 
line 261: " Maximum number of lines searched backwards for indenting special forms
line 262: if !exists( 'g:slimv_indent_maxlines' )
line 263:     let g:slimv_indent_maxlines = 50
line 264: endif
line 265: 
line 266: " Special indentation for keyword lists
line 267: if !exists( 'g:slimv_indent_keylists' )
line 268:     let g:slimv_indent_keylists = 1
line 269: endif
line 270: 
line 271: " Maximum length of the REPL buffer
line 272: if !exists( 'g:slimv_repl_max_len' )
line 273:     let g:slimv_repl_max_len = 0
line 274: endif
line 275: 
line 276: " =====================================================================
line 277: "  Template definitions
line 278: " =====================================================================
line 279: 
line 280: if !exists( 'g:slimv_template_apropos' )
line 281:     if SlimvGetFiletype() =~ '.*clojure.*'
calling function SlimvGetFiletype()

line 1:     if &ft != ''
line 2:         " Return Vim filetype if defined
line 3:         return &ft
function SlimvGetFiletype returning 'lisp'

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 282:         let g:slimv_template_apropos = '(find-doc "%1")'
line 283:     else
line 284:         let g:slimv_template_apropos = '(apropos "%1")'
line 285:     endif
line 286: endif
line 287: 
line 288: 
line 289: " =====================================================================
line 290: "  Other non-global script variables
line 291: " =====================================================================
line 292: 
line 293: let s:indent = ''                                         " Most recent indentation info
line 294: let s:last_update = 0                                     " The last update time for the REPL buffer
line 295: let s:save_updatetime = &updatetime                       " The original value for 'updatetime'
line 296: let s:save_showmode = &showmode                           " The original value for 'showmode'
line 297: let s:python_initialized = 0                              " Is the embedded Python initialized?
line 298: let s:swank_connected = 0                                 " Is the SWANK server connected?
line 299: let s:swank_package = ''                                  " Package to use at the next SWANK eval
line 300: let s:swank_form = ''                                     " Form to send to SWANK
line 301: let s:refresh_disabled = 0                                " Set this variable temporarily to avoid recursive REPL rehresh calls
line 302: let s:sldb_level = -1                                     " Are we in the SWANK debugger? -1 == no, else SLDB level
line 303: let s:break_on_exception = 0                              " Enable debugger break on exceptions (for ritz-swank)
line 304: let s:compiled_file = ''                                  " Name of the compiled file
line 305: let s:win_id = 0                                          " Counter for generating unique window id
line 306: let s:repl_buf = -1                                       " Buffer number for the REPL buffer
line 307: let s:current_buf = -1                                    " Swank action was requested from this buffer
line 308: let s:current_win = 0                                     " Swank action was requested from this window
line 309: let s:arglist_line = 0                                    " Arglist was requested in this line ...
line 310: let s:arglist_col = 0                                     " ... and column
line 311: let s:inspect_path = []                                   " Inspection path of the current object
line 312: let s:skip_sc = 'synIDattr(synID(line("."), col("."), 0), "name") =~ "[Ss]tring\\|[Cc]omment"'
line 313:                                                           " Skip matches inside string or comment 
line 314: let s:skip_q = 'getline(".")[col(".")-2] == "\\"'         " Skip escaped double quote characters in matches
line 315: let s:frame_def = '^\s\{0,2}\d\{1,}:'                     " Regular expression to match SLDB restart or frame identifier
line 316: let s:spec_indent = 'flet\|labels\|macrolet\|symbol-macrolet'
line 317:                                                           " List of symbols need special indenting
line 318: let s:spec_param = 'defmacro'                             " List of symbols with special parameter list
line 319: let s:binding_form = 'let\|let\*'                         " List of symbols with binding list
line 320: 
line 321: " =====================================================================
line 322: "  General utility functions
line 323: " =====================================================================
line 324: 
line 325: " Display an error message
line 326: function! SlimvError( msg )
line 331: 
line 332: " Display an error message and a question, return user response
line 333: function! SlimvErrorAsk( msg, question )
line 340: 
line 341: " Display an error message and wait for ENTER
line 342: function! SlimvErrorWait( msg )
line 345: 
line 346: " Shorten long messages to fit status line
line 347: function! SlimvShortEcho( msg )
line 353: 
line 354: " Go to the end of buffer, make sure the cursor is positioned
line 355: " after the last character of the buffer when in insert mode
line 356: function s:EndOfBuffer()
line 362: 
line 363: " Position the cursor at the end of the REPL buffer
line 364: " Optionally mark this position in Vim mark 's'
line 365: function! SlimvEndOfReplBuffer( force )
line 371: 
line 372: " Remember the end of the REPL buffer: user may enter commands here
line 373: " Also remember the prompt, because the user may overwrite it
line 374: function! SlimvMarkBufferEnd( force )
line 383: 
line 384: " Get REPL prompt line. Fix stored prompt position when corrupted
line 385: " (e.g. some lines were deleted from the REPL buffer)
line 386: function! s:GetPromptLine()
line 395: 
line 396: " Generate unique window id for the current window
line 397: function s:MakeWindowId()
line 403: 
line 404: " Find and switch to window with the specified window id
line 405: function s:SwitchToWindow( id )
line 412: 
line 413: " Save caller buffer identification
line 414: function! SlimvBeginUpdate()
line 419: 
line 420: " Switch to the buffer/window that was active before a swank action
line 421: function! SlimvRestoreFocus( hide_current_buf )
line 444: 
line 445: " Handle response coming from the SWANK listener
line 446: function! SlimvSwankResponse()
line 480: 
line 481: " Execute the given command and write its output at the end of the REPL buffer
line 482: function! SlimvCommand( cmd )
line 490: 
line 491: " Execute the given SWANK command, wait for and return the response
line 492: function! SlimvCommandGetResponse( name, cmd, timeout )
line 509: 
line 510: " Reload the contents of the REPL buffer from the output file if changed
line 511: function! SlimvRefreshReplBuffer()
line 533: 
line 534: " This function re-triggers the CursorHold event
line 535: " after refreshing the REPL buffer
line 536: function! SlimvTimer()
line 555: 
line 556: " Switch refresh mode on:
line 557: " refresh REPL buffer on frequent Vim events
line 558: function! SlimvRefreshModeOn()
line 565: 
line 566: " Switch refresh mode off
line 567: function! SlimvRefreshModeOff()
line 572: 
line 573: " Called when entering REPL buffer
line 574: function! SlimvReplEnter()
line 582: 
line 583: " Called when leaving REPL buffer
line 584: function! SlimvReplLeave()
line 598: 
line 599: " Refresh cursor position in the REPL buffer after new lines appended
line 600: function! SlimvReplSetCursorPos( force )
line 611: 
line 612: " View the given file in a top/bottom/left/right split window
line 613: function! s:SplitView( filename )
line 655: 
line 656: " Open a buffer with the given name if not yet open, and switch to it
line 657: function! SlimvOpenBuffer( name )
line 689: 
line 690: " Go to the end of the screen line
line 691: function s:EndOfScreenLine()
line 699: 
line 700: " Set special syntax rules for the REPL buffer
line 701: function! SlimvSetSyntaxRepl()
line 797: 
line 798: " Open a new REPL buffer
line 799: function! SlimvOpenReplBuffer()
line 880: 
line 881: " Clear the contents of the REPL buffer, keeping the last prompt only
line 882: function! SlimvClearReplBuffer()
line 901: 
line 902: " Open a new Inspect buffer
line 903: function SlimvOpenInspectBuffer()
line 931: 
line 932: " Open a new Threads buffer
line 933: function SlimvOpenThreadsBuffer()
line 946: 
line 947: " Open a new SLDB buffer
line 948: function SlimvOpenSldbBuffer()
line 986: 
line 987: " End updating an otherwise readonly buffer
line 988: function SlimvEndUpdate()
line 992: 
line 993: " Quit Inspector
line 994: function SlimvQuitInspect( force )
line 1007: 
line 1008: " Quit Threads
line 1009: function SlimvQuitThreads()
line 1016: 
line 1017: " Quit Sldb
line 1018: function SlimvQuitSldb()
line 1025: 
line 1026: " Create help text for Inspect buffer
line 1027: function SlimvHelpInspect()
line 1035: 
line 1036: " Create help text for Threads buffer
line 1037: function SlimvHelpThreads()
line 1047: 
line 1048: " Write help text to current buffer at given line
line 1049: function SlimvHelp( line )
line 1059: 
line 1060: " Toggle help
line 1061: function SlimvToggleHelp()
line 1074: 
line 1075: " Open SLDB buffer and place cursor on the given frame
line 1076: function SlimvGotoFrame( frame )
line 1090: 
line 1091: " Set 'iskeyword' option depending on file type
line 1092: function! s:SetKeyword()
line 1099: 
line 1100: " Select symbol under cursor and return it
line 1101: function! SlimvSelectSymbol()
line 1111: 
line 1112: " Select symbol with possible prefixes under cursor and return it
line 1113: function! SlimvSelectSymbolExt()
line 1121: 
line 1122: " Select bottom level form the cursor is inside and copy it to register 's'
line 1123: function! SlimvSelectForm( extended )
line 1163: 
line 1164: " Find starting '(' of a top level form
line 1165: function! SlimvFindDefunStart()
line 1176: 
line 1177: " Select top level form the cursor is inside and copy it to register 's'
line 1178: function! SlimvSelectDefun()
line 1188: 
line 1189: " Return the contents of register 's'
line 1190: function! SlimvGetSelection()
line 1193: 
line 1194: " Find language specific package/namespace definition backwards
line 1195: " Set it as the current package for the next swank action
line 1196: function! SlimvFindPackage()
line 1235: 
line 1236: " Execute the given SWANK command with current package defined
line 1237: function! SlimvCommandUsePackage( cmd )
line 1245: 
line 1246: " Initialize embedded Python and connect to SWANK server
line 1247: function! SlimvConnectSwank()
line 1331: 
line 1332: " Send argument to Lisp server for evaluation
line 1333: function! SlimvSend( args, echoing, output )
line 1376: 
line 1377: " Eval arguments in Lisp REPL
line 1378: function! SlimvEval( args )
line 1381: 
line 1382: " Send argument silently to SWANK
line 1383: function! SlimvSendSilent( args )
line 1386: 
line 1387: " Set command line after the prompt
line 1388: function! SlimvSetCommandLine( cmd )
line 1417: 
line 1418: " Add command list to the command history
line 1419: function! SlimvAddHistory( cmd )
line 1433: 
line 1434: " Recall command from the command history at the marked position
line 1435: function! SlimvRecallHistory( direction )
line 1462: 
line 1463: " Return missing parens, double quotes, etc to properly close form
line 1464: function! s:CloseForm( form )
line 1512: 
line 1513: " Some multi-byte characters screw up the built-in lispindent()
line 1514: " This function is a wrapper that tries to fix it
line 1515: " TODO: implement custom indent procedure and omit lispindent()
line 1516: function SlimvLispindent( lnum )
line 1575: 
line 1576: " Return Lisp source code indentation at the given line
line 1577: function! SlimvIndent( lnum )
line 1804: 
line 1805: " Convert indent value to spaces or a mix of tabs and spaces
line 1806: " depending on the value of 'expandtab'
line 1807: function! s:MakeIndent( indent )
line 1814: 
line 1815: " Send command line to REPL buffer
line 1816: " Arguments: close = add missing closing parens
line 1817: function! SlimvSendCommand( close )
line 1873: 
line 1874: " Close current top level form by adding the missing parens
line 1875: function! SlimvCloseForm()
line 1899: 
line 1900: " Handle insert mode 'Enter' keypress
line 1901: function! SlimvHandleEnter()
line 1917: 
line 1918: " Display arglist after pressing Enter
line 1919: function! SlimvArglistOnEnter()
line 1940: 
line 1941: " Handle insert mode 'Tab' keypress by doing completion or indentation
line 1942: function! SlimvHandleTab()
line 1961: 
line 1962: " Handle insert mode 'Backspace' keypress in the REPL buffer
line 1963: function! SlimvHandleBS()
line 1971: 
line 1972: " Recall previous command from command history
line 1973: function! s:PreviousCommand()
line 1978: 
line 1979: " Recall next command from command history
line 1980: function! s:NextCommand()
line 1987: 
line 1988: " Handle insert mode 'Up' keypress in the REPL buffer
line 1989: function! SlimvHandleUp()
line 2000: 
line 2001: " Handle insert mode 'Down' keypress in the REPL buffer
line 2002: function! SlimvHandleDown()
line 2013: 
line 2014: " Make a fold at the cursor point in the current buffer
line 2015: function SlimvMakeFold()
line 2020: 
line 2021: " Handle insert mode 'Enter' keypress in the REPL buffer
line 2022: function! SlimvHandleEnterRepl()
line 2078: 
line 2079: " Handle normal mode 'Enter' keypress in the SLDB buffer
line 2080: function! SlimvHandleEnterSldb()
line 2135: 
line 2136: " Restore Inspector cursor position if the referenced title has already been visited
line 2137: function SlimvSetInspectPos( title )
line 2144: 
line 2145: " Handle normal mode 'Enter' keypress in the Inspector buffer
line 2146: function! SlimvHandleEnterInspect()
line 2259: 
line 2260: " Go to command line and recall previous command from command history
line 2261: function! SlimvPreviousCommand()
line 2270: 
line 2271: " Go to command line and recall next command from command history
line 2272: function! SlimvNextCommand()
line 2281: 
line 2282: " Handle interrupt (Ctrl-C) keypress in the REPL buffer
line 2283: function! SlimvInterrupt()
line 2287: 
line 2288: " Select a specific restart in debugger
line 2289: function! SlimvDebugCommand( name, cmd )
line 2311: 
line 2312: " Various debugger restarts
line 2313: function! SlimvDebugAbort()
line 2316: 
line 2317: function! SlimvDebugQuit()
line 2320: 
line 2321: function! SlimvDebugContinue()
line 2324: 
line 2325: " Restart execution of the frame with the same arguments
line 2326: function! SlimvDebugRestartFrame()
line 2333: 
line 2334: " List current Lisp threads
line 2335: function! SlimvListThreads()
line 2341: 
line 2342: " Kill thread(s) selected from the Thread List
line 2343: function! SlimvKillThread() range
line 2369: 
line 2370: " Debug thread selected from the Thread List
line 2371: function! SlimvDebugThread()
line 2382: 
line 2383: function! SlimvRFunction()
line 2395: 
line 2396: " Display function argument list
line 2397: " Optional argument is the number of characters typed after the keyword
line 2398: function! SlimvArglist( ... )
line 2470: 
line 2471: " Start and connect swank server
line 2472: function! SlimvConnectServer()
line 2486: 
line 2487: " Get the last region (visual block)
line 2488: function! SlimvGetRegion(first, last)
line 2517: 
line 2518: " Eval buffer lines in the given range
line 2519: function! SlimvEvalRegion() range
line 2544: 
line 2545: " Eval contents of the 's' register, optionally store it in another register
line 2546: " Also optionally append a test form for quick testing (not stored in 'outreg')
line 2547: " If the test form contains '%1' then it 'wraps' the selection around the '%1'
line 2548: function! SlimvEvalSelection( outreg, testform )
line 2579: 
line 2580: " Eval Lisp form.
line 2581: " Form given in the template is passed to Lisp without modification.
line 2582: function! SlimvEvalForm( template )
line 2586: 
line 2587: " Eval Lisp form, with the given parameter substituted in the template.
line 2588: " %1 string is substituted with par1
line 2589: function! SlimvEvalForm1( template, par1 )
line 2595: 
line 2596: " Eval Lisp form, with the given parameters substituted in the template.
line 2597: " %1 string is substituted with par1
line 2598: " %2 string is substituted with par2
line 2599: function! SlimvEvalForm2( template, par1, par2 )
line 2607: 
line 2608: 
line 2609: " =====================================================================
line 2610: "  Special functions
line 2611: " =====================================================================
line 2612: 
line 2613: " Evaluate and test top level form at the cursor pos
line 2614: function! SlimvEvalTestDefun( testform )
line 2624: 
line 2625: " Evaluate top level form at the cursor pos
line 2626: function! SlimvEvalDefun()
line 2629: 
line 2630: " Evaluate the whole buffer
line 2631: function! SlimvEvalBuffer()
line 2644: 
line 2645: " Return frame number if we are in the Backtrace section of the debugger
line 2646: function! s:DebugFrame()
line 2667: 
line 2668: " Evaluate and test current s-expression at the cursor pos
line 2669: function! SlimvEvalTestExp( testform )
line 2679: 
line 2680: " Evaluate current s-expression at the cursor pos
line 2681: function! SlimvEvalExp()
line 2684: 
line 2685: " Evaluate expression entered interactively
line 2686: function! SlimvInteractiveEval()
line 2705: 
line 2706: " Undefine function
line 2707: function! SlimvUndefineFunction()
line 2713: 
line 2714: " ---------------------------------------------------------------------
line 2715: 
line 2716: " Macroexpand-1 the current top level form
line 2717: function! SlimvMacroexpand()
line 2730: 
line 2731: " Macroexpand the current top level form
line 2732: function! SlimvMacroexpandAll()
line 2745: 
line 2746: " Toggle debugger break on exceptions
line 2747: " Only for ritz-swank 0.4.0 and above
line 2748: function! SlimvBreakOnException()
line 2761: 
line 2762: " Set a breakpoint on the beginning of a function
line 2763: function! SlimvBreak()
line 2772: 
line 2773: " Switch trace on for the selected function (toggle for swank)
line 2774: function! SlimvTrace()
line 2787: 
line 2788: " Switch trace off for the selected function (or all functions for swank)
line 2789: function! SlimvUntrace()
line 2801: 
line 2802: " Disassemble the selected function
line 2803: function! SlimvDisassemble()
line 2812: 
line 2813: " Inspect symbol under cursor
line 2814: function! SlimvInspect()
line 2852: 
line 2853: " Cross reference: who calls
line 2854: function! SlimvXrefBase( text, cmd )
line 2862: 
line 2863: " Cross reference: who calls
line 2864: function! SlimvXrefCalls()
line 2867: 
line 2868: " Cross reference: who references
line 2869: function! SlimvXrefReferences()
line 2872: 
line 2873: " Cross reference: who sets
line 2874: function! SlimvXrefSets()
line 2877: 
line 2878: " Cross reference: who binds
line 2879: function! SlimvXrefBinds()
line 2882: 
line 2883: " Cross reference: who macroexpands
line 2884: function! SlimvXrefMacroexpands()
line 2887: 
line 2888: " Cross reference: who specializes
line 2889: function! SlimvXrefSpecializes()
line 2892: 
line 2893: " Cross reference: list callers
line 2894: function! SlimvXrefCallers()
line 2897: 
line 2898: " Cross reference: list callees
line 2899: function! SlimvXrefCallees()
line 2902: 
line 2903: " ---------------------------------------------------------------------
line 2904: 
line 2905: " Switch or toggle profiling on for the selected function
line 2906: function! SlimvProfile()
line 2915: 
line 2916: " Switch profiling on based on substring
line 2917: function! SlimvProfileSubstring()
line 2927: 
line 2928: " Switch profiling completely off
line 2929: function! SlimvUnprofileAll()
line 2934: 
line 2935: " Display list of profiled functions
line 2936: function! SlimvShowProfiled()
line 2941: 
line 2942: " Report profiling results
line 2943: function! SlimvProfileReport()
line 2948: 
line 2949: " Reset profiling counters
line 2950: function! SlimvProfileReset()
line 2955: 
line 2956: " ---------------------------------------------------------------------
line 2957: 
line 2958: " Compile the current top-level form
line 2959: function! SlimvCompileDefun()
line 2970: 
line 2971: " Compile and load whole file
line 2972: function! SlimvCompileLoadFile()
line 2998: 
line 2999: " Compile whole file
line 3000: function! SlimvCompileFile()
line 3017: 
line 3018: " Compile buffer lines in the given range
line 3019: function! SlimvCompileRegion() range
line 3041: 
line 3042: " ---------------------------------------------------------------------
line 3043: 
line 3044: " Describe the selected symbol
line 3045: function! SlimvDescribeSymbol()
line 3055: 
line 3056: " Display symbol description in balloonexpr
line 3057: function! SlimvDescribe(arg)
line 3087: 
line 3088: " Apropos of the selected symbol
line 3089: function! SlimvApropos()
line 3092: 
line 3093: " Generate tags file using ctags
line 3094: function! SlimvGenerateTags()
line 3101: 
line 3102: " ---------------------------------------------------------------------
line 3103: 
line 3104: " Find word in the CLHS symbol database, with exact or partial match.
line 3105: " Return either the first symbol found with the associated URL,
line 3106: " or the list of all symbols found without the associated URL.
line 3107: function! SlimvFindSymbol( word, exact, all, db, root, init )
line 3145: 
line 3146: " Lookup word in Common Lisp Hyperspec
line 3147: function! SlimvLookup( word )
line 3207: 
line 3208: " Lookup current symbol in the Common Lisp Hyperspec
line 3209: function! SlimvHyperspec()
line 3212: 
line 3213: " Complete symbol name starting with 'base'
line 3214: function! SlimvComplete( base )
line 3266: 
line 3267: " Complete function that uses the Hyperspec database
line 3268: function! SlimvOmniComplete( findstart, base )
line 3278: 
line 3279: " Define complete function only if none is defined yet
line 3280: if &omnifunc == ''
line 3281:     set omnifunc=SlimvOmniComplete
line 3282: endif
line 3283: 
line 3284: " Complete function for user-defined commands
line 3285: function! SlimvCommandComplete( arglead, cmdline, cursorpos )
line 3304: 
line 3305: " Set current package
line 3306: function! SlimvSetPackage()
line 3318: 
line 3319: " =====================================================================
line 3320: "  Slimv keybindings
line 3321: " =====================================================================
line 3322: 
line 3323: " <Leader> timeouts in 1000 msec by default, if this is too short,
line 3324: " then increase 'timeoutlen'
line 3325: 
line 3326: " Map keyboard keyset dependant shortcut to command and also add it to menu
line 3327: function! s:MenuMap( name, shortcut1, shortcut2, command )
line 3345: 
line 3346: " Initialize buffer by adding buffer specific mappings
line 3347: function! SlimvInitBuffer()
line 3374: 
line 3375: " Edit commands
line 3376: call s:MenuMap( 'Slim&v.Edi&t.Close-&Form',                     g:slimv_leader.')',  g:slimv_leader.'tc',  ':<C-U>call SlimvCloseForm()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Close-&Form', ',)', ',tc', ':<C-U>call SlimvCloseForm()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,) :<C-U>call SlimvCloseForm()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.Edi&t.Close-&Form<Tab>,) :<C-U>call SlimvCloseForm()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3377: call s:MenuMap( 'Slim&v.Edi&t.&Complete-Symbol<Tab>Tab',        '',                  '',                   '<Ins><C-X><C-O>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.&Complete-Symbol<Tab>Tab', '', '', '<Ins><C-X><C-O>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.&Complete-Symbol<Tab>Tab <Ins><C-X><C-O>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3378: 
line 3379: if exists( 'g:paredit_loaded' )
line 3380: call s:MenuMap( 'Slim&v.Edi&t.&Paredit-Toggle',                 g:slimv_leader.'(',  g:slimv_leader.'(t',  ':<C-U>call PareditToggle()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.&Paredit-Toggle', ',(', ',(t', ':<C-U>call PareditToggle()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,( :<C-U>call PareditToggle()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.Edi&t.&Paredit-Toggle<Tab>,( :<C-U>call PareditToggle()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3381: call s:MenuMap( 'Slim&v.Edi&t.-PareditSep-',                    '',                  '',                   ':' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.-PareditSep-', '', '', ':')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.-PareditSep- :
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3382: 
line 3383: if g:paredit_shortmaps
line 3384: call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Wrap<Tab>'                             .'W',  '',  '',              ':<C-U>call PareditWrap("(",")")<CR>' )
line 3385: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Spli&ce<Tab>'                           .'S',  '',  '',              ':<C-U>call PareditSplice()<CR>' )
line 3386: call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Split<Tab>'                            .'O',  '',  '',              ':<C-U>call PareditSplit()<CR>' )
line 3387: call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Join<Tab>'                             .'J',  '',  '',              ':<C-U>call PareditJoin()<CR>' )
line 3388: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Ra&ise<Tab>'             .g:slimv_leader.'I',  '',  '',              ':<C-U>call PareditRaise()<CR>' )
line 3389: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Left<Tab>'                         .'<',  '',  '',              ':<C-U>call PareditMoveLeft()<CR>' )
line 3390: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Right<Tab>'                        .'>',  '',  '',              ':<C-U>call PareditMoveRight()<CR>' )
line 3391: else
line 3392: call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Wrap<Tab>'              .g:slimv_leader.'W',  '',  '',              ':<C-U>call PareditWrap("(",")")<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Paredit-&Wrap<Tab>,W', '', '', ':<C-U>call PareditWrap("(",")")<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.Paredit-&Wrap<Tab>,W :<C-U>call PareditWrap("(",")")<CR>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3393: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Spli&ce<Tab>'            .g:slimv_leader.'S',  '',  '',              ':<C-U>call PareditSplice()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Paredit-Spli&ce<Tab>,S', '', '', ':<C-U>call PareditSplice()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.Paredit-Spli&ce<Tab>,S :<C-U>call PareditSplice()<CR>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3394: call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Split<Tab>'             .g:slimv_leader.'O',  '',  '',              ':<C-U>call PareditSplit()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Paredit-&Split<Tab>,O', '', '', ':<C-U>call PareditSplit()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.Paredit-&Split<Tab>,O :<C-U>call PareditSplit()<CR>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3395: call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Join<Tab>'              .g:slimv_leader.'J',  '',  '',              ':<C-U>call PareditJoin()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Paredit-&Join<Tab>,J', '', '', ':<C-U>call PareditJoin()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.Paredit-&Join<Tab>,J :<C-U>call PareditJoin()<CR>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3396: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Ra&ise<Tab>'             .g:slimv_leader.'I',  '',  '',              ':<C-U>call PareditRaise()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Paredit-Ra&ise<Tab>,I', '', '', ':<C-U>call PareditRaise()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.Paredit-Ra&ise<Tab>,I :<C-U>call PareditRaise()<CR>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3397: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Left<Tab>'          .g:slimv_leader.'<',  '',  '',              ':<C-U>call PareditMoveLeft()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Paredit-Move&Left<Tab>,<', '', '', ':<C-U>call PareditMoveLeft()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.Paredit-Move&Left<Tab>,< :<C-U>call PareditMoveLeft()<CR>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3398: call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Right<Tab>'         .g:slimv_leader.'>',  '',  '',              ':<C-U>call PareditMoveRight()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.Edi&t.Paredit-Move&Right<Tab>,>', '', '', ':<C-U>call PareditMoveRight()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.Edi&t.Paredit-Move&Right<Tab>,> :<C-U>call PareditMoveRight()<CR>
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3399: endif "g:paredit_shortmaps
line 3400: endif "g:paredit_loaded
line 3401: 
line 3402: " Evaluation commands
line 3403: call s:MenuMap( 'Slim&v.&Evaluation.Eval-&Defun',               g:slimv_leader.'d',  g:slimv_leader.'ed',  ':<C-U>call SlimvEvalDefun()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Evaluation.Eval-&Defun', ',d', ',ed', ':<C-U>call SlimvEvalDefun()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,d :<C-U>call SlimvEvalDefun()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Evaluation.Eval-&Defun<Tab>,d :<C-U>call SlimvEvalDefun()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3404: call s:MenuMap( 'Slim&v.&Evaluation.Eval-Current-&Exp',         g:slimv_leader.'e',  g:slimv_leader.'ee',  ':<C-U>call SlimvEvalExp()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Evaluation.Eval-Current-&Exp', ',e', ',ee', ':<C-U>call SlimvEvalExp()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,e :<C-U>call SlimvEvalExp()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Evaluation.Eval-Current-&Exp<Tab>,e :<C-U>call SlimvEvalExp()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3405: call s:MenuMap( 'Slim&v.&Evaluation.Eval-&Region',              g:slimv_leader.'r',  g:slimv_leader.'er',  ':call SlimvEvalRegion()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Evaluation.Eval-&Region', ',r', ',er', ':call SlimvEvalRegion()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,r :call SlimvEvalRegion()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Evaluation.Eval-&Region<Tab>,r :call SlimvEvalRegion()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3406: call s:MenuMap( 'Slim&v.&Evaluation.Eval-&Buffer',              g:slimv_leader.'b',  g:slimv_leader.'eb',  ':<C-U>call SlimvEvalBuffer()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Evaluation.Eval-&Buffer', ',b', ',eb', ':<C-U>call SlimvEvalBuffer()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,b :<C-U>call SlimvEvalBuffer()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Evaluation.Eval-&Buffer<Tab>,b :<C-U>call SlimvEvalBuffer()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3407: call s:MenuMap( 'Slim&v.&Evaluation.Interacti&ve-Eval\.\.\.',   g:slimv_leader.'v',  g:slimv_leader.'ei',  ':call SlimvInteractiveEval()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Evaluation.Interacti&ve-Eval\.\.\.', ',v', ',ei', ':call SlimvInteractiveEval()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,v :call SlimvInteractiveEval()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Evaluation.Interacti&ve-Eval\.\.\.<Tab>,v :call SlimvInteractiveEval()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3408: call s:MenuMap( 'Slim&v.&Evaluation.&Undefine-Function',        g:slimv_leader.'u',  g:slimv_leader.'eu',  ':call SlimvUndefineFunction()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Evaluation.&Undefine-Function', ',u', ',eu', ':call SlimvUndefineFunction()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,u :call SlimvUndefineFunction()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Evaluation.&Undefine-Function<Tab>,u :call SlimvUndefineFunction()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3409: 
line 3410: " Debug commands
line 3411: call s:MenuMap( 'Slim&v.De&bugging.Macroexpand-&1',             g:slimv_leader.'1',  g:slimv_leader.'m1',  ':<C-U>call SlimvMacroexpand()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.Macroexpand-&1', ',1', ',m1', ':<C-U>call SlimvMacroexpand()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,1 :<C-U>call SlimvMacroexpand()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.Macroexpand-&1<Tab>,1 :<C-U>call SlimvMacroexpand()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3412: call s:MenuMap( 'Slim&v.De&bugging.&Macroexpand-All',           g:slimv_leader.'m',  g:slimv_leader.'ma',  ':<C-U>call SlimvMacroexpandAll()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Macroexpand-All', ',m', ',ma', ':<C-U>call SlimvMacroexpandAll()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,m :<C-U>call SlimvMacroexpandAll()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Macroexpand-All<Tab>,m :<C-U>call SlimvMacroexpandAll()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3413: call s:MenuMap( 'Slim&v.De&bugging.Toggle-&Trace\.\.\.',        g:slimv_leader.'t',  g:slimv_leader.'dt',  ':call SlimvTrace()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.Toggle-&Trace\.\.\.', ',t', ',dt', ':call SlimvTrace()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,t :call SlimvTrace()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.Toggle-&Trace\.\.\.<Tab>,t :call SlimvTrace()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3414: call s:MenuMap( 'Slim&v.De&bugging.U&ntrace-All',               g:slimv_leader.'T',  g:slimv_leader.'du',  ':call SlimvUntrace()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.U&ntrace-All', ',T', ',du', ':call SlimvUntrace()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,T :call SlimvUntrace()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.U&ntrace-All<Tab>,T :call SlimvUntrace()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3415: call s:MenuMap( 'Slim&v.De&bugging.Set-&Breakpoint',            g:slimv_leader.'B',  g:slimv_leader.'db',  ':call SlimvBreak()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.Set-&Breakpoint', ',B', ',db', ':call SlimvBreak()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,B :call SlimvBreak()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.Set-&Breakpoint<Tab>,B :call SlimvBreak()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3416: call s:MenuMap( 'Slim&v.De&bugging.Break-on-&Exception',        g:slimv_leader.'E',  g:slimv_leader.'de',  ':call SlimvBreakOnException()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.Break-on-&Exception', ',E', ',de', ':call SlimvBreakOnException()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,E :call SlimvBreakOnException()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.Break-on-&Exception<Tab>,E :call SlimvBreakOnException()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3417: call s:MenuMap( 'Slim&v.De&bugging.Disassemb&le\.\.\.',         g:slimv_leader.'l',  g:slimv_leader.'dd',  ':call SlimvDisassemble()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.Disassemb&le\.\.\.', ',l', ',dd', ':call SlimvDisassemble()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,l :call SlimvDisassemble()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.Disassemb&le\.\.\.<Tab>,l :call SlimvDisassemble()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3418: call s:MenuMap( 'Slim&v.De&bugging.&Inspect\.\.\.',             g:slimv_leader.'i',  g:slimv_leader.'di',  ':call SlimvInspect()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Inspect\.\.\.', ',i', ',di', ':call SlimvInspect()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,i :call SlimvInspect()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Inspect\.\.\.<Tab>,i :call SlimvInspect()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3419: call s:MenuMap( 'Slim&v.De&bugging.-SldbSep-',                  '',                  '',                   ':' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.-SldbSep-', '', '', ':')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.De&bugging.-SldbSep- :
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3420: call s:MenuMap( 'Slim&v.De&bugging.&Abort',                     g:slimv_leader.'a',  g:slimv_leader.'da',  ':call SlimvDebugAbort()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Abort', ',a', ',da', ':call SlimvDebugAbort()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,a :call SlimvDebugAbort()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Abort<Tab>,a :call SlimvDebugAbort()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3421: call s:MenuMap( 'Slim&v.De&bugging.&Quit-to-Toplevel',          g:slimv_leader.'q',  g:slimv_leader.'dq',  ':call SlimvDebugQuit()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Quit-to-Toplevel', ',q', ',dq', ':call SlimvDebugQuit()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,q :call SlimvDebugQuit()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Quit-to-Toplevel<Tab>,q :call SlimvDebugQuit()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3422: call s:MenuMap( 'Slim&v.De&bugging.&Continue',                  g:slimv_leader.'n',  g:slimv_leader.'dc',  ':call SlimvDebugContinue()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Continue', ',n', ',dc', ':call SlimvDebugContinue()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,n :call SlimvDebugContinue()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Continue<Tab>,n :call SlimvDebugContinue()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3423: call s:MenuMap( 'Slim&v.De&bugging.&Restart-Frame',             g:slimv_leader.'N',  g:slimv_leader.'dr',  ':call SlimvDebugRestartFrame()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Restart-Frame', ',N', ',dr', ':call SlimvDebugRestartFrame()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,N :call SlimvDebugRestartFrame()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Restart-Frame<Tab>,N :call SlimvDebugRestartFrame()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3424: call s:MenuMap( 'Slim&v.De&bugging.-ThreadSep-',                '',                  '',                   ':' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.-ThreadSep-', '', '', ':')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.De&bugging.-ThreadSep- :
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3425: call s:MenuMap( 'Slim&v.De&bugging.List-T&hreads',              g:slimv_leader.'H',  g:slimv_leader.'dl',  ':call SlimvListThreads()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.List-T&hreads', ',H', ',dl', ':call SlimvListThreads()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,H :call SlimvListThreads()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.List-T&hreads<Tab>,H :call SlimvListThreads()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3426: call s:MenuMap( 'Slim&v.De&bugging.&Kill-Thread\.\.\.',         g:slimv_leader.'K',  g:slimv_leader.'dk',  ':call SlimvKillThread()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Kill-Thread\.\.\.', ',K', ',dk', ':call SlimvKillThread()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,K :call SlimvKillThread()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Kill-Thread\.\.\.<Tab>,K :call SlimvKillThread()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3427: call s:MenuMap( 'Slim&v.De&bugging.&Debug-Thread\.\.\.',        g:slimv_leader.'G',  g:slimv_leader.'dT',  ':call SlimvDebugThread()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.De&bugging.&Debug-Thread\.\.\.', ',G', ',dT', ':call SlimvDebugThread()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,G :call SlimvDebugThread()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.De&bugging.&Debug-Thread\.\.\.<Tab>,G :call SlimvDebugThread()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3428: 
line 3429: " Compile commands
line 3430: call s:MenuMap( 'Slim&v.&Compilation.Compile-&Defun',           g:slimv_leader.'D',  g:slimv_leader.'cd',  ':<C-U>call SlimvCompileDefun()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Compilation.Compile-&Defun', ',D', ',cd', ':<C-U>call SlimvCompileDefun()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,D :<C-U>call SlimvCompileDefun()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Compilation.Compile-&Defun<Tab>,D :<C-U>call SlimvCompileDefun()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3431: call s:MenuMap( 'Slim&v.&Compilation.Compile-&Load-File',       g:slimv_leader.'L',  g:slimv_leader.'cl',  ':<C-U>call SlimvCompileLoadFile()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Compilation.Compile-&Load-File', ',L', ',cl', ':<C-U>call SlimvCompileLoadFile()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,L :<C-U>call SlimvCompileLoadFile()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Compilation.Compile-&Load-File<Tab>,L :<C-U>call SlimvCompileLoadFile()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3432: call s:MenuMap( 'Slim&v.&Compilation.Compile-&File',            g:slimv_leader.'F',  g:slimv_leader.'cf',  ':<C-U>call SlimvCompileFile()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Compilation.Compile-&File', ',F', ',cf', ':<C-U>call SlimvCompileFile()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,F :<C-U>call SlimvCompileFile()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Compilation.Compile-&File<Tab>,F :<C-U>call SlimvCompileFile()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3433: call s:MenuMap( 'Slim&v.&Compilation.Compile-&Region',          g:slimv_leader.'R',  g:slimv_leader.'cr',  ':call SlimvCompileRegion()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Compilation.Compile-&Region', ',R', ',cr', ':call SlimvCompileRegion()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,R :call SlimvCompileRegion()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Compilation.Compile-&Region<Tab>,R :call SlimvCompileRegion()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3434: 
line 3435: " Xref commands
line 3436: call s:MenuMap( 'Slim&v.&Xref.Who-&Calls',                      g:slimv_leader.'xc', g:slimv_leader.'xc',  ':call SlimvXrefCalls()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.Who-&Calls', ',xc', ',xc', ':call SlimvXrefCalls()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xc :call SlimvXrefCalls()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.Who-&Calls<Tab>,xc :call SlimvXrefCalls()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3437: call s:MenuMap( 'Slim&v.&Xref.Who-&References',                 g:slimv_leader.'xr', g:slimv_leader.'xr',  ':call SlimvXrefReferences()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.Who-&References', ',xr', ',xr', ':call SlimvXrefReferences()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xr :call SlimvXrefReferences()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.Who-&References<Tab>,xr :call SlimvXrefReferences()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3438: call s:MenuMap( 'Slim&v.&Xref.Who-&Sets',                       g:slimv_leader.'xs', g:slimv_leader.'xs',  ':call SlimvXrefSets()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.Who-&Sets', ',xs', ',xs', ':call SlimvXrefSets()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xs :call SlimvXrefSets()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.Who-&Sets<Tab>,xs :call SlimvXrefSets()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3439: call s:MenuMap( 'Slim&v.&Xref.Who-&Binds',                      g:slimv_leader.'xb', g:slimv_leader.'xb',  ':call SlimvXrefBinds()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.Who-&Binds', ',xb', ',xb', ':call SlimvXrefBinds()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xb :call SlimvXrefBinds()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.Who-&Binds<Tab>,xb :call SlimvXrefBinds()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3440: call s:MenuMap( 'Slim&v.&Xref.Who-&Macroexpands',               g:slimv_leader.'xm', g:slimv_leader.'xm',  ':call SlimvXrefMacroexpands()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.Who-&Macroexpands', ',xm', ',xm', ':call SlimvXrefMacroexpands()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xm :call SlimvXrefMacroexpands()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.Who-&Macroexpands<Tab>,xm :call SlimvXrefMacroexpands()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3441: call s:MenuMap( 'Slim&v.&Xref.Who-S&pecializes',                g:slimv_leader.'xp', g:slimv_leader.'xp',  ':call SlimvXrefSpecializes()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.Who-S&pecializes', ',xp', ',xp', ':call SlimvXrefSpecializes()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xp :call SlimvXrefSpecializes()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.Who-S&pecializes<Tab>,xp :call SlimvXrefSpecializes()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3442: call s:MenuMap( 'Slim&v.&Xref.&List-Callers',                   g:slimv_leader.'xl', g:slimv_leader.'xl',  ':call SlimvXrefCallers()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.&List-Callers', ',xl', ',xl', ':call SlimvXrefCallers()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xl :call SlimvXrefCallers()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.&List-Callers<Tab>,xl :call SlimvXrefCallers()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3443: call s:MenuMap( 'Slim&v.&Xref.List-Call&ees',                   g:slimv_leader.'xe', g:slimv_leader.'xe',  ':call SlimvXrefCallees()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Xref.List-Call&ees', ',xe', ',xe', ':call SlimvXrefCallees()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,xe :call SlimvXrefCallees()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Xref.List-Call&ees<Tab>,xe :call SlimvXrefCallees()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3444: 
line 3445: " Profile commands
line 3446: call s:MenuMap( 'Slim&v.&Profiling.Toggle-&Profile\.\.\.',      g:slimv_leader.'p',  g:slimv_leader.'pp',  ':<C-U>call SlimvProfile()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Profiling.Toggle-&Profile\.\.\.', ',p', ',pp', ':<C-U>call SlimvProfile()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,p :<C-U>call SlimvProfile()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Profiling.Toggle-&Profile\.\.\.<Tab>,p :<C-U>call SlimvProfile()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3447: call s:MenuMap( 'Slim&v.&Profiling.Profile-&By-Substring\.\.\.',g:slimv_leader.'P',  g:slimv_leader.'pb',  ':<C-U>call SlimvProfileSubstring()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Profiling.Profile-&By-Substring\.\.\.', ',P', ',pb', ':<C-U>call SlimvProfileSubstring()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,P :<C-U>call SlimvProfileSubstring()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Profiling.Profile-&By-Substring\.\.\.<Tab>,P :<C-U>call SlimvProfileSubstring()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3448: call s:MenuMap( 'Slim&v.&Profiling.Unprofile-&All',             g:slimv_leader.'U',  g:slimv_leader.'pa',  ':<C-U>call SlimvUnprofileAll()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Profiling.Unprofile-&All', ',U', ',pa', ':<C-U>call SlimvUnprofileAll()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,U :<C-U>call SlimvUnprofileAll()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Profiling.Unprofile-&All<Tab>,U :<C-U>call SlimvUnprofileAll()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3449: call s:MenuMap( 'Slim&v.&Profiling.&Show-Profiled',             g:slimv_leader.'?',  g:slimv_leader.'ps',  ':<C-U>call SlimvShowProfiled()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Profiling.&Show-Profiled', ',?', ',ps', ':<C-U>call SlimvShowProfiled()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,? :<C-U>call SlimvShowProfiled()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Profiling.&Show-Profiled<Tab>,? :<C-U>call SlimvShowProfiled()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3450: call s:MenuMap( 'Slim&v.&Profiling.-ProfilingSep-',             '',                  '',                   ':' )
calling function <SNR>50_MenuMap('Slim&v.&Profiling.-ProfilingSep-', '', '', ':')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 15: amenu Slim&v.&Profiling.-ProfilingSep- :
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3451: call s:MenuMap( 'Slim&v.&Profiling.Profile-Rep&ort',            g:slimv_leader.'o',  g:slimv_leader.'pr',  ':<C-U>call SlimvProfileReport()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Profiling.Profile-Rep&ort', ',o', ',pr', ':<C-U>call SlimvProfileReport()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,o :<C-U>call SlimvProfileReport()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Profiling.Profile-Rep&ort<Tab>,o :<C-U>call SlimvProfileReport()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3452: call s:MenuMap( 'Slim&v.&Profiling.Profile-&Reset',             g:slimv_leader.'X',  g:slimv_leader.'px',  ':<C-U>call SlimvProfileReset()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Profiling.Profile-&Reset', ',X', ',px', ':<C-U>call SlimvProfileReset()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,X :<C-U>call SlimvProfileReset()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Profiling.Profile-&Reset<Tab>,X :<C-U>call SlimvProfileReset()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3453: 
line 3454: " Documentation commands
line 3455: call s:MenuMap( 'Slim&v.&Documentation.Describe-&Symbol',       g:slimv_leader.'s',  g:slimv_leader.'ds',  ':call SlimvDescribeSymbol()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Documentation.Describe-&Symbol', ',s', ',ds', ':call SlimvDescribeSymbol()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,s :call SlimvDescribeSymbol()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Documentation.Describe-&Symbol<Tab>,s :call SlimvDescribeSymbol()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3456: call s:MenuMap( 'Slim&v.&Documentation.&Apropos',               g:slimv_leader.'A',  g:slimv_leader.'dp',  ':call SlimvApropos()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Documentation.&Apropos', ',A', ',dp', ':call SlimvApropos()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,A :call SlimvApropos()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Documentation.&Apropos<Tab>,A :call SlimvApropos()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3457: call s:MenuMap( 'Slim&v.&Documentation.&Hyperspec',             g:slimv_leader.'h',  g:slimv_leader.'dh',  ':call SlimvHyperspec()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Documentation.&Hyperspec', ',h', ',dh', ':call SlimvHyperspec()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,h :call SlimvHyperspec()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Documentation.&Hyperspec<Tab>,h :call SlimvHyperspec()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3458: call s:MenuMap( 'Slim&v.&Documentation.Generate-&Tags',         g:slimv_leader.']',  g:slimv_leader.'dg',  ':call SlimvGenerateTags()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Documentation.Generate-&Tags', ',]', ',dg', ':call SlimvGenerateTags()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,] :call SlimvGenerateTags()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Documentation.Generate-&Tags<Tab>,] :call SlimvGenerateTags()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3459: 
line 3460: " REPL commands
line 3461: call s:MenuMap( 'Slim&v.&Repl.&Connect-Server',                 g:slimv_leader.'c',  g:slimv_leader.'rc',  ':call SlimvConnectServer()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Repl.&Connect-Server', ',c', ',rc', ':call SlimvConnectServer()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,c :call SlimvConnectServer()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Repl.&Connect-Server<Tab>,c :call SlimvConnectServer()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3462: call s:MenuMap( '',                                             g:slimv_leader.'g',  g:slimv_leader.'rp',  ':call SlimvSetPackage()<CR>' )
calling function <SNR>50_MenuMap('', ',g', ',rp', ':call SlimvSetPackage()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,g :call SlimvSetPackage()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3463: call s:MenuMap( 'Slim&v.&Repl.Interrup&t-Lisp-Process',         g:slimv_leader.'y',  g:slimv_leader.'ri',  ':call SlimvInterrupt()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Repl.Interrup&t-Lisp-Process', ',y', ',ri', ':call SlimvInterrupt()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,y :call SlimvInterrupt()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Repl.Interrup&t-Lisp-Process<Tab>,y :call SlimvInterrupt()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3464: call s:MenuMap( 'Slim&v.&Repl.Clear-&REPL',                     g:slimv_leader.'-',  g:slimv_leader.'-',   ':call SlimvClearReplBuffer()<CR>' )
calling function <SNR>50_MenuMap('Slim&v.&Repl.Clear-&REPL', ',-', ',-', ':call SlimvClearReplBuffer()<CR>')

line 1:     if g:slimv_keybindings == 1
line 2:         " Short (one-key) keybinding set
line 3:         let shortcut = a:shortcut1
line 4:     elseif g:slimv_keybindings == 2
line 5:         " Easy to remember (two-key) keybinding set
line 6:         let shortcut = a:shortcut2
line 7:     endif
line 8: 
line 9:     if shortcut != ''
line 10:         execute "noremap <silent> " . shortcut . " " . a:command
line 10: noremap <silent> ,- :call SlimvClearReplBuffer()<CR>
line 11:         if a:name != '' && g:slimv_menu == 1
line 12:             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
line 12: amenu Slim&v.&Repl.Clear-&REPL<Tab>,- :call SlimvClearReplBuffer()<CR>
line 13:         endif
line 14:     elseif a:name != '' && g:slimv_menu == 1
line 15:         silent execute "amenu " . a:name . " " . a:command
line 16:     endif
function <SNR>50_MenuMap returning #0

continuing in /Users/leostera/.vim/ftplugin/slimv.vim

line 3465: 
line 3466: 
line 3467: " =====================================================================
line 3468: "  Slimv menu
line 3469: " =====================================================================
line 3470: 
line 3471: if g:slimv_menu == 1
line 3472:     " Works only if 'wildcharm' is <Tab>
line 3473:     if &wildcharm == 0
line 3474:         set wildcharm=<Tab>
line 3475:     endif
line 3476:     if &wildcharm != 0
line 3477:         execute ':map ' . g:slimv_leader.', :emenu Slimv.' . nr2char( &wildcharm )
line 3477: :map ,, :emenu Slimv.^I
line 3478:     endif
line 3479: endif
line 3480: 
line 3481: " Add REPL menu. This menu exist only for the REPL buffer.
line 3482: function! SlimvAddReplMenu()
line 3496: 
line 3497: " =====================================================================
line 3498: "  Slimv commands
line 3499: " =====================================================================
line 3500: 
line 3501: command! -complete=customlist,SlimvCommandComplete -nargs=* Lisp call SlimvEval([<q-args>])
line 3502: command! -complete=customlist,SlimvCommandComplete -nargs=* Eval call SlimvEval([<q-args>])
line 3503: 
line 3504: " Switch on syntax highlighting
line 3505: if !exists("g:syntax_on")
line 3506:     syntax on
line 3507: endif
line 3508: 
finished sourcing /Users/leostera/.vim/ftplugin/slimv.vim
continuing in /Users/leostera/.vim/ftplugin/lisp/slimv-lisp.vim
line 188: 
line 189: endif "!exists( 'g:slimv_lisp_loaded' )
line 190: " ---------- End of part loaded once ----------
line 191: 
line 192: runtime ftplugin/**/lisp.vim
Searching for "ftplugin/**/lisp.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leo
Searching for "/Users/leostera/.vim/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/ftplugin/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/ftplugin/**/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin/**/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/**/lisp.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin)
fchdir() to previous dir
line 192: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/lisp.vim"
line 1: " Vim filetype plugin
line 2: " Language:      Lisp
line 3: " Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
line 4: " URL:^I^I http://sites.google.com/site/khorser/opensource/vim
line 5: " Original author:    Dorai Sitaram <ds26@gte.com>
line 6: " Original URL:^I^I http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
line 7: " Last Change:   Oct 23, 2013
line 8: 
line 9: " Only do this when not done yet for this buffer
line 10: if exists("b:did_ftplugin")
line 11:   finish
line 12: endif
line 13: 
line 14: " Don't load another plugin for this buffer
line 15: let b:did_ftplugin = 1
line 16: 
line 17: setl comments=:;
line 18: setl define=^\\s*(def\\k*
line 19: setl formatoptions-=t
line 20: setl iskeyword+=+,-,*,/,%,<,=,>,:,$,?,!,@-@,94
line 21: setl lisp
line 22: setl commentstring=;%s
line 23: 
line 24: setl comments^=:;;;,:;;,sr:#\|,mb:\|,ex:\|#
line 25: 
line 26: let b:undo_ftplugin = "setlocal comments< define< formatoptions< iskeyword< lisp< commentstring<"
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/lisp.vim
continuing in /Users/leostera/.vim/ftplugin/lisp/slimv-lisp.vim
line 193: 
line 194: " Must be called for each lisp buffer
line 195: call SlimvInitBuffer()
calling function SlimvInitBuffer()

line 1:     " Map space to display function argument list in status line
line 2:     if SlimvGetFiletype() == 'r'
calling function SlimvInitBuffer..SlimvGetFiletype()

line 1:     if &ft != ''
line 2:         " Return Vim filetype if defined
line 3:         return &ft
function SlimvInitBuffer..SlimvGetFiletype returning 'lisp'

continuing in function SlimvInitBuffer

line 3:         inoremap <silent> <buffer> (          (<C-R>=SlimvArglist()<CR>
line 4:     else
line 5:         inoremap <silent> <buffer> <Space>    <Space><C-R>=SlimvArglist()<CR>
line 6:         inoremap <silent> <buffer> <CR>       <C-R>=pumvisible() ?  "\<lt>C-Y>" : SlimvHandleEnter()<CR><C-R>=SlimvArglistOnEnter()<CR>
line 7:     endif
line 8:     "noremap  <silent> <buffer> <C-C>      :call SlimvInterrupt()<CR>
line 9:     augroup SlimvInsertLeave
line 10:         au!
line 11:         au InsertLeave * :let &showmode=s:save_showmode
line 12:     augroup END
line 13:     inoremap <silent> <buffer> <C-X>0     <C-O>:call SlimvCloseForm()<CR>
line 14:     inoremap <silent> <buffer> <Tab>      <C-R>=SlimvHandleTab()<CR>
line 15:     inoremap <silent> <buffer> <S-Tab>    <C-R>=pumvisible() ? "\<lt>C-P>" : "\<lt>S-Tab>"<CR>
line 16: 
line 17:     " Setup balloonexp to display symbol description
line 18:     if g:slimv_balloon && has( 'balloon_eval' )
line 19:         "setlocal balloondelay=100
line 20:         setlocal ballooneval
line 21:         setlocal balloonexpr=SlimvDescribe(v:beval_text)
line 22:     endif
line 23:     " This is needed for safe switching of modified buffers
line 24:     set hidden
line 25:     call s:MakeWindowId()
calling function SlimvInitBuffer..<SNR>50_MakeWindowId()

line 1:     if g:slimv_repl_split && !exists('w:id')
line 2:         let s:win_id = s:win_id + 1
line 3:         let w:id = s:win_id
line 4:     endif
function SlimvInitBuffer..<SNR>50_MakeWindowId returning #0

continuing in function SlimvInitBuffer

function SlimvInitBuffer returning #0

continuing in /Users/leostera/.vim/ftplugin/lisp/slimv-lisp.vim

line 196: 
line 197: " Don't load another plugin for this buffer
line 198: let b:did_ftplugin = 1
line 199: 
finished sourcing /Users/leostera/.vim/ftplugin/lisp/slimv-lisp.vim
continuing in function <SNR>10_LoadFTPlugin
Searching for "/Users/leostera/.vim/bundle/vundle/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/ftplugin/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin/lisp_*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/lisp.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin)
fchdir() to previous dir
line 17: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/lisp.vim"
line 1: " Vim filetype plugin
line 2: " Language:      Lisp
line 3: " Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
line 4: " URL:^I^I http://sites.google.com/site/khorser/opensource/vim
line 5: " Original author:    Dorai Sitaram <ds26@gte.com>
line 6: " Original URL:^I^I http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
line 7: " Last Change:   Oct 23, 2013
line 8: 
line 9: " Only do this when not done yet for this buffer
line 10: if exists("b:did_ftplugin")
line 11:   finish
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/lisp.vim
continuing in function <SNR>10_LoadFTPlugin
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/lisp_*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/ftplugin/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/ftplugin/lisp_*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/ftplugin/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/ftplugin/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/ftplugin/lisp_*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/ftplugin/lisp/*.vim"
line 18:       endfor
line 16:       for name in split(s, '\.')
line 17: ^Iexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 18:       endfor
line 19:     endif
function <SNR>10_LoadFTPlugin returning #0

continuing in FileType Auto commands for "*"

Executing FileType Auto commands for "*"
autocommand call s:LoadIndent()

line 0: call s:LoadIndent()
calling function <SNR>11_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14: ^Iexe 'runtime! indent/' . name . '.vim'
line 14: runtime! indent/lisp.vim
Searching for "indent/lisp.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leostera
Searching for "/Users/leostera/.vim/indent/lisp.vim"
chdir(/Users/leostera/.vim/indent)
fchdir() to previous dir
line 14: sourcing "/Users/leostera/.vim/indent/lisp.vim"
line 1: " lisp.vim:
line 2: "               Lisp indent plugin for Slimv
line 3: " Version:      0.9.5
line 4: " Last Change:  21 Feb 2012
line 5: " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
line 6: " License:      This file is placed in the public domain.
line 7: "               No warranty, express or implied.
line 8: "               *** ***   Use At-Your-Own-Risk!   *** ***
line 9: "
line 10: " =====================================================================
line 11: "
line 12: "  Load Once:
line 13: if exists("b:did_indent")
line 14:    finish
line 15: endif
line 16: 
line 17: " Handle cases when lisp dialects explicitly use the lisp indent plugins
line 18: if &ft == "clojure" && exists("g:slimv_disable_clojure")
line 19:     finish
line 20: endif
line 21: 
line 22: if &ft == "scheme" && exists("g:slimv_disable_scheme")
line 23:     finish
line 24: endif 
line 25: 
line 26: setlocal nolisp
line 27: setlocal autoindent
line 28: setlocal expandtab
line 29: setlocal indentexpr=SlimvIndent(v:lnum)
line 30: 
finished sourcing /Users/leostera/.vim/indent/lisp.vim
continuing in function <SNR>11_LoadIndent
Searching for "/Users/leostera/.vim/bundle/vundle/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/indent/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/indent/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/indent/lisp.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/indent)
fchdir() to previous dir
line 14: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/indent/lisp.vim"
line 1: " Vim indent file
line 2: " Language:^ILisp
line 3: " Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
line 4: " URL:^I^I http://sites.google.com/site/khorser/opensource/vim
line 5: " Last Change:^I2012 Jan 10
line 6: 
line 7: " Only load this indent file when no other was loaded.
line 8: if exists("b:did_indent")
line 9:    finish
line 10: endif
line 11: let b:did_indent = 1
line 12: 
line 13: setlocal ai nosi
line 14: 
line 15: let b:undo_indent = "setl ai< si<"
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/indent/lisp.vim
continuing in function <SNR>11_LoadIndent
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/indent/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/indent/lisp.vim"
line 15:       endfor
line 13:       for name in split(s, '\.')
line 14: ^Iexe 'runtime! indent/' . name . '.vim'
line 15:       endfor
line 16:     endif
function <SNR>11_LoadIndent returning #0

continuing in FileType Auto commands for "*"

Executing FileType Auto commands for "*"
autocommand exe "set syntax=" . expand("<amatch>")

line 0: exe "set syntax=" . expand("<amatch>")
line 0: set syntax=lisp
Executing Syntax Auto commands for "*"
autocommand call s:SynSet()

line 0: call s:SynSet()
calling function <SNR>13_SynSet()

line 1:   " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
line 2:   syn clear
line 3:   if exists("b:current_syntax")
line 4:     unlet b:current_syntax
line 5:   endif
line 6: 
line 7:   let s = expand("<amatch>")
line 8:   if s == "ON"
line 9:     " :set syntax=ON
line 10:     if &filetype == ""
line 11:       echohl ErrorMsg
line 12:       echo "filetype unknown"
line 13:       echohl None
line 14:     endif
line 15:     let s = &filetype
line 16:   elseif s == "OFF"
line 17:     let s = ""
line 18:   endif
line 19: 
line 20:   if s != ""
line 21:     " Load the syntax file(s).  When there are several, separated by dots,
line 22:     " load each in sequence.
line 23:     for name in split(s, '\.')
line 24:       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 24: runtime! syntax/lisp.vim syntax/lisp/*.vim
Searching for "syntax/lisp.vim syntax/lisp/*.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/aft
Searching for "/Users/leostera/.vim/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/syntax/lisp/*.vim"
chdir(/Users/leostera/.vim/syntax/lisp)
fchdir() to previous dir
line 24: sourcing "/Users/leostera/.vim/syntax/lisp/slimv-syntax-lisp.vim"
line 1: " slimv-syntax-lisp.vim:
line 2: "               Lisp syntax plugin for Slimv
line 3: " Version:      0.9.11
line 4: " Last Change:  22 Apr 2013
line 5: " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
line 6: " License:      This file is placed in the public domain.
line 7: "               No warranty, express or implied.
line 8: "               *** ***   Use At-Your-Own-Risk!   *** ***
line 9: "
line 10: " =====================================================================
line 11: "
line 12: "  Load Once:
line 13: if exists("b:current_syntax") || exists("g:slimv_disable_lisp")
line 14:   finish
line 15: endif
line 16: 
line 17: runtime syntax/**/lisp.vim
Searching for "syntax/**/lisp.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/leost
Searching for "/Users/leostera/.vim/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/syntax/**/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/syntax/**/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/syntax/**/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/**/lisp.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 17: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/lisp.vim"
line 1: " Vim syntax file
line 2: " Language:    Lisp
line 3: " Maintainer:  Dr. Charles E. Campbell, Jr. <NdrOchipS@PcampbellAfamily.Mbiz>
line 4: " Last Change: Nov 16, 2010
line 5: " Version:     22
line 6: " URL:^I       http://mysite.verizon.net/astronaut/vim/index.html#vimlinks_syntax
line 7: "
line 8: "  Thanks to F Xavier Noria for a list of 978 Common Lisp symbols
line 9: "  taken from the HyperSpec
line 10: "  Clisp additions courtesy of http://clisp.cvs.sourceforge.net/*checkout*/clisp/clisp/emacs/lisp.vim
line 11: 
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: " For vim-version 5.x: Clear all syntax items
line 15: " For vim-version 6.x: Quit when a syntax file was already loaded
line 16: if version < 600
line 17:   syntax clear
line 18: elseif exists("b:current_syntax")
line 19:   finish
line 20: endif
line 21: 
line 22: if version >= 600
line 23:  setlocal iskeyword=38,42,43,45,47-58,60-62,64-90,97-122,_
line 24: else
line 25:  set iskeyword=38,42,43,45,47-58,60-62,64-90,97-122,_
line 26: endif
line 27: 
line 28: if exists("g:lispsyntax_ignorecase") || exists("g:lispsyntax_clisp")
line 29:  set ignorecase
line 30: endif
line 31: 
line 32: " ---------------------------------------------------------------------
line 33: " Clusters: {{{1
line 34: syn cluster^I^I^IlispAtomCluster^I^Icontains=lispAtomBarSymbol,lispAtomList,lispAtomNmbr0,lispComment,lispDecl,lispFunc,lispLeadWhite
line 35: syn cluster^I^I^IlispBaseListCluster^Icontains=lispAtom,lispAtomBarSymbol,lispAtomMark,lispBQList,lispBarSymbol,lispComment,lispConcat,lispDecl,lispFunc,lispKey,lispList,lispNumber,lispEscapeSpecial,lispSymbol,lispVar,lispLeadWhite
line 36: if exists("g:lisp_instring")
line 37:  syn cluster^I^I^IlispListCluster^I^Icontains=@lispBaseListCluster,lispString,lispInString,lispInStringString
line 38: else
line 39:  syn cluster^I^I^IlispListCluster^I^Icontains=@lispBaseListCluster,lispString
line 40: endif
line 41: 
line 42: syn case ignore
line 43: 
line 44: " ---------------------------------------------------------------------
line 45: " Lists: {{{1
line 46: syn match^I^I^IlispSymbol^I^I^Icontained^I^I^I![^()'`,"; \t]\+!
line 47: syn match^I^I^IlispBarSymbol^I^I^Icontained^I^I^I!|..\{-}|!
line 48: if exists("g:lisp_rainbow") && g:lisp_rainbow != 0
line 49:  syn region lispParen0           matchgroup=hlLevel0 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen1
line 50:  syn region lispParen1 contained matchgroup=hlLevel1 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen2
line 51:  syn region lispParen2 contained matchgroup=hlLevel2 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen3
line 52:  syn region lispParen3 contained matchgroup=hlLevel3 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen4
line 53:  syn region lispParen4 contained matchgroup=hlLevel4 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen5
line 54:  syn region lispParen5 contained matchgroup=hlLevel5 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen6
line 55:  syn region lispParen6 contained matchgroup=hlLevel6 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen7
line 56:  syn region lispParen7 contained matchgroup=hlLevel7 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen8
line 57:  syn region lispParen8 contained matchgroup=hlLevel8 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen9
line 58:  syn region lispParen9 contained matchgroup=hlLevel9 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen0
line 59: else
line 60:  syn region lispList^I^I^Imatchgroup=Delimiter start="("   skip="|.\{-}|"^I^I^Imatchgroup=Delimiter end=")"^Icontains=@lispListCluster
line 61:  syn region lispBQList^I^I^Imatchgroup=PreProc   start="`("  skip="|.\{-}|"^I^I^Imatchgroup=PreProc   end=")"^I^Icontains=@lispListCluster
line 62: endif
line 63: 
line 64: " ---------------------------------------------------------------------
line 65: " Atoms: {{{1
line 66: syn match lispAtomMark^I^I^I"'"
line 67: syn match lispAtom^I^I^I"'("me=e-1^I^I^Icontains=lispAtomMark^Inextgroup=lispAtomList
line 68: syn match lispAtom^I^I^I"'[^ \t()]\+"^I^I^Icontains=lispAtomMark
line 69: syn match lispAtomBarSymbol^I^I!'|..\{-}|!^I^I^Icontains=lispAtomMark
line 70: syn region lispAtom^I^I^Istart=+'"+^I^I^Iskip=+\\"+ end=+"+
line 71: syn region lispAtomList^I^I^Icontained^I^I^Imatchgroup=Special start="("^Iskip="|.\{-}|" matchgroup=Special end=")"^Icontains=@lispAtomCluster,lispString,lispEscapeSpecial
line 72: syn match lispAtomNmbr^I^I^Icontained^I^I^I"\<\d\+"
line 73: syn match lispLeadWhite^I^I^Icontained^I^I^I"^\s\+"
line 74: 
line 75: " ---------------------------------------------------------------------
line 76: " Standard Lisp Functions and Macros: {{{1
line 77: syn keyword lispFunc^I^I*^I^I^I^Ifind-method^I^I^I^I^Ipprint-indent
line 78: syn keyword lispFunc^I^I**^I^I^I^Ifind-package^I^I^I^I^Ipprint-linear
line 79: syn keyword lispFunc^I^I***^I^I^I^Ifind-restart^I^I^I^I^Ipprint-logical-block
line 80: syn keyword lispFunc^I^I+^I^I^I^Ifind-symbol^I^I^I^I^Ipprint-newline
line 81: syn keyword lispFunc^I^I++^I^I^I^Ifinish-output^I^I^I^I^Ipprint-pop
line 82: syn keyword lispFunc^I^I+++^I^I^I^Ifirst^I^I^I^I^I^Ipprint-tab
line 83: syn keyword lispFunc^I^I-^I^I^I^Ifixnum^I^I^I^I^I^Ipprint-tabular
line 84: syn keyword lispFunc^I^I/^I^I^I^Iflet^I^I^I^I^I^Iprin1
line 85: syn keyword lispFunc^I^I//^I^I^I^Ifloat^I^I^I^I^I^Iprin1-to-string
line 86: syn keyword lispFunc^I^I///^I^I^I^Ifloat-digits^I^I^I^I^Iprinc
line 87: syn keyword lispFunc^I^I/=^I^I^I^Ifloat-precision^I^I^I^I^Iprinc-to-string
line 88: syn keyword lispFunc^I^I1+^I^I^I^Ifloat-radix^I^I^I^I^Iprint
line 89: syn keyword lispFunc^I^I1-^I^I^I^Ifloat-sign^I^I^I^I^Iprint-not-readable
line 90: syn keyword lispFunc^I^I<^I^I^I^Ifloating-point-inexact^I^I^I^Iprint-not-readable-object
line 91: syn keyword lispFunc^I^I<=^I^I^I^Ifloating-point-invalid-operation print-object
line 92: syn keyword lispFunc^I^I=^I^I^I^Ifloating-point-overflow^I^I^I^Iprint-unreadable-object
line 93: syn keyword lispFunc^I^I>^I^I^I^Ifloating-point-underflow^I^I^Iprobe-file
line 94: syn keyword lispFunc^I^I>=^I^I^I^Ifloatp^I^I^I^I^I^Iproclaim
line 95: syn keyword lispFunc^I^Iabort^I^I^I^Ifloor^I^I^I^I^I^Iprog
line 96: syn keyword lispFunc^I^Iabs^I^I^I^Ifmakunbound^I^I^I^I^Iprog*
line 97: syn keyword lispFunc^I^Iaccess^I^I^I^Iforce-output^I^I^I^I^Iprog1
line 98: syn keyword lispFunc^I^Iacons^I^I^I^Iformat^I^I^I^I^I^Iprog2
line 99: syn keyword lispFunc^I^Iacos^I^I^I^Iformatter^I^I^I^I^Iprogn
line 100: syn keyword lispFunc^I^Iacosh^I^I^I^Ifourth^I^I^I^I^I^Iprogram-error
line 101: syn keyword lispFunc^I^Iadd-method^I^I^Ifresh-line^I^I^I^I^Iprogv
line 102: syn keyword lispFunc^I^Iadjoin^I^I^I^Ifround^I^I^I^I^I^Iprovide
line 103: syn keyword lispFunc^I^Iadjust-array^I^I^Iftruncate^I^I^I^I^Ipsetf
line 104: syn keyword lispFunc^I^Iadjustable-array-p^I^Iftype^I^I^I^I^I^Ipsetq
line 105: syn keyword lispFunc^I^Iallocate-instance^I^Ifuncall^I^I^I^I^I^Ipush
line 106: syn keyword lispFunc^I^Ialpha-char-p^I^I^Ifunction^I^I^I^I^Ipushnew
line 107: syn keyword lispFunc^I^Ialphanumericp^I^I^Ifunction-keywords^I^I^I^Iputprop
line 108: syn keyword lispFunc^I^Iand^I^I^I^Ifunction-lambda-expression^I^I^Iquote
line 109: syn keyword lispFunc^I^Iappend^I^I^I^Ifunctionp^I^I^I^I^Irandom
line 110: syn keyword lispFunc^I^Iapply^I^I^I^Igbitp^I^I^I^I^I^Irandom-state
line 111: syn keyword lispFunc^I^Iapplyhook^I^I^Igcd^I^I^I^I^I^Irandom-state-p
line 112: syn keyword lispFunc^I^Iapropos^I^I^I^Igeneric-function^I^I^I^Irassoc
line 113: syn keyword lispFunc^I^Iapropos-list^I^I^Igensym^I^I^I^I^I^Irassoc-if
line 114: syn keyword lispFunc^I^Iaref^I^I^I^Igentemp^I^I^I^I^I^Irassoc-if-not
line 115: syn keyword lispFunc^I^Iarithmetic-error^I^Iget^I^I^I^I^I^Iratio
line 116: syn keyword lispFunc^I^Iarithmetic-error-operands^Iget-decoded-time^I^I^I^Irational
line 117: syn keyword lispFunc^I^Iarithmetic-error-operation^Iget-dispatch-macro-character^I^I^Irationalize
line 118: syn keyword lispFunc^I^Iarray^I^I^I^Iget-internal-real-time^I^I^I^Irationalp
line 119: syn keyword lispFunc^I^Iarray-dimension^I^I^Iget-internal-run-time^I^I^I^Iread
line 120: syn keyword lispFunc^I^Iarray-dimension-limit^I^Iget-macro-character^I^I^I^Iread-byte
line 121: syn keyword lispFunc^I^Iarray-dimensions^I^Iget-output-stream-string^I^I^Iread-char
line 122: syn keyword lispFunc^I^Iarray-displacement^I^Iget-properties^I^I^I^I^Iread-char-no-hang
line 123: syn keyword lispFunc^I^Iarray-element-type^I^Iget-setf-expansion^I^I^I^Iread-delimited-list
line 124: syn keyword lispFunc^I^Iarray-has-fill-pointer-p^Iget-setf-method^I^I^I^I^Iread-eval-print
line 125: syn keyword lispFunc^I^Iarray-in-bounds-p^I^Iget-universal-time^I^I^I^Iread-from-string
line 126: syn keyword lispFunc^I^Iarray-rank^I^I^Igetf^I^I^I^I^I^Iread-line
line 127: syn keyword lispFunc^I^Iarray-rank-limit^I^Igethash^I^I^I^I^I^Iread-preserving-whitespace
line 128: syn keyword lispFunc^I^Iarray-row-major-index^I^Igo^I^I^I^I^I^Iread-sequence
line 129: syn keyword lispFunc^I^Iarray-total-size^I^Igraphic-char-p^I^I^I^I^Ireader-error
line 130: syn keyword lispFunc^I^Iarray-total-size-limit^I^Ihandler-bind^I^I^I^I^Ireadtable
line 131: syn keyword lispFunc^I^Iarrayp^I^I^I^Ihandler-case^I^I^I^I^Ireadtable-case
line 132: syn keyword lispFunc^I^Iash^I^I^I^Ihash-table^I^I^I^I^Ireadtablep
line 133: syn keyword lispFunc^I^Iasin^I^I^I^Ihash-table-count^I^I^I^Ireal
line 134: syn keyword lispFunc^I^Iasinh^I^I^I^Ihash-table-p^I^I^I^I^Irealp
line 135: syn keyword lispFunc^I^Iassert^I^I^I^Ihash-table-rehash-size^I^I^I^Irealpart
line 136: syn keyword lispFunc^I^Iassoc^I^I^I^Ihash-table-rehash-threshold^I^I^Ireduce
line 137: syn keyword lispFunc^I^Iassoc-if^I^I^Ihash-table-size^I^I^I^I^Ireinitialize-instance
line 138: syn keyword lispFunc^I^Iassoc-if-not^I^I^Ihash-table-test^I^I^I^I^Irem
line 139: syn keyword lispFunc^I^Iatan^I^I^I^Ihost-namestring^I^I^I^I^Iremf
line 140: syn keyword lispFunc^I^Iatanh^I^I^I^Iidentity^I^I^I^I^Iremhash
line 141: syn keyword lispFunc^I^Iatom^I^I^I^Iif^I^I^I^I^I^Iremove
line 142: syn keyword lispFunc^I^Ibase-char^I^I^Iif-exists^I^I^I^I^Iremove-duplicates
line 143: syn keyword lispFunc^I^Ibase-string^I^I^Iignorable^I^I^I^I^Iremove-if
line 144: syn keyword lispFunc^I^Ibignum^I^I^I^Iignore^I^I^I^I^I^Iremove-if-not
line 145: syn keyword lispFunc^I^Ibit^I^I^I^Iignore-errors^I^I^I^I^Iremove-method
line 146: syn keyword lispFunc^I^Ibit-and^I^I^I^Iimagpart^I^I^I^I^Iremprop
line 147: syn keyword lispFunc^I^Ibit-andc1^I^I^Iimport^I^I^I^I^I^Irename-file
line 148: syn keyword lispFunc^I^Ibit-andc2^I^I^Iin-package^I^I^I^I^Irename-package
line 149: syn keyword lispFunc^I^Ibit-eqv^I^I^I^Iin-package^I^I^I^I^Ireplace
line 150: syn keyword lispFunc^I^Ibit-ior^I^I^I^Iincf^I^I^I^I^I^Irequire
line 151: syn keyword lispFunc^I^Ibit-nand^I^I^Iinitialize-instance^I^I^I^Irest
line 152: syn keyword lispFunc^I^Ibit-nor^I^I^I^Iinline^I^I^I^I^I^Irestart
line 153: syn keyword lispFunc^I^Ibit-not^I^I^I^Iinput-stream-p^I^I^I^I^Irestart-bind
line 154: syn keyword lispFunc^I^Ibit-orc1^I^I^Iinspect^I^I^I^I^I^Irestart-case
line 155: syn keyword lispFunc^I^Ibit-orc2^I^I^Iint-char^I^I^I^I^Irestart-name
line 156: syn keyword lispFunc^I^Ibit-vector^I^I^Iinteger^I^I^I^I^I^Ireturn
line 157: syn keyword lispFunc^I^Ibit-vector-p^I^I^Iinteger-decode-float^I^I^I^Ireturn-from
line 158: syn keyword lispFunc^I^Ibit-xor^I^I^I^Iinteger-length^I^I^I^I^Irevappend
line 159: syn keyword lispFunc^I^Iblock^I^I^I^Iintegerp^I^I^I^I^Ireverse
line 160: syn keyword lispFunc^I^Iboole^I^I^I^Iinteractive-stream-p^I^I^I^Iroom
line 161: syn keyword lispFunc^I^Iboole-1^I^I^I^Iintern^I^I^I^I^I^Irotatef
line 162: syn keyword lispFunc^I^Iboole-2^I^I^I^Iinternal-time-units-per-second^I^I^Iround
line 163: syn keyword lispFunc^I^Iboole-and^I^I^Iintersection^I^I^I^I^Irow-major-aref
line 164: syn keyword lispFunc^I^Iboole-andc1^I^I^Iinvalid-method-error^I^I^I^Irplaca
line 165: syn keyword lispFunc^I^Iboole-andc2^I^I^Iinvoke-debugger^I^I^I^I^Irplacd
line 166: syn keyword lispFunc^I^Iboole-c1^I^I^Iinvoke-restart^I^I^I^I^Isafety
line 167: syn keyword lispFunc^I^Iboole-c2^I^I^Iinvoke-restart-interactively^I^I^Isatisfies
line 168: syn keyword lispFunc^I^Iboole-clr^I^I^Iisqrt^I^I^I^I^I^Isbit
line 169: syn keyword lispFunc^I^Iboole-eqv^I^I^Ikeyword^I^I^I^I^I^Iscale-float
line 170: syn keyword lispFunc^I^Iboole-ior^I^I^Ikeywordp^I^I^I^I^Ischar
line 171: syn keyword lispFunc^I^Iboole-nand^I^I^Ilabels^I^I^I^I^I^Isearch
line 172: syn keyword lispFunc^I^Iboole-nor^I^I^Ilambda^I^I^I^I^I^Isecond
line 173: syn keyword lispFunc^I^Iboole-orc1^I^I^Ilambda-list-keywords^I^I^I^Isequence
line 174: syn keyword lispFunc^I^Iboole-orc2^I^I^Ilambda-parameters-limit^I^I^I^Iserious-condition
line 175: syn keyword lispFunc^I^Iboole-set^I^I^Ilast^I^I^I^I^I^Iset
line 176: syn keyword lispFunc^I^Iboole-xor^I^I^Ilcm^I^I^I^I^I^Iset-char-bit
line 177: syn keyword lispFunc^I^Iboolean^I^I^I^Ildb^I^I^I^I^I^Iset-difference
line 178: syn keyword lispFunc^I^Iboth-case-p^I^I^Ildb-test^I^I^I^I^Iset-dispatch-macro-character
line 179: syn keyword lispFunc^I^Iboundp^I^I^I^Ildiff^I^I^I^I^I^Iset-exclusive-or
line 180: syn keyword lispFunc^I^Ibreak^I^I^I^Ileast-negative-double-float^I^I^Iset-macro-character
line 181: syn keyword lispFunc^I^Ibroadcast-stream^I^Ileast-negative-long-float^I^I^Iset-pprint-dispatch
line 182: syn keyword lispFunc^I^Ibroadcast-stream-streams^Ileast-negative-normalized-double-float^I^Iset-syntax-from-char
line 183: syn keyword lispFunc^I^Ibuilt-in-class^I^I^Ileast-negative-normalized-long-float^I^Isetf
line 184: syn keyword lispFunc^I^Ibutlast^I^I^I^Ileast-negative-normalized-short-float^I^Isetq
line 185: syn keyword lispFunc^I^Ibyte^I^I^I^Ileast-negative-normalized-single-float^I^Iseventh
line 186: syn keyword lispFunc^I^Ibyte-position^I^I^Ileast-negative-short-float^I^I^Ishadow
line 187: syn keyword lispFunc^I^Ibyte-size^I^I^Ileast-negative-single-float^I^I^Ishadowing-import
line 188: syn keyword lispFunc^I^Icall-arguments-limit^I^Ileast-positive-double-float^I^I^Ishared-initialize
line 189: syn keyword lispFunc^I^Icall-method^I^I^Ileast-positive-long-float^I^I^Ishiftf
line 190: syn keyword lispFunc^I^Icall-next-method^I^Ileast-positive-normalized-double-float^I^Ishort-float
line 191: syn keyword lispFunc^I^Icapitalize^I^I^Ileast-positive-normalized-long-float^I^Ishort-float-epsilon
line 192: syn keyword lispFunc^I^Icar^I^I^I^Ileast-positive-normalized-short-float^I^Ishort-float-negative-epsilon
line 193: syn keyword lispFunc^I^Icase^I^I^I^Ileast-positive-normalized-single-float^I^Ishort-site-name
line 194: syn keyword lispFunc^I^Icatch^I^I^I^Ileast-positive-short-float^I^I^Isignal
line 195: syn keyword lispFunc^I^Iccase^I^I^I^Ileast-positive-single-float^I^I^Isigned-byte
line 196: syn keyword lispFunc^I^Icdr^I^I^I^Ilength^I^I^I^I^I^Isignum
line 197: syn keyword lispFunc^I^Iceiling^I^I^I^Ilet^I^I^I^I^I^Isimple-condition
line 198: syn keyword lispFunc^I^Icell-error^I^I^Ilet*^I^I^I^I^I^Isimple-array
line 199: syn keyword lispFunc^I^Icell-error-name^I^I^Ilisp^I^I^I^I^I^Isimple-base-string
line 200: syn keyword lispFunc^I^Icerror^I^I^I^Ilisp-implementation-type^I^I^Isimple-bit-vector
line 201: syn keyword lispFunc^I^Ichange-class^I^I^Ilisp-implementation-version^I^I^Isimple-bit-vector-p
line 202: syn keyword lispFunc^I^Ichar^I^I^I^Ilist^I^I^I^I^I^Isimple-condition-format-arguments
line 203: syn keyword lispFunc^I^Ichar-bit^I^I^Ilist*^I^I^I^I^I^Isimple-condition-format-control
line 204: syn keyword lispFunc^I^Ichar-bits^I^I^Ilist-all-packages^I^I^I^Isimple-error
line 205: syn keyword lispFunc^I^Ichar-bits-limit^I^I^Ilist-length^I^I^I^I^Isimple-string
line 206: syn keyword lispFunc^I^Ichar-code^I^I^Ilisten^I^I^I^I^I^Isimple-string-p
line 207: syn keyword lispFunc^I^Ichar-code-limit^I^I^Ilistp^I^I^I^I^I^Isimple-type-error
line 208: syn keyword lispFunc^I^Ichar-control-bit^I^Iload^I^I^I^I^I^Isimple-vector
line 209: syn keyword lispFunc^I^Ichar-downcase^I^I^Iload-logical-pathname-translations^I^Isimple-vector-p
line 210: syn keyword lispFunc^I^Ichar-equal^I^I^Iload-time-value^I^I^I^I^Isimple-warning
line 211: syn keyword lispFunc^I^Ichar-font^I^I^Ilocally^I^I^I^I^I^Isin
line 212: syn keyword lispFunc^I^Ichar-font-limit^I^I^Ilog^I^I^I^I^I^Isingle-flaot-epsilon
line 213: syn keyword lispFunc^I^Ichar-greaterp^I^I^Ilogand^I^I^I^I^I^Isingle-float
line 214: syn keyword lispFunc^I^Ichar-hyper-bit^I^I^Ilogandc1^I^I^I^I^Isingle-float-epsilon
line 215: syn keyword lispFunc^I^Ichar-int^I^I^Ilogandc2^I^I^I^I^Isingle-float-negative-epsilon
line 216: syn keyword lispFunc^I^Ichar-lessp^I^I^Ilogbitp^I^I^I^I^I^Isinh
line 217: syn keyword lispFunc^I^Ichar-meta-bit^I^I^Ilogcount^I^I^I^I^Isixth
line 218: syn keyword lispFunc^I^Ichar-name^I^I^Ilogeqv^I^I^I^I^I^Isleep
line 219: syn keyword lispFunc^I^Ichar-not-equal^I^I^Ilogical-pathname^I^I^I^Islot-boundp
line 220: syn keyword lispFunc^I^Ichar-not-greaterp^I^Ilogical-pathname-translations^I^I^Islot-exists-p
line 221: syn keyword lispFunc^I^Ichar-not-lessp^I^I^Ilogior^I^I^I^I^I^Islot-makunbound
line 222: syn keyword lispFunc^I^Ichar-super-bit^I^I^Ilognand^I^I^I^I^I^Islot-missing
line 223: syn keyword lispFunc^I^Ichar-upcase^I^I^Ilognor^I^I^I^I^I^Islot-unbound
line 224: syn keyword lispFunc^I^Ichar/=^I^I^I^Ilognot^I^I^I^I^I^Islot-value
line 225: syn keyword lispFunc^I^Ichar<^I^I^I^Ilogorc1^I^I^I^I^I^Isoftware-type
line 226: syn keyword lispFunc^I^Ichar<=^I^I^I^Ilogorc2^I^I^I^I^I^Isoftware-version
line 227: syn keyword lispFunc^I^Ichar=^I^I^I^Ilogtest^I^I^I^I^I^Isome
line 228: syn keyword lispFunc^I^Ichar>^I^I^I^Ilogxor^I^I^I^I^I^Isort
line 229: syn keyword lispFunc^I^Ichar>=^I^I^I^Ilong-float^I^I^I^I^Ispace
line 230: syn keyword lispFunc^I^Icharacter^I^I^Ilong-float-epsilon^I^I^I^Ispecial
line 231: syn keyword lispFunc^I^Icharacterp^I^I^Ilong-float-negative-epsilon^I^I^Ispecial-form-p
line 232: syn keyword lispFunc^I^Icheck-type^I^I^Ilong-site-name^I^I^I^I^Ispecial-operator-p
line 233: syn keyword lispFunc^I^Icis^I^I^I^Iloop^I^I^I^I^I^Ispeed
line 234: syn keyword lispFunc^I^Iclass^I^I^I^Iloop-finish^I^I^I^I^Isqrt
line 235: syn keyword lispFunc^I^Iclass-name^I^I^Ilower-case-p^I^I^I^I^Istable-sort
line 236: syn keyword lispFunc^I^Iclass-of^I^I^Imachine-instance^I^I^I^Istandard
line 237: syn keyword lispFunc^I^Iclear-input^I^I^Imachine-type^I^I^I^I^Istandard-char
line 238: syn keyword lispFunc^I^Iclear-output^I^I^Imachine-version^I^I^I^I^Istandard-char-p
line 239: syn keyword lispFunc^I^Iclose^I^I^I^Imacro-function^I^I^I^I^Istandard-class
line 240: syn keyword lispFunc^I^Iclrhash^I^I^I^Imacroexpand^I^I^I^I^Istandard-generic-function
line 241: syn keyword lispFunc^I^Icode-char^I^I^Imacroexpand-1^I^I^I^I^Istandard-method
line 242: syn keyword lispFunc^I^Icoerce^I^I^I^Imacroexpand-l^I^I^I^I^Istandard-object
line 243: syn keyword lispFunc^I^Icommonp^I^I^I^Imacrolet^I^I^I^I^Istep
line 244: syn keyword lispFunc^I^Icompilation-speed^I^Imake-array^I^I^I^I^Istorage-condition
line 245: syn keyword lispFunc^I^Icompile^I^I^I^Imake-array^I^I^I^I^Istore-value
line 246: syn keyword lispFunc^I^Icompile-file^I^I^Imake-broadcast-stream^I^I^I^Istream
line 247: syn keyword lispFunc^I^Icompile-file-pathname^I^Imake-char^I^I^I^I^Istream-element-type
line 248: syn keyword lispFunc^I^Icompiled-function^I^Imake-concatenated-stream^I^I^Istream-error
line 249: syn keyword lispFunc^I^Icompiled-function-p^I^Imake-condition^I^I^I^I^Istream-error-stream
line 250: syn keyword lispFunc^I^Icompiler-let^I^I^Imake-dispatch-macro-character^I^I^Istream-external-format
line 251: syn keyword lispFunc^I^Icompiler-macro^I^I^Imake-echo-stream^I^I^I^Istreamp
line 252: syn keyword lispFunc^I^Icompiler-macro-function^Imake-hash-table^I^I^I^I^I^Istreamup
line 253: syn keyword lispFunc^I^Icomplement^I^I^Imake-instance^I^I^I^I^Istring
line 254: syn keyword lispFunc^I^Icomplex^I^I^I^Imake-instances-obsolete^I^I^I^Istring-capitalize
line 255: syn keyword lispFunc^I^Icomplexp^I^I^Imake-list^I^I^I^I^Istring-char
line 256: syn keyword lispFunc^I^Icompute-applicable-methods^Imake-load-form^I^I^I^I^Istring-char-p
line 257: syn keyword lispFunc^I^Icompute-restarts^I^Imake-load-form-saving-slots^I^I^Istring-downcase
line 258: syn keyword lispFunc^I^Iconcatenate^I^I^Imake-method^I^I^I^I^Istring-equal
line 259: syn keyword lispFunc^I^Iconcatenated-stream^I^Imake-package^I^I^I^I^Istring-greaterp
line 260: syn keyword lispFunc^I^Iconcatenated-stream-streams^Imake-pathname^I^I^I^I^Istring-left-trim
line 261: syn keyword lispFunc^I^Icond^I^I^I^Imake-random-state^I^I^I^Istring-lessp
line 262: syn keyword lispFunc^I^Icondition^I^I^Imake-sequence^I^I^I^I^Istring-not-equal
line 263: syn keyword lispFunc^I^Iconjugate^I^I^Imake-string^I^I^I^I^Istring-not-greaterp
line 264: syn keyword lispFunc^I^Icons^I^I^I^Imake-string-input-stream^I^I^Istring-not-lessp
line 265: syn keyword lispFunc^I^Iconsp^I^I^I^Imake-string-output-stream^I^I^Istring-right-strim
line 266: syn keyword lispFunc^I^Iconstantly^I^I^Imake-symbol^I^I^I^I^Istring-right-trim
line 267: syn keyword lispFunc^I^Iconstantp^I^I^Imake-synonym-stream^I^I^I^Istring-stream
line 268: syn keyword lispFunc^I^Icontinue^I^I^Imake-two-way-stream^I^I^I^Istring-trim
line 269: syn keyword lispFunc^I^Icontrol-error^I^I^Imakunbound^I^I^I^I^Istring-upcase
line 270: syn keyword lispFunc^I^Icopy-alist^I^I^Imap^I^I^I^I^I^Istring/=
line 271: syn keyword lispFunc^I^Icopy-list^I^I^Imap-into^I^I^I^I^Istring<
line 272: syn keyword lispFunc^I^Icopy-pprint-dispatch^I^Imapc^I^I^I^I^I^Istring<=
line 273: syn keyword lispFunc^I^Icopy-readtable^I^I^Imapcan^I^I^I^I^I^Istring=
line 274: syn keyword lispFunc^I^Icopy-seq^I^I^Imapcar^I^I^I^I^I^Istring>
line 275: syn keyword lispFunc^I^Icopy-structure^I^I^Imapcon^I^I^I^I^I^Istring>=
line 276: syn keyword lispFunc^I^Icopy-symbol^I^I^Imaphash^I^I^I^I^I^Istringp
line 277: syn keyword lispFunc^I^Icopy-tree^I^I^Imapl^I^I^I^I^I^Istructure
line 278: syn keyword lispFunc^I^Icos^I^I^I^Imaplist^I^I^I^I^I^Istructure-class
line 279: syn keyword lispFunc^I^Icosh^I^I^I^Imask-field^I^I^I^I^Istructure-object
line 280: syn keyword lispFunc^I^Icount^I^I^I^Imax^I^I^I^I^I^Istyle-warning
line 281: syn keyword lispFunc^I^Icount-if^I^I^Imember^I^I^I^I^I^Isublim
line 282: syn keyword lispFunc^I^Icount-if-not^I^I^Imember-if^I^I^I^I^Isublis
line 283: syn keyword lispFunc^I^Ictypecase^I^I^Imember-if-not^I^I^I^I^Isubseq
line 284: syn keyword lispFunc^I^Idebug^I^I^I^Imerge^I^I^I^I^I^Isubsetp
line 285: syn keyword lispFunc^I^Idecf^I^I^I^Imerge-pathname^I^I^I^I^Isubst
line 286: syn keyword lispFunc^I^Ideclaim^I^I^I^Imerge-pathnames^I^I^I^I^Isubst-if
line 287: syn keyword lispFunc^I^Ideclaration^I^I^Imethod^I^I^I^I^I^Isubst-if-not
line 288: syn keyword lispFunc^I^Ideclare^I^I^I^Imethod-combination^I^I^I^Isubstitute
line 289: syn keyword lispFunc^I^Idecode-float^I^I^Imethod-combination-error^I^I^Isubstitute-if
line 290: syn keyword lispFunc^I^Idecode-universal-time^I^Imethod-qualifiers^I^I^I^Isubstitute-if-not
line 291: syn keyword lispFunc^I^Idefclass^I^I^Imin^I^I^I^I^I^Isubtypep
line 292: syn keyword lispFunc^I^Idefconstant^I^I^Iminusp^I^I^I^I^I^Isvref
line 293: syn keyword lispFunc^I^Idefgeneric^I^I^Imismatch^I^I^I^I^Isxhash
line 294: syn keyword lispFunc^I^Idefine-compiler-macro^I^Imod^I^I^I^I^I^Isymbol
line 295: syn keyword lispFunc^I^Idefine-condition^I^Imost-negative-double-float^I^I^Isymbol-function
line 296: syn keyword lispFunc^I^Idefine-method-combination^Imost-negative-fixnum^I^I^I^Isymbol-macrolet
line 297: syn keyword lispFunc^I^Idefine-modify-macro^I^Imost-negative-long-float^I^I^Isymbol-name
line 298: syn keyword lispFunc^I^Idefine-setf-expander^I^Imost-negative-short-float^I^I^Isymbol-package
line 299: syn keyword lispFunc^I^Idefine-setf-method^I^Imost-negative-single-float^I^I^Isymbol-plist
line 300: syn keyword lispFunc^I^Idefine-symbol-macro^I^Imost-positive-double-float^I^I^Isymbol-value
line 301: syn keyword lispFunc^I^Idefmacro^I^I^Imost-positive-fixnum^I^I^I^Isymbolp
line 302: syn keyword lispFunc^I^Idefmethod^I^I^Imost-positive-long-float^I^I^Isynonym-stream
line 303: syn keyword lispFunc^I^Idefpackage^I^I^Imost-positive-short-float^I^I^Isynonym-stream-symbol
line 304: syn keyword lispFunc^I^Idefparameter^I^I^Imost-positive-single-float^I^I^Isys
line 305: syn keyword lispFunc^I^Idefsetf^I^I^I^Imuffle-warning^I^I^I^I^Isystem
line 306: syn keyword lispFunc^I^Idefstruct^I^I^Imultiple-value-bind^I^I^I^It
line 307: syn keyword lispFunc^I^Ideftype^I^I^I^Imultiple-value-call^I^I^I^Itagbody
line 308: syn keyword lispFunc^I^Idefun^I^I^I^Imultiple-value-list^I^I^I^Itailp
line 309: syn keyword lispFunc^I^Idefvar^I^I^I^Imultiple-value-prog1^I^I^I^Itan
line 310: syn keyword lispFunc^I^Idelete^I^I^I^Imultiple-value-seteq^I^I^I^Itanh
line 311: syn keyword lispFunc^I^Idelete-duplicates^I^Imultiple-value-setq^I^I^I^Itenth
line 312: syn keyword lispFunc^I^Idelete-file^I^I^Imultiple-values-limit^I^I^I^Iterpri
line 313: syn keyword lispFunc^I^Idelete-if^I^I^Iname-char^I^I^I^I^Ithe
line 314: syn keyword lispFunc^I^Idelete-if-not^I^I^Inamestring^I^I^I^I^Ithird
line 315: syn keyword lispFunc^I^Idelete-package^I^I^Inbutlast^I^I^I^I^Ithrow
line 316: syn keyword lispFunc^I^Idenominator^I^I^Inconc^I^I^I^I^I^Itime
line 317: syn keyword lispFunc^I^Ideposit-field^I^I^Inext-method-p^I^I^I^I^Itrace
line 318: syn keyword lispFunc^I^Idescribe^I^I^Inil^I^I^I^I^I^Itranslate-logical-pathname
line 319: syn keyword lispFunc^I^Idescribe-object^I^I^Inintersection^I^I^I^I^Itranslate-pathname
line 320: syn keyword lispFunc^I^Idestructuring-bind^I^Ininth^I^I^I^I^I^Itree-equal
line 321: syn keyword lispFunc^I^Idigit-char^I^I^Ino-applicable-method^I^I^I^Itruename
line 322: syn keyword lispFunc^I^Idigit-char-p^I^I^Ino-next-method^I^I^I^I^Itruncase
line 323: syn keyword lispFunc^I^Idirectory^I^I^Inot^I^I^I^I^I^Itruncate
line 324: syn keyword lispFunc^I^Idirectory-namestring^I^Inotany^I^I^I^I^I^Itwo-way-stream
line 325: syn keyword lispFunc^I^Idisassemble^I^I^Inotevery^I^I^I^I^Itwo-way-stream-input-stream
line 326: syn keyword lispFunc^I^Idivision-by-zero^I^Inotinline^I^I^I^I^Itwo-way-stream-output-stream
line 327: syn keyword lispFunc^I^Ido^I^I^I^Inreconc^I^I^I^I^I^Itype
line 328: syn keyword lispFunc^I^Ido*^I^I^I^Inreverse^I^I^I^I^Itype-error
line 329: syn keyword lispFunc^I^Ido-all-symbols^I^I^Inset-difference^I^I^I^I^Itype-error-datum
line 330: syn keyword lispFunc^I^Ido-exeternal-symbols^I^Inset-exclusive-or^I^I^I^Itype-error-expected-type
line 331: syn keyword lispFunc^I^Ido-external-symbols^I^Instring^I^I^I^I^I^Itype-of
line 332: syn keyword lispFunc^I^Ido-symbols^I^I^Instring-capitalize^I^I^I^Itypecase
line 333: syn keyword lispFunc^I^Idocumentation^I^I^Instring-downcase^I^I^I^Itypep
line 334: syn keyword lispFunc^I^Idolist^I^I^I^Instring-upcase^I^I^I^I^Iunbound-slot
line 335: syn keyword lispFunc^I^Idotimes^I^I^I^Insublis^I^I^I^I^I^Iunbound-slot-instance
line 336: syn keyword lispFunc^I^Idouble-float^I^I^Insubst^I^I^I^I^I^Iunbound-variable
line 337: syn keyword lispFunc^I^Idouble-float-epsilon^I^Insubst-if^I^I^I^I^Iundefined-function
line 338: syn keyword lispFunc^I^Idouble-float-negative-epsilon^Insubst-if-not^I^I^I^I^Iunexport
line 339: syn keyword lispFunc^I^Idpb^I^I^I^Insubstitute^I^I^I^I^Iunintern
line 340: syn keyword lispFunc^I^Idribble^I^I^I^Insubstitute-if^I^I^I^I^Iunion
line 341: syn keyword lispFunc^I^Idynamic-extent^I^I^Insubstitute-if-not^I^I^I^Iunless
line 342: syn keyword lispFunc^I^Iecase^I^I^I^Inth^I^I^I^I^I^Iunread
line 343: syn keyword lispFunc^I^Iecho-stream^I^I^Inth-value^I^I^I^I^Iunread-char
line 344: syn keyword lispFunc^I^Iecho-stream-input-stream^Inthcdr^I^I^I^I^I^Iunsigned-byte
line 345: syn keyword lispFunc^I^Iecho-stream-output-stream^Inull^I^I^I^I^I^Iuntrace
line 346: syn keyword lispFunc^I^Ied^I^I^I^Inumber^I^I^I^I^I^Iunuse-package
line 347: syn keyword lispFunc^I^Ieighth^I^I^I^Inumberp^I^I^I^I^I^Iunwind-protect
line 348: syn keyword lispFunc^I^Ielt^I^I^I^Inumerator^I^I^I^I^Iupdate-instance-for-different-class
line 349: syn keyword lispFunc^I^Iencode-universal-time^I^Inunion^I^I^I^I^I^Iupdate-instance-for-redefined-class
line 350: syn keyword lispFunc^I^Iend-of-file^I^I^Ioddp^I^I^I^I^I^Iupgraded-array-element-type
line 351: syn keyword lispFunc^I^Iendp^I^I^I^Iopen^I^I^I^I^I^Iupgraded-complex-part-type
line 352: syn keyword lispFunc^I^Ienough-namestring^I^Iopen-stream-p^I^I^I^I^Iupper-case-p
line 353: syn keyword lispFunc^I^Iensure-directories-exist^Ioptimize^I^I^I^I^Iuse-package
line 354: syn keyword lispFunc^I^Iensure-generic-function^Ior^I^I^I^I^I^I^Iuse-value
line 355: syn keyword lispFunc^I^Ieq^I^I^I^Iotherwise^I^I^I^I^Iuser
line 356: syn keyword lispFunc^I^Ieql^I^I^I^Ioutput-stream-p^I^I^I^I^Iuser-homedir-pathname
line 357: syn keyword lispFunc^I^Iequal^I^I^I^Ipackage^I^I^I^I^I^Ivalues
line 358: syn keyword lispFunc^I^Iequalp^I^I^I^Ipackage-error^I^I^I^I^Ivalues-list
line 359: syn keyword lispFunc^I^Ierror^I^I^I^Ipackage-error-package^I^I^I^Ivector
line 360: syn keyword lispFunc^I^Ietypecase^I^I^Ipackage-name^I^I^I^I^Ivector-pop
line 361: syn keyword lispFunc^I^Ieval^I^I^I^Ipackage-nicknames^I^I^I^Ivector-push
line 362: syn keyword lispFunc^I^Ieval-when^I^I^Ipackage-shadowing-symbols^I^I^Ivector-push-extend
line 363: syn keyword lispFunc^I^Ievalhook^I^I^Ipackage-use-list^I^I^I^Ivectorp
line 364: syn keyword lispFunc^I^Ievenp^I^I^I^Ipackage-used-by-list^I^I^I^Iwarn
line 365: syn keyword lispFunc^I^Ievery^I^I^I^Ipackagep^I^I^I^I^Iwarning
line 366: syn keyword lispFunc^I^Iexp^I^I^I^Ipairlis^I^I^I^I^I^Iwhen
line 367: syn keyword lispFunc^I^Iexport^I^I^I^Iparse-error^I^I^I^I^Iwild-pathname-p
line 368: syn keyword lispFunc^I^Iexpt^I^I^I^Iparse-integer^I^I^I^I^Iwith-accessors
line 369: syn keyword lispFunc^I^Iextended-char^I^I^Iparse-namestring^I^I^I^Iwith-compilation-unit
line 370: syn keyword lispFunc^I^Ifboundp^I^I^I^Ipathname^I^I^I^I^Iwith-condition-restarts
line 371: syn keyword lispFunc^I^Ifceiling^I^I^Ipathname-device^I^I^I^I^Iwith-hash-table-iterator
line 372: syn keyword lispFunc^I^Ifdefinition^I^I^Ipathname-directory^I^I^I^Iwith-input-from-string
line 373: syn keyword lispFunc^I^Iffloor^I^I^I^Ipathname-host^I^I^I^I^Iwith-open-file
line 374: syn keyword lispFunc^I^Ififth^I^I^I^Ipathname-match-p^I^I^I^Iwith-open-stream
line 375: syn keyword lispFunc^I^Ifile-author^I^I^Ipathname-name^I^I^I^I^Iwith-output-to-string
line 376: syn keyword lispFunc^I^Ifile-error^I^I^Ipathname-type^I^I^I^I^Iwith-package-iterator
line 377: syn keyword lispFunc^I^Ifile-error-pathname^I^Ipathname-version^I^I^I^Iwith-simple-restart
line 378: syn keyword lispFunc^I^Ifile-length^I^I^Ipathnamep^I^I^I^I^Iwith-slots
line 379: syn keyword lispFunc^I^Ifile-namestring^I^I^Ipeek-char^I^I^I^I^Iwith-standard-io-syntax
line 380: syn keyword lispFunc^I^Ifile-position^I^I^Iphase^I^I^I^I^I^Iwrite
line 381: syn keyword lispFunc^I^Ifile-stream^I^I^Ipi^I^I^I^I^I^Iwrite-byte
line 382: syn keyword lispFunc^I^Ifile-string-length^I^Iplusp^I^I^I^I^I^Iwrite-char
line 383: syn keyword lispFunc^I^Ifile-write-date^I^I^Ipop^I^I^I^I^I^Iwrite-line
line 384: syn keyword lispFunc^I^Ifill^I^I^I^Iposition^I^I^I^I^Iwrite-sequence
line 385: syn keyword lispFunc^I^Ifill-pointer^I^I^Iposition-if^I^I^I^I^Iwrite-string
line 386: syn keyword lispFunc^I^Ifind^I^I^I^Iposition-if-not^I^I^I^I^Iwrite-to-string
line 387: syn keyword lispFunc^I^Ifind-all-symbols^I^Ipprint^I^I^I^I^I^Iy-or-n-p
line 388: syn keyword lispFunc^I^Ifind-class^I^I^Ipprint-dispatch^I^I^I^I^Iyes-or-no-p
line 389: syn keyword lispFunc^I^Ifind-if^I^I^I^Ipprint-exit-if-list-exhausted^I^I^Izerop
line 390: syn keyword lispFunc^I^Ifind-if-not^I^I^Ipprint-fill
line 391: 
line 392: syn match   lispFunc^I^I"\<c[ad]\+r\>"
line 393: if exists("g:lispsyntax_clisp")
line 394:   " CLISP FFI:
line 395:   syn match lispFunc^I"\<\(ffi:\)\?with-c-\(place\|var\)\>"
line 396:   syn match lispFunc^I"\<\(ffi:\)\?with-foreign-\(object\|string\)\>"
line 397:   syn match lispFunc^I"\<\(ffi:\)\?default-foreign-\(language\|library\)\>"
line 398:   syn match lispFunc^I"\<\([us]_\?\)\?\(element\|deref\|cast\|slot\|validp\)\>"
line 399:   syn match lispFunc^I"\<\(ffi:\)\?set-foreign-pointer\>"
line 400:   syn match lispFunc^I"\<\(ffi:\)\?allocate-\(deep\|shallow\)\>"
line 401:   syn match lispFunc^I"\<\(ffi:\)\?c-lines\>"
line 402:   syn match lispFunc^I"\<\(ffi:\)\?foreign-\(value\|free\|variable\|function\|object\)\>"
line 403:   syn match lispFunc^I"\<\(ffi:\)\?foreign-address\(-null\|unsigned\)\?\>"
line 404:   syn match lispFunc^I"\<\(ffi:\)\?undigned-foreign-address\>"
line 405:   syn match lispFunc^I"\<\(ffi:\)\?c-var-\(address\|object\)\>"
line 406:   syn match lispFunc^I"\<\(ffi:\)\?typeof\>"
line 407:   syn match lispFunc^I"\<\(ffi:\)\?\(bit\)\?sizeof\>"
line 408: " CLISP Macros, functions et al:
line 409:   syn match lispFunc^I"\<\(ext:\)\?with-collect\>"
line 410:   syn match lispFunc^I"\<\(ext:\)\?letf\*\?\>"
line 411:   syn match lispFunc^I"\<\(ext:\)\?finalize\>\>"
line 412:   syn match lispFunc^I"\<\(ext:\)\?memoized\>"
line 413:   syn match lispFunc^I"\<\(ext:\)\?getenv\>"
line 414:   syn match lispFunc^I"\<\(ext:\)\?convert-string-\(to\|from\)-bytes\>"
line 415:   syn match lispFunc^I"\<\(ext:\)\?ethe\>"
line 416:   syn match lispFunc^I"\<\(ext:\)\?with-gensyms\>"
line 417:   syn match lispFunc^I"\<\(ext:\)\?open-http\>"
line 418:   syn match lispFunc^I"\<\(ext:\)\?string-concat\>"
line 419:   syn match lispFunc^I"\<\(ext:\)\?with-http-\(in\|out\)put\>"
line 420:   syn match lispFunc^I"\<\(ext:\)\?with-html-output\>"
line 421:   syn match lispFunc^I"\<\(ext:\)\?expand-form\>"
line 422:   syn match lispFunc^I"\<\(ext:\)\?\(without-\)\?package-lock\>"
line 423:   syn match lispFunc^I"\<\(ext:\)\?re-export\>"
line 424:   syn match lispFunc^I"\<\(ext:\)\?saveinitmem\>"
line 425:   syn match lispFunc^I"\<\(ext:\)\?\(read\|write\)-\(integer\|float\)\>"
line 426:   syn match lispFunc^I"\<\(ext:\)\?\(read\|write\)-\(char\|byte\)-sequence\>"
line 427:   syn match lispFunc^I"\<\(custom:\)\?\*system-package-list\*\>"
line 428:   syn match lispFunc^I"\<\(custom:\)\?\*ansi\*\>"
line 429: endif
line 430: 
line 431: " ---------------------------------------------------------------------
line 432: " Lisp Keywords (modifiers): {{{1
line 433: syn keyword lispKey^I^I:abort^I^I^I^I:from-end^I^I^I:overwrite
line 434: syn keyword lispKey^I^I:adjustable^I^I^I:gensym^I^I^I^I:predicate
line 435: syn keyword lispKey^I^I:append^I^I^I^I:host^I^I^I^I:preserve-whitespace
line 436: syn keyword lispKey^I^I:array^I^I^I^I:if-does-not-exist^I^I:pretty
line 437: syn keyword lispKey^I^I:base^I^I^I^I:if-exists^I^I^I:print
line 438: syn keyword lispKey^I^I:case^I^I^I^I:include^I^I^I:print-function
line 439: syn keyword lispKey^I^I:circle^I^I^I^I:index^I^I^I^I:probe
line 440: syn keyword lispKey^I^I:conc-name^I^I^I:inherited^I^I^I:radix
line 441: syn keyword lispKey^I^I:constructor^I^I^I:initial-contents^I^I:read-only
line 442: syn keyword lispKey^I^I:copier^I^I^I^I:initial-element^I^I:rehash-size
line 443: syn keyword lispKey^I^I:count^I^I^I^I:initial-offset^I^I^I:rehash-threshold
line 444: syn keyword lispKey^I^I:create^I^I^I^I:initial-value^I^I^I:rename
line 445: syn keyword lispKey^I^I:default^I^I^I:input^I^I^I^I:rename-and-delete
line 446: syn keyword lispKey^I^I:defaults^I^I^I:internal^I^I^I:size
line 447: syn keyword lispKey^I^I:device^I^I^I^I:io^I^I^I^I:start
line 448: syn keyword lispKey^I^I:direction^I^I^I:junk-allowed^I^I^I:start1
line 449: syn keyword lispKey^I^I:directory^I^I^I:key^I^I^I^I:start2
line 450: syn keyword lispKey^I^I:displaced-index-offset^I^I:length^I^I^I^I:stream
line 451: syn keyword lispKey^I^I:displaced-to^I^I^I:level^I^I^I^I:supersede
line 452: syn keyword lispKey^I^I:element-type^I^I^I:name^I^I^I^I:test
line 453: syn keyword lispKey^I^I:end^I^I^I^I:named^I^I^I^I:test-not
line 454: syn keyword lispKey^I^I:end1^I^I^I^I:new-version^I^I^I:type
line 455: syn keyword lispKey^I^I:end2^I^I^I^I:nicknames^I^I^I:use
line 456: syn keyword lispKey^I^I:error^I^I^I^I:output^I^I^I^I:verbose
line 457: syn keyword lispKey^I^I:escape^I^I^I^I:output-file^I^I^I:version
line 458: syn keyword lispKey^I^I:external
line 459: " defpackage arguments
line 460: syn keyword lispKey^I:documentation^I:shadowing-import-from^I:modern^I^I:export
line 461: syn keyword lispKey^I:case-sensitive^I:case-inverted^I^I:shadow^I^I:import-from^I:intern
line 462: " lambda list keywords
line 463: syn keyword lispKey^I&allow-other-keys^I&aux^I^I&body
line 464: syn keyword lispKey^I&environment^I&key^I^I^I&optional^I&rest^I^I&whole
line 465: " make-array argument
line 466: syn keyword lispKey^I:fill-pointer
line 467: " readtable-case values
line 468: syn keyword lispKey^I:upcase^I^I:downcase^I^I:preserve^I:invert
line 469: " eval-when situations
line 470: syn keyword lispKey^I:load-toplevel^I:compile-toplevel^I:execute
line 471: " ANSI Extended LOOP:
line 472: syn keyword lispKey^I:while      :until       :for         :do       :if          :then         :else     :when      :unless :in
line 473: syn keyword lispKey^I:across     :finally     :collect     :nconc    :maximize    :minimize     :sum
line 474: syn keyword lispKey^I:and        :with        :initially   :append   :into        :count        :end      :repeat
line 475: syn keyword lispKey^I:always     :never       :thereis     :from     :to          :upto         :downto   :below
line 476: syn keyword lispKey^I:above      :by          :on          :being    :each        :the          :hash-key :hash-keys
line 477: syn keyword lispKey^I:hash-value :hash-values :using       :of-type  :upfrom      :downfrom
line 478: if exists("g:lispsyntax_clisp")
line 479:   " CLISP FFI:
line 480:   syn keyword lispKey^I:arguments  :return-type :library     :full     :malloc-free
line 481:   syn keyword lispKey^I:none       :alloca      :in          :out      :in-out      :stdc-stdcall :stdc     :c
line 482:   syn keyword lispKey^I:language   :built-in    :typedef     :external
line 483:   syn keyword lispKey^I:fini       :init-once   :init-always
line 484: endif
line 485: 
line 486: " ---------------------------------------------------------------------
line 487: " Standard Lisp Variables: {{{1
line 488: syn keyword lispVar^I^I*applyhook*^I^I^I*load-pathname*^I^I^I*print-pprint-dispatch*
line 489: syn keyword lispVar^I^I*break-on-signals*^I^I*load-print*^I^I^I*print-pprint-dispatch*
line 490: syn keyword lispVar^I^I*break-on-signals*^I^I*load-truename*^I^I^I*print-pretty*
line 491: syn keyword lispVar^I^I*break-on-warnings*^I^I*load-verbose*^I^I^I*print-radix*
line 492: syn keyword lispVar^I^I*compile-file-pathname*^I^I*macroexpand-hook*^I^I*print-readably*
line 493: syn keyword lispVar^I^I*compile-file-pathname*^I^I*modules*^I^I^I*print-right-margin*
line 494: syn keyword lispVar^I^I*compile-file-truename*^I^I*package*^I^I^I*print-right-margin*
line 495: syn keyword lispVar^I^I*compile-file-truename*^I^I*print-array*^I^I^I*query-io*
line 496: syn keyword lispVar^I^I*compile-print*^I^I^I*print-base*^I^I^I*random-state*
line 497: syn keyword lispVar^I^I*compile-verbose*^I^I*print-case*^I^I^I*read-base*
line 498: syn keyword lispVar^I^I*compile-verbose*^I^I*print-circle*^I^I^I*read-default-float-format*
line 499: syn keyword lispVar^I^I*debug-io*^I^I^I*print-escape*^I^I^I*read-eval*
line 500: syn keyword lispVar^I^I*debugger-hook*^I^I^I*print-gensym*^I^I^I*read-suppress*
line 501: syn keyword lispVar^I^I*default-pathname-defaults*^I*print-length*^I^I^I*readtable*
line 502: syn keyword lispVar^I^I*error-output*^I^I^I*print-level*^I^I^I*standard-input*
line 503: syn keyword lispVar^I^I*evalhook*^I^I^I*print-lines*^I^I^I*standard-output*
line 504: syn keyword lispVar^I^I*features*^I^I^I*print-miser-width*^I^I*terminal-io*
line 505: syn keyword lispVar^I^I*gensym-counter*^I^I*print-miser-width*^I^I*trace-output*
line 506: 
line 507: " ---------------------------------------------------------------------
line 508: " Strings: {{{1
line 509: syn region^I^I^IlispString^I^I^Istart=+"+ skip=+\\\\\|\\"+ end=+"+^Icontains=@Spell
line 510: if exists("g:lisp_instring")
line 511:  syn region^I^I^IlispInString^I^I^Ikeepend matchgroup=Delimiter start=+"(+rs=s+1 skip=+|.\{-}|+ matchgroup=Delimiter end=+)"+ contains=@lispBaseListCluster,lispInStringString
line 512:  syn region^I^I^IlispInStringString^I^Istart=+\\"+ skip=+\\\\+ end=+\\"+ contained
line 513: endif
line 514: 
line 515: " ---------------------------------------------------------------------
line 516: " Shared with Xlisp, Declarations, Macros, Functions: {{{1
line 517: syn keyword lispDecl^I^Idefmacro^I^I^Ido-all-symbols^I^Ilabels
line 518: syn keyword lispDecl^I^Idefsetf^I^I^I^Ido-external-symbols^Ilet
line 519: syn keyword lispDecl^I^Ideftype^I^I^I^Ido-symbols^I^Ilocally
line 520: syn keyword lispDecl^I^Idefun^I^I^I^Idotimes^I^I^Imacrolet
line 521: syn keyword lispDecl^I^Ido*^I^I^I^Iflet^I^I^Imultiple-value-bind
line 522: if exists("g:lispsyntax_clisp")
line 523:   " CLISP FFI:
line 524:   syn match lispDecl^I"\<\(ffi:\)\?def-c-\(var\|const\|enum\|type\|struct\)\>"
line 525:   syn match lispDecl^I"\<\(ffi:\)\?def-call-\(out\|in\)\>"
line 526:   syn match lispDecl^I"\<\(ffi:\)\?c-\(function\|struct\|pointer\|string\)\>"
line 527:   syn match lispDecl^I"\<\(ffi:\)\?c-ptr\(-null\)\?\>"
line 528:   syn match lispDecl^I"\<\(ffi:\)\?c-array\(-ptr\|-max\)\?\>"
line 529:   syn match lispDecl^I"\<\(ffi:\)\?[us]\?\(char\|short\|int\|long\)\>"
line 530:   syn match lispDecl^I"\<\(win32:\|w32\)\?d\?word\>"
line 531:   syn match lispDecl^I"\<\([us]_\?\)\?int\(8\|16\|32\|64\)\(_t\)\?\>"
line 532:   syn keyword lispDecl^Isize_t off_t time_t handle
line 533: endif
line 534: 
line 535: " ---------------------------------------------------------------------
line 536: " Numbers: supporting integers and floating point numbers {{{1
line 537: syn match lispNumber^I^I"-\=\(\.\d\+\|\d\+\(\.\d*\)\=\)\([dDeEfFlL][-+]\=\d\+\)\="
line 538: syn match lispNumber^I^I"-\=\(\d\+/\d\+\)"
line 539: 
line 540: syn match lispEscapeSpecial^I^I"\*\w[a-z_0-9-]*\*"
line 541: syn match lispEscapeSpecial^I^I!#|[^()'`,"; \t]\+|#!
line 542: syn match lispEscapeSpecial^I^I!#x\x\+!
line 543: syn match lispEscapeSpecial^I^I!#o\o\+!
line 544: syn match lispEscapeSpecial^I^I!#b[01]\+!
line 545: syn match lispEscapeSpecial^I^I!#\\[ -}\~]!
line 546: syn match lispEscapeSpecial^I^I!#[':][^()'`,"; \t]\+!
line 547: syn match lispEscapeSpecial^I^I!#([^()'`,"; \t]\+)!
line 548: syn match lispEscapeSpecial^I^I!#\\\%(Space\|Newline\|Tab\|Page\|Rubout\|Linefeed\|Return\|Backspace\)!
line 549: syn match lispEscapeSpecial^I^I"\<+[a-zA-Z_][a-zA-Z_0-9-]*+\>"
line 550: 
line 551: syn match lispConcat^I^I"\s\.\s"
line 552: syn match lispParenError^I")"
line 553: 
line 554: " ---------------------------------------------------------------------
line 555: " Comments: {{{1
line 556: syn cluster lispCommentGroup^Icontains=lispTodo,@Spell
line 557: syn match   lispComment^I^I";.*$"^I^I^I^Icontains=@lispCommentGroup
line 558: syn region  lispCommentRegion^Istart="#|" end="|#"^I^Icontains=lispCommentRegion,@lispCommentGroup
line 559: syn keyword lispTodo^I^Icontained^I^I^Icombak^I^I^Icombak:^I^I^Itodo^I^I^Itodo:
line 560: 
line 561: " ---------------------------------------------------------------------
line 562: " Synchronization: {{{1
line 563: syn sync lines=100
line 564: 
line 565: " ---------------------------------------------------------------------
line 566: " Define Highlighting: {{{1
line 567: " For version 5.7 and earlier: only when not done already
line 568: " For version 5.8 and later: only when an item doesn't have highlighting yet
line 569: if version >= 508
line 570:   command -nargs=+ HiLink hi def link <args>
line 571: 
line 572:   HiLink lispCommentRegion^IlispComment
line 572: hi def link lispCommentRegion^IlispComment
line 573:   HiLink lispAtomNmbr^I^IlispNumber
line 573: hi def link lispAtomNmbr^I^IlispNumber
line 574:   HiLink lispAtomMark^I^IlispMark
line 574: hi def link lispAtomMark^I^IlispMark
line 575:   HiLink lispInStringString^IlispString
line 575: hi def link lispInStringString^IlispString
line 576: 
line 577:   HiLink lispAtom^I^IIdentifier
line 577: hi def link lispAtom^I^IIdentifier
line 578:   HiLink lispAtomBarSymbol^ISpecial
line 578: hi def link lispAtomBarSymbol^ISpecial
line 579:   HiLink lispBarSymbol^I^ISpecial
line 579: hi def link lispBarSymbol^I^ISpecial
line 580:   HiLink lispComment^I^IComment
line 580: hi def link lispComment^I^IComment
line 581:   HiLink lispConcat^I^IStatement
line 581: hi def link lispConcat^I^IStatement
line 582:   HiLink lispDecl^I^IStatement
line 582: hi def link lispDecl^I^IStatement
line 583:   HiLink lispFunc^I^IStatement
line 583: hi def link lispFunc^I^IStatement
line 584:   HiLink lispKey^I^IType
line 584: hi def link lispKey^I^IType
line 585:   HiLink lispMark^I^IDelimiter
line 585: hi def link lispMark^I^IDelimiter
line 586:   HiLink lispNumber^I^INumber
line 586: hi def link lispNumber^I^INumber
line 587:   HiLink lispParenError^I^IError
line 587: hi def link lispParenError^I^IError
line 588:   HiLink lispEscapeSpecial^IType
line 588: hi def link lispEscapeSpecial^IType
line 589:   HiLink lispString^I^IString
line 589: hi def link lispString^I^IString
line 590:   HiLink lispTodo^I^ITodo
line 590: hi def link lispTodo^I^ITodo
line 591:   HiLink lispVar^I^IStatement
line 591: hi def link lispVar^I^IStatement
line 592: 
line 593:   if exists("g:lisp_rainbow") && g:lisp_rainbow != 0
line 594:    if &bg == "dark"
line 595:     hi def hlLevel0 ctermfg=red         guifg=red1
line 596:     hi def hlLevel1 ctermfg=yellow      guifg=orange1
line 597:     hi def hlLevel2 ctermfg=green       guifg=yellow1
line 598:     hi def hlLevel3 ctermfg=cyan        guifg=greenyellow
line 599:     hi def hlLevel4 ctermfg=magenta     guifg=green1
line 600:     hi def hlLevel5 ctermfg=red         guifg=springgreen1
line 601:     hi def hlLevel6 ctermfg=yellow      guifg=cyan1
line 602:     hi def hlLevel7 ctermfg=green       guifg=slateblue1
line 603:     hi def hlLevel8 ctermfg=cyan        guifg=magenta1
line 604:     hi def hlLevel9 ctermfg=magenta     guifg=purple1
line 605:    else
line 606:     hi def hlLevel0 ctermfg=red         guifg=red3
line 607:     hi def hlLevel1 ctermfg=darkyellow  guifg=orangered3
line 608:     hi def hlLevel2 ctermfg=darkgreen   guifg=orange2
line 609:     hi def hlLevel3 ctermfg=blue        guifg=yellow3
line 610:     hi def hlLevel4 ctermfg=darkmagenta guifg=olivedrab4
line 611:     hi def hlLevel5 ctermfg=red         guifg=green4
line 612:     hi def hlLevel6 ctermfg=darkyellow  guifg=paleturquoise3
line 613:     hi def hlLevel7 ctermfg=darkgreen   guifg=deepskyblue4
line 614:     hi def hlLevel8 ctermfg=blue        guifg=darkslateblue
line 615:     hi def hlLevel9 ctermfg=darkmagenta guifg=darkviolet
line 616:    endif
line 617:   endif
line 618: 
line 619:   delcommand HiLink
line 620: endif
line 621: 
line 622: let b:current_syntax = "lisp"
line 623: 
line 624: " ---------------------------------------------------------------------
line 625: " vim: ts=8 nowrap fdm=marker
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/lisp.vim
continuing in /Users/leostera/.vim/syntax/lisp/slimv-syntax-lisp.vim
line 18: 
line 19: " Change syntax for #\( and #\) to string so that paren matching ignores them
line 20: syn match lispString !#\\[\(\)]!
line 21: 
finished sourcing /Users/leostera/.vim/syntax/lisp/slimv-syntax-lisp.vim
continuing in function <SNR>13_SynSet
Searching for "/Users/leostera/.vim/bundle/vundle/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/syntax/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/syntax/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/syntax/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/lisp.vim"
chdir(/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 24: sourcing "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/lisp.vim"
line 1: " Vim syntax file
line 2: " Language:    Lisp
line 3: " Maintainer:  Dr. Charles E. Campbell, Jr. <NdrOchipS@PcampbellAfamily.Mbiz>
line 4: " Last Change: Nov 16, 2010
line 5: " Version:     22
line 6: " URL:^I       http://mysite.verizon.net/astronaut/vim/index.html#vimlinks_syntax
line 7: "
line 8: "  Thanks to F Xavier Noria for a list of 978 Common Lisp symbols
line 9: "  taken from the HyperSpec
line 10: "  Clisp additions courtesy of http://clisp.cvs.sourceforge.net/*checkout*/clisp/clisp/emacs/lisp.vim
line 11: 
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: " For vim-version 5.x: Clear all syntax items
line 15: " For vim-version 6.x: Quit when a syntax file was already loaded
line 16: if version < 600
line 17:   syntax clear
line 18: elseif exists("b:current_syntax")
line 19:   finish
finished sourcing /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/lisp.vim
continuing in function <SNR>13_SynSet
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax/lisp.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/syntax/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/syntax/lisp.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/syntax/lisp/*.vim"
line 25:     endfor
line 23:     for name in split(s, '\.')
line 24:       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 25:     endfor
line 26:   endif
function <SNR>13_SynSet returning #0

continuing in Syntax Auto commands for "*"

Executing FileType Auto commands for "lisp"
autocommand call PareditInitBuffer()

line 0: call PareditInitBuffer()
calling function PareditInitBuffer()

line 1:     let b:paredit_init = 1
line 2:     " in case they are accidentally removed
line 3:     " Also define regular expressions to identify special characters used by paredit
line 4:     if &ft =~ s:fts_balancing_all_brackets
line 5:         let b:any_matched_char   = '(\|)\|\[\|\]\|{\|}\|\"'
line 6:         let b:any_matched_pair   = '()\|\[\]\|{}\|\"\"'
line 7:         let b:any_opening_char   = '(\|\[\|{'
line 8:         let b:any_closing_char   = ')\|\]\|}'
line 9:         let b:any_openclose_char = '(\|)\|\[\|\]\|{\|}'
line 10:         let b:any_wsopen_char    = '\s\|(\|\[\|{'
line 11:         let b:any_wsclose_char   = '\s\|)\|\]\|}'
line 12:     else
line 13:         let b:any_matched_char   = '(\|)\|\"'
line 14:         let b:any_matched_pair   = '()\|\"\"'
line 15:         let b:any_opening_char   = '('
line 16:         let b:any_closing_char   = ')'
line 17:         let b:any_openclose_char = '(\|)'
line 18:         let b:any_wsopen_char    = '\s\|('
line 19:         let b:any_wsclose_char   = '\s\|)'
line 20:     endif
line 21: 
line 22:     if g:paredit_mode
line 23:         " Paredit mode is on: add buffer specific keybindings
line 24:         inoremap <buffer> <expr>   (            PareditInsertOpening('(',')')
line 25:         inoremap <buffer> <silent> )            <C-R>=(pumvisible() ? "\<lt>C-Y>" : "")<CR><C-O>:let save_ve=&ve<CR><C-O>:set ve=all<CR><C-O>:<C-U>call PareditInsertClosing('(',')')<CR><C-O>:let &ve=save_ve<CR>
line 26:         inoremap <buffer> <expr>   "            PareditInsertQuotes()
line 27:         inoremap <buffer> <expr>   <BS>         PareditBackspace(0)
line 28:         inoremap <buffer> <expr>   <C-h>        PareditBackspace(0)
line 29:         inoremap <buffer> <expr>   <Del>        PareditDel()
line 30:         if &ft =~ s:fts_balancing_all_brackets && g:paredit_smartjump
line 31:             noremap  <buffer> <silent> (            :<C-U>call PareditSmartJumpOpening(0)<CR>
line 32:             noremap  <buffer> <silent> )            :<C-U>call PareditSmartJumpClosing(0)<CR>
line 33:             vnoremap <buffer> <silent> (            <Esc>:<C-U>call PareditSmartJumpOpening(1)<CR>
line 34:             vnoremap <buffer> <silent> )            <Esc>:<C-U>call PareditSmartJumpClosing(1)<CR>
line 35:         else
line 36:             noremap  <buffer> <silent> (            :<C-U>call PareditFindOpening('(',')',0)<CR>
line 37:             noremap  <buffer> <silent> )            :<C-U>call PareditFindClosing('(',')',0)<CR>
line 38:             vnoremap <buffer> <silent> (            <Esc>:<C-U>call PareditFindOpening('(',')',1)<CR>
line 39:             vnoremap <buffer> <silent> )            <Esc>:<C-U>call PareditFindClosing('(',')',1)<CR>
line 40:         endif
line 41:         noremap  <buffer> <silent> [[           :<C-U>call PareditFindDefunBck()<CR>
line 42:         noremap  <buffer> <silent> ]]           :<C-U>call PareditFindDefunFwd()<CR>
line 43: 
line 44:         call RepeatableNNoRemap('x', ':<C-U>call PareditEraseFwd()')
calling function PareditInitBuffer..RepeatableNNoRemap('x', ':<C-U>call PareditEraseFwd()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', 'x', ':<C-U>call PareditEraseFwd()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> x :<C-U>call PareditEraseFwd()\|silent! call repeat#set("x")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 45:         nnoremap <buffer> <silent> <Del>        :<C-U>call PareditEraseFwd()<CR>
line 46:         call RepeatableNNoRemap('X', ':<C-U>call PareditEraseBck()')
calling function PareditInitBuffer..RepeatableNNoRemap('X', ':<C-U>call PareditEraseBck()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', 'X', ':<C-U>call PareditEraseBck()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> X :<C-U>call PareditEraseBck()\|silent! call repeat#set("X")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 47:         nnoremap <buffer> <silent> s            :<C-U>call PareditEraseFwd()<CR>i
line 48:         call RepeatableNNoRemap('D', 'v$:<C-U>call PareditDelete(visualmode(),1)')
calling function PareditInitBuffer..RepeatableNNoRemap('D', 'v$:<C-U>call PareditDelete(visualmode(),1)')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', 'D', 'v$:<C-U>call PareditDelete(visualmode(),1)')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> D v$:<C-U>call PareditDelete(visualmode(),1)\|silent! call repeat#set("D")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 49:         nnoremap <buffer> <silent> C            v$:<C-U>call PareditChange(visualmode(),1)<CR>
line 50:         nnoremap <buffer> <silent> d            :<C-U>call PareditSetDelete(v:count)<CR>g@
line 51:         vnoremap <buffer> <silent> d            :<C-U>call PareditDelete(visualmode(),1)<CR>
line 52:         vnoremap <buffer> <silent> x            :<C-U>call PareditDelete(visualmode(),1)<CR>
line 53:         vnoremap <buffer> <silent> <Del>        :<C-U>call PareditDelete(visualmode(),1)<CR>
line 54:         nnoremap <buffer> <silent> c            :set opfunc=PareditChange<CR>g@
line 55:         vnoremap <buffer> <silent> c            :<C-U>call PareditChange(visualmode(),1)<CR>
line 56:         call RepeatableNNoRemap('dd', ':<C-U>call PareditDeleteLines()')
calling function PareditInitBuffer..RepeatableNNoRemap('dd', ':<C-U>call PareditDeleteLines()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', 'dd', ':<C-U>call PareditDeleteLines()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> dd :<C-U>call PareditDeleteLines()\|silent! call repeat#set("dd")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 57:         nnoremap <buffer> <silent> cc           :<C-U>call PareditChangeLines()<CR>
line 58:         nnoremap <buffer> <silent> cw           :<C-U>call PareditChangeSpec('cw',1)<CR>
line 59:         nnoremap <buffer> <silent> cW           :set opfunc=PareditChange<CR>g@E
line 60:         nnoremap <buffer> <silent> cb           :<C-U>call PareditChangeSpec('cb',0)<CR>
line 61:         nnoremap <buffer> <silent> ciw          :<C-U>call PareditChangeSpec('ciw',1)<CR>
line 62:         nnoremap <buffer> <silent> caw          :<C-U>call PareditChangeSpec('caw',1)<CR>
line 63:         call RepeatableNNoRemap('p', ':<C-U>call PareditPut("p")')
calling function PareditInitBuffer..RepeatableNNoRemap('p', ':<C-U>call PareditPut("p")')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', 'p', ':<C-U>call PareditPut("p")')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> p :<C-U>call PareditPut("p")\|silent! call repeat#set("p")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 64:         call RepeatableNNoRemap('P', ':<C-U>call PareditPut("P")')
calling function PareditInitBuffer..RepeatableNNoRemap('P', ':<C-U>call PareditPut("P")')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', 'P', ':<C-U>call PareditPut("P")')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> P :<C-U>call PareditPut("P")\|silent! call repeat#set("P")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 65:         call RepeatableNNoRemap(g:paredit_leader . 'w(', ':<C-U>call PareditWrap("(",")")')
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>w(', ':<C-U>call PareditWrap("(",")")')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>w(', ':<C-U>call PareditWrap("(",")")')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>w( :<C-U>call PareditWrap("(",")")\|silent! call repeat#set("\<leader>w(")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 66:         execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w(  :<C-U>call PareditWrapSelection("(",")")<CR>'
line 66: vnoremap <buffer> <silent> <leader>w(  :<C-U>call PareditWrapSelection("(",")")<CR>
line 67:         call RepeatableNNoRemap(g:paredit_leader . 'w"', ':<C-U>call PareditWrap('."'".'"'."','".'"'."')")
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>w"', ':<C-U>call PareditWrap(''"'',''"'')')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>w"', ':<C-U>call PareditWrap(''"'',''"'')')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>w" :<C-U>call PareditWrap('"','"')\|silent! call repeat#set("\<leader>w\"")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 68:         execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w"  :<C-U>call PareditWrapSelection('."'".'"'."','".'"'."')<CR>"
line 68: vnoremap <buffer> <silent> <leader>w"  :<C-U>call PareditWrapSelection('"','"')<CR>
line 69:         " Spliec s-expression killing backward/forward
line 70:         execute 'nmap     <buffer> <silent> ' . g:paredit_leader.'<Up>    d[(:<C-U>call PareditSplice()<CR>'
line 70: nmap     <buffer> <silent> <leader><Up>    d[(:<C-U>call PareditSplice()<CR>
line 71:         execute 'nmap     <buffer> <silent> ' . g:paredit_leader.'<Down>  d])%:<C-U>call PareditSplice()<CR>'
line 71: nmap     <buffer> <silent> <leader><Down>  d])%:<C-U>call PareditSplice()<CR>
line 72:         call RepeatableNNoRemap(g:paredit_leader . 'I', ':<C-U>call PareditRaise()')
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>I', ':<C-U>call PareditRaise()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>I', ':<C-U>call PareditRaise()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>I :<C-U>call PareditRaise()\|silent! call repeat#set("\<leader>I")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 73:         if &ft =~ s:fts_balancing_all_brackets
line 74:             inoremap <buffer> <expr>   [            PareditInsertOpening('[',']')
line 75:             inoremap <buffer> <silent> ]            <C-R>=(pumvisible() ? "\<lt>C-Y>" : "")<CR><C-O>:let save_ve=&ve<CR><C-O>:set ve=all<CR><C-O>:<C-U>call PareditInsertClosing('[',']')<CR><C-O>:let &ve=save_ve<CR>
line 76:             inoremap <buffer> <expr>   {            PareditInsertOpening('{','}')
line 77:             inoremap <buffer> <silent> }            <C-R>=(pumvisible() ? "\<lt>C-Y>" : "")<CR><C-O>:let save_ve=&ve<CR><C-O>:set ve=all<CR><C-O>:<C-U>call PareditInsertClosing('{','}')<CR><C-O>:let &ve=save_ve<CR>
line 78:             call RepeatableNNoRemap(g:paredit_leader . 'w[', ':<C-U>call PareditWrap("[","]")')
line 79:             execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w[  :<C-U>call PareditWrapSelection("[","]")<CR>'
line 80:             call RepeatableNNoRemap(g:paredit_leader . 'w{', ':<C-U>call PareditWrap("{","}")')
line 81:             execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w{  :<C-U>call PareditWrapSelection("{","}")<CR>'
line 82:         endif
line 83: 
line 84:         if g:paredit_shortmaps
line 85:             " Shorter keymaps: old functionality of KEY is remapped to <Leader>KEY
line 86:             call RepeatableNNoRemap('<', ':<C-U>call PareditMoveLeft()') 
line 87:             call RepeatableNNoRemap('>', ':<C-U>call PareditMoveRight()') 
line 88:             call RepeatableNNoRemap('O', ':<C-U>call PareditSplit()') 
line 89:             call RepeatableNNoRemap('J', ':<C-U>call PareditJoin()') 
line 90:             call RepeatableNNoRemap('W', ':<C-U>call PareditWrap("(",")")') 
line 91:             vnoremap <buffer> <silent> W            :<C-U>call PareditWrapSelection('(',')')<CR>
line 92:             call RepeatableNNoRemap('S', ':<C-U>call PareditSplice()') 
line 93:             execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'<  :<C-U>normal! <<CR>'
line 94:             execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'>  :<C-U>normal! ><CR>'
line 95:             execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'O  :<C-U>normal! O<CR>'
line 96:             execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'J  :<C-U>normal! J<CR>'
line 97:             execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'W  :<C-U>normal! W<CR>'
line 98:             execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'W  :<C-U>normal! W<CR>'
line 99:             execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'S  :<C-U>normal! S<CR>'
line 100:         else
line 101:             " Longer keymaps with <Leader> prefix
line 102:             nnoremap <buffer> <silent> S            V:<C-U>call PareditChange(visualmode(),1)<CR>
line 103:             call RepeatableNNoRemap(g:paredit_leader . '<', ':<C-U>call PareditMoveLeft()') 
calling function PareditInitBuffer..RepeatableNNoRemap('<leader><', ':<C-U>call PareditMoveLeft()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader><', ':<C-U>call PareditMoveLeft()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>< :<C-U>call PareditMoveLeft()\|silent! call repeat#set("\<leader>\<")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 104:             call RepeatableNNoRemap(g:paredit_leader . '>', ':<C-U>call PareditMoveRight()') 
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>>', ':<C-U>call PareditMoveRight()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>>', ':<C-U>call PareditMoveRight()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>> :<C-U>call PareditMoveRight()\|silent! call repeat#set("\<leader>>")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 105:             call RepeatableNNoRemap(g:paredit_leader . 'O', ':<C-U>call PareditSplit()') 
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>O', ':<C-U>call PareditSplit()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>O', ':<C-U>call PareditSplit()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>O :<C-U>call PareditSplit()\|silent! call repeat#set("\<leader>O")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 106:             call RepeatableNNoRemap(g:paredit_leader . 'J', ':<C-U>call PareditJoin()') 
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>J', ':<C-U>call PareditJoin()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>J', ':<C-U>call PareditJoin()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>J :<C-U>call PareditJoin()\|silent! call repeat#set("\<leader>J")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 107:             call RepeatableNNoRemap(g:paredit_leader . 'W', ':<C-U>call PareditWrap("(",")")') 
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>W', ':<C-U>call PareditWrap("(",")")')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>W', ':<C-U>call PareditWrap("(",")")')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>W :<C-U>call PareditWrap("(",")")\|silent! call repeat#set("\<leader>W")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 108:             execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'W  :<C-U>call PareditWrapSelection("(",")")<CR>'
line 108: vnoremap <buffer> <silent> <leader>W  :<C-U>call PareditWrapSelection("(",")")<CR>
line 109:             call RepeatableNNoRemap(g:paredit_leader . 'S', ':<C-U>call PareditSplice()') 
calling function PareditInitBuffer..RepeatableNNoRemap('<leader>S', ':<C-U>call PareditSplice()')

line 1:   call RepeatableMap('nnoremap', a:keys, a:command)
calling function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap('nnoremap', '<leader>S', ':<C-U>call PareditSplice()')

line 1:   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
line 2:   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'
line 2: nnoremap <silent> <buffer> <leader>S :<C-U>call PareditSplice()\|silent! call repeat#set("\<leader>S")<CR>
function PareditInitBuffer..RepeatableNNoRemap..RepeatableMap returning #0

continuing in function PareditInitBuffer..RepeatableNNoRemap

function PareditInitBuffer..RepeatableNNoRemap returning #0

continuing in function PareditInitBuffer

line 110:         endif
line 111: 
line 112:         if g:paredit_electric_return && mapcheck( "<CR>", "i" ) == ""
line 113:             " Do not override any possible mapping for <Enter>
line 114:             inoremap <buffer> <expr>   <CR>         PareditEnter()
line 115:         endif
line 116:     else
line 117:         " Paredit mode is off: remove keybindings
line 118:         silent! iunmap <buffer> (
line 119:         silent! iunmap <buffer> )
line 120:         silent! iunmap <buffer> "
line 121:         silent! iunmap <buffer> <BS>
line 122:         silent! iunmap <buffer> <C-h>
line 123:         silent! iunmap <buffer> <Del>
line 124:         silent! unmap  <buffer> (
line 125:         silent! unmap  <buffer> )
line 126:         silent! unmap  <buffer> [[
line 127:         silent! unmap  <buffer> ]]
line 128:         silent! unmap  <buffer> x
line 129:         silent! unmap  <buffer> <Del>
line 130:         silent! unmap  <buffer> X
line 131:         silent! unmap  <buffer> s
line 132:         silent! unmap  <buffer> D
line 133:         silent! unmap  <buffer> C
line 134:         silent! unmap  <buffer> d
line 135:         silent! unmap  <buffer> c
line 136:         silent! unmap  <buffer> dd
line 137:         silent! unmap  <buffer> cc
line 138:         silent! unmap  <buffer> cw
line 139:         silent! unmap  <buffer> cW
line 140:         silent! unmap  <buffer> cb
line 141:         silent! unmap  <buffer> ciw
line 142:         silent! unmap  <buffer> caw
line 143:         if &ft =~ s:fts_balancing_all_brackets
line 144:             silent! iunmap <buffer> [
line 145:             silent! iunmap <buffer> ]
line 146:             silent! iunmap <buffer> {
line 147:             silent! iunmap <buffer> }
line 148:         endif
line 149:         if mapcheck( "<CR>", "i" ) == "PareditEnter()"
line 150:             " Remove only if we have added this mapping
line 151:             silent! iunmap <buffer> <CR>
line 152:         endif
line 153:     endif
function PareditInitBuffer returning #0

continuing in FileType Auto commands for "lisp"

Executing FileType Auto commands for "*"
autocommand call indent_guides#process_autocmds()

line 0: call indent_guides#process_autocmds()
calling function indent_guides#process_autocmds()

line 1:   if g:indent_guides_autocmds_enabled
line 2:     call indent_guides#enable()
line 3:   else
line 4:     call indent_guides#disable()
calling function indent_guides#process_autocmds..indent_guides#disable()

line 1:   let g:indent_guides_autocmds_enabled = 0
line 2:   call indent_guides#clear_matches()
calling function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches()

line 1:   call indent_guides#init_matches()
calling function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches..indent_guides#init_matches()

line 1:   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []
function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches..indent_guides#init_matches returning #0

continuing in function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches

line 2:   if !empty(w:indent_guides_matches)
line 3:     let l:index = 0
line 4:     for l:match_id in w:indent_guides_matches
line 5:       try
line 6:         call matchdelete(l:match_id)
line 7:       catch /E803:/
line 8:         " Do nothing
line 9:       endtry
line 10:       call remove(w:indent_guides_matches, l:index)
line 11:       let l:index += l:index
line 12:     endfor
line 13:   endif
function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches returning #0

continuing in function indent_guides#process_autocmds..indent_guides#disable

function indent_guides#process_autocmds..indent_guides#disable returning #0

continuing in function indent_guides#process_autocmds

line 5:   end
function indent_guides#process_autocmds returning #0

continuing in FileType Auto commands for "*"

Executing BufRead Auto commands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 0:  runtime! scripts.vim | endif
line 0:  endif
Executing BufRead Auto commands for "*"
autocommand call s:SelectJavascript()

line 0: call s:SelectJavascript()
calling function <SNR>9_SelectJavascript()

line 1:   if getline(1) =~# '^#!.*/bin/env\s\+node\>'
line 2:     set ft=javascript
line 3:   endif
function <SNR>9_SelectJavascript returning #0

continuing in BufRead Auto commands for "*"

autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif
line 0:    setf conf | endif
line 0:  endif
Executing BufRead Auto commands for "*"
autocommand call s:BufReadPostHook()

line 0: call s:BufReadPostHook()
calling function <SNR>29_BufReadPostHook()

line 1:     if g:syntastic_check_on_open
line 2:         call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufReadPost, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
Searching for "autoload/syntastic/log.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Use
Searching for "/Users/leostera/.vim/autoload/syntastic/log.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/syntastic/log.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/syntastic/log.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/syntastic/log.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/syntastic/log.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/syntastic/log.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/syntastic/log.vim"
chdir(/Users/leostera/.vim/bundle/syntastic/autoload/syntastic)
fchdir() to previous dir
line 2: sourcing "/Users/leostera/.vim/bundle/syntastic/autoload/syntastic/log.vim"
line 1: if exists("g:loaded_syntastic_log_autoload") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_log_autoload = 1
line 5: 
line 6: let s:save_cpo = &cpo
line 7: set cpo&vim
line 8: 
line 9: let s:one_time_notices_issued = []
line 10: 
line 11: " Public functions {{{1
line 12: 
line 13: function! syntastic#log#info(msg) " {{{2
line 16: 
line 17: function! syntastic#log#warn(msg) " {{{2
line 22: 
line 23: function! syntastic#log#error(msg) " {{{2
line 29: 
line 30: function! syntastic#log#oneTimeWarn(msg) " {{{2
line 38: 
line 39: " @vimlint(EVL102, 1, l:OLD_VAR)
line 40: function! syntastic#log#deprecationWarn(old, new, ...) " {{{2
line 61: " @vimlint(EVL102, 0, l:OLD_VAR)
line 62: 
line 63: function! syntastic#log#debug(level, msg, ...) " {{{2
line 82: 
line 83: function! syntastic#log#debugShowOptions(level, names) " {{{2
line 98: 
line 99: function! syntastic#log#debugShowVariables(level, names) " {{{2
line 117: 
line 118: function! syntastic#log#debugDump(level) " {{{2
line 125: 
line 126: " }}}1
line 127: 
line 128: " Private functions {{{1
line 129: 
line 130: function! s:_isDebugEnabled_smart(level) " {{{2
line 133: 
line 134: function! s:_isDebugEnabled_dumb(level) " {{{2
line 138: 
line 139: let s:isDebugEnabled = function(exists('*and') ? 's:_isDebugEnabled_smart' : 's:_isDebugEnabled_dumb')
line 140: lockvar s:isDebugEnabled
line 141: 
line 142: function! s:_logRedirect(on) " {{{2
line 156: 
line 157: function! s:_logTimestamp() " {{{2
line 160: 
line 161: function! s:_formatVariable(name) " {{{2
line 172: 
line 173: " }}}1
line 174: 
line 175: let &cpo = s:save_cpo
line 176: unlet s:save_cpo
line 177: 
line 178: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/leostera/.vim/bundle/syntastic/autoload/syntastic/log.vim
continuing in function <SNR>29_BufReadPostHook
calling function <SNR>29_BufReadPostHook..syntastic#log#debug(8, 'autocmd: BufReadPost, buffer 1 = ''test.lisp''')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook

line 4:         call s:UpdateErrors(1)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors(1)

line 1:     call syntastic#log#debugShowVariables(g:SyntasticDebugTrace, 'version')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables(1, 'version')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 2:     call syntastic#log#debugShowOptions(g:SyntasticDebugTrace, s:debug_dump_options)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions(1, ['shell', 'shellcmdflag', 'shellpipe'...elltemp', 'shellxquote', 'shellxescape'])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 3:     call syntastic#log#debugDump(g:SyntasticDebugVariables)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump(16)

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump..<SNR>56__isDebugEnabled_smart(16)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 4:     call syntastic#log#debug(g:SyntasticDebugTrace, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (a:0 ? join(a:000) : 'default checkers'))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debug(1, 'UpdateErrors (auto): default checkers')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 6:     if s:skipFile()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile()

line 1:     let fname = expand('%')
line 2:     let skip = (exists('b:syntastic_skip_checks') ? b:syntastic_skip_checks : 0) || (&buftype != '') || !filereadable(fname) || getwinvar(0, '&diff') || s:ignoreFile(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile..<SNR>29_ignoreFile('test.lisp')

line 1:     let fname = fnamemodify(a:filename, ':p')
line 2:     for pattern in g:syntastic_ignore_files
line 3:         if fname =~# pattern
line 4:             return 1
line 5:         endif
line 6:     endfor
line 7:     return 0
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile..<SNR>29_ignoreFile returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile

line 5:     if skip
line 6:         call syntastic#log#debug(g:SyntasticDebugTrace, 'skipFile: skipping')
line 7:     endif
line 8:     return skip
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 7:         return
line 8:     endif
line 9: 
line 10:     call s:modemap.synch()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..62()

line 1:     if exists('g:syntastic_mode_map')
line 2:         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
line 3:         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
line 4:         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
line 5:     else
line 6:         let self._mode = 'active'
line 7:         let self._activeFiletypes = []
line 8:         let self._passiveFiletypes = []
line 9:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..62 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 11:     let run_checks = !a:auto_invoked || s:modemap.allowsAutoChecking(&filetype)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63('lisp')

line 1:     let fts = split(a:filetype, '\m\.')
line 2: 
line 3:     if self.isPassive()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63..64()

line 1:     return self._mode ==# 'passive'
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63..64 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63

line 4:         return self._isOneFiletypeActive(fts)
line 5:     else
line 6:         return self._noFiletypesArePassive(fts)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63..69(['lisp'])

line 1:     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63..69 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..63 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 12:     if run_checks
line 13:         call s:CacheErrors(a:000)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors([])

line 1:     call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(1, 'CacheErrors: default checkers')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 3:     call s:ClearCache()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache()

line 1:     call s:notifiers.reset(g:SyntasticLoclist.current())
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..36()

line 1:     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
line 2:         let b:syntastic_loclist = g:SyntasticLoclist.New([])
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..36..35([])

line 1:     let newObj = copy(self)
line 2: 
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
line 4: 
line 5:     for e in llist
line 6:         if get(e, 'type', '') == ''
line 7:             let e['type'] = 'E'
line 8:         endif
line 9:     endfor
line 10: 
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16: 
line 17:     return newObj
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..36..35 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..36

line 3:     endif
line 4:     return b:syntastic_loclist
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..36 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: reset')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug(4, 'notifiers: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let b:syntastic_balloons = {}
line 2:     if has('balloon_eval')
line 3:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: reset')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug(4, 'balloons: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9

line 4:         set nobeval
line 5:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if s:has_highlighting
line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: reset')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug(4, 'highlighting: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32

line 3:         call self._reset()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..34()

line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..34 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32

line 4:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: reset')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug(4, 'cursor: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28

line 2:     autocmd! syntastic CursorMoved
line 3:     unlet! b:syntastic_messages
line 4:     let b:syntastic_line = -1
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache

line 2:     call b:syntastic_loclist.destroy()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52()

line 1:     for buf in self.getBuffers()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43()

line 1:     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43..syntastic#util#unique([1])

line 1:     let seen = {}
line 2:     let uniques = []
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 9:     return uniques
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43..syntastic#util#unique returning [1]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43 returning [1]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52

line 2:         call setbufvar(buf, 'syntastic_loclist', {})
line 3:     endfor
line 1:     for buf in self.getBuffers()
line 2:         call setbufvar(buf, 'syntastic_loclist', {})
line 3:     endfor
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 4:     let newLoclist = g:SyntasticLoclist.New([])
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..35([])

line 1:     let newObj = copy(self)
line 2: 
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
line 4: 
line 5:     for e in llist
line 6:         if get(e, 'type', '') == ''
line 7:             let e['type'] = 'E'
line 8:         endif
line 9:     endfor
line 10: 
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16: 
line 17:     return newObj
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..35 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 5: 
line 6:     if !s:skipFile()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile()

line 1:     let fname = expand('%')
line 2:     let skip = (exists('b:syntastic_skip_checks') ? b:syntastic_skip_checks : 0) || (&buftype != '') || !filereadable(fname) || getwinvar(0, '&diff') || s:ignoreFile(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile..<SNR>29_ignoreFile('test.lisp')

line 1:     let fname = fnamemodify(a:filename, ':p')
line 2:     for pattern in g:syntastic_ignore_files
line 3:         if fname =~# pattern
line 4:             return 1
line 5:         endif
line 6:     endfor
line 7:     return 0
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile..<SNR>29_ignoreFile returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile

line 5:     if skip
line 6:         call syntastic#log#debug(g:SyntasticDebugTrace, 'skipFile: skipping')
line 7:     endif
line 8:     return skip
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 7:         " debug logging {{{3
line 8:         call syntastic#log#debugShowVariables(g:SyntasticDebugTrace, 'aggregate_errors')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables(1, 'aggregate_errors')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 9:         call syntastic#log#debug(g:SyntasticDebugTrace, 'getcwd() = ' . getcwd())
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(1, 'getcwd() = /Users/leostera/repos/leostera/lisp-db')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 10:         " }}}3
line 11: 
line 12:         let filetypes = s:resolveFiletypes()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_resolveFiletypes()

line 1:     let type = a:0 ? a:1 : &filetype
line 2:     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_resolveFiletypes returning ['lisp']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 13:         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#util#var('aggregate_errors')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#util#var returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 14:         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
line 15:         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
line 16: 
line 17:         let clist = []
line 18:         for type in filetypes
line 19:             call extend(clist, s:registry.getCheckers(type, a:checker_names))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76('lisp', [])

line 1:     let ft = s:_normaliseFiletype(a:ftalias)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..<SNR>27__normaliseFiletype('lisp')

line 1:     let ft = get(s:defaultFiletypeMap, a:ftalias, a:ftalias)
line 2:     let ft = get(g:syntastic_filetype_map, ft, ft)
line 3:     let ft = substitute(ft, '\m-', '_', 'g')
line 4:     return ft
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..<SNR>27__normaliseFiletype returning 'lisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

line 2:     call self._loadCheckersFor(ft)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..83('lisp')

line 1:     if has_key(self._checkerMap, a:filetype)
line 2:         return
line 3:     endif
line 4: 
line 5:     execute "runtime! syntax_checkers/" . a:filetype . "/*.vim"
line 5: runtime! syntax_checkers/lisp/*.vim
Searching for "syntax_checkers/lisp/*.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Use
Searching for "/Users/leostera/.vim/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/syntax_checkers/lisp/*.vim"
chdir(/Users/leostera/.vim/bundle/syntastic/syntax_checkers/lisp)
fchdir() to previous dir
line 5: sourcing "/Users/leostera/.vim/bundle/syntastic/syntax_checkers/lisp/clisp.vim"
line 1: "============================================================================
line 2: "File:        lisp.vim
line 3: "Description: Syntax checking plugin for syntastic.vim
line 4: "Maintainer:  Karl Yngve Lervåg <karl.yngve@lervag.net>
line 5: "License:     This program is free software. It comes without any warranty,
line 6: "             to the extent permitted by applicable law. You can redistribute
line 7: "             it and/or modify it under the terms of the Do What The Fuck You
line 8: "             Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "             See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: "============================================================================
line 12: 
line 13: if exists("g:loaded_syntastic_lisp_clisp_checker")
line 14:     finish
line 15: endif
line 16: let g:loaded_syntastic_lisp_clisp_checker = 1
line 17: 
line 18: let s:save_cpo = &cpo
line 19: set cpo&vim
line 20: 
line 21: function! SyntaxCheckers_lisp_clisp_GetLocList() dict
line 41: 
line 44: call g:SyntasticRegistry.CreateAndRegisterChecker({ 'filetype': 'lisp', 'name': 'clisp'})
calling function 75({'name': 'clisp', 'filetype': 'lisp'})

line 1:     let checker = g:SyntasticChecker.New(a:args)
calling function 75..10({'name': 'clisp', 'filetype': 'lisp'})

line 1:     let newObj = copy(self)
line 2: 
line 3:     let newObj._filetype = a:args['filetype']
line 4:     let newObj._name = a:args['name']
line 5:     let newObj._exec = get(a:args, 'exec', newObj._name)
line 6:     let newObj._sort = 0
line 7: 
line 8:     if has_key(a:args, 'redirect')
line 9:         let [filetype, name] = split(a:args['redirect'], '/')
line 10:         let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
line 11:     else
line 12:         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
line 13:     endif
line 14: 
line 15:     let newObj._locListFunc = function(prefix . 'GetLocList')
line 16: 
line 17:     if exists('*' . prefix . 'IsAvailable')
line 18:         let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
line 19:     else
line 20:         let newObj._isAvailableFunc = function('SyntasticCheckerIsAvailableDefault')
line 21:     endif
line 22: 
line 23:     if exists('*' . prefix . 'GetHighlightRegex')
line 24:         let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
line 25:     endif
line 26: 
line 27:     return newObj
function 75..10 returning {'_populateHighlightRegexes': functio...rt': 0, 'getLocListRaw': function('15')}

continuing in function 75

line 2:     let registry = g:SyntasticRegistry.Instance()
calling function 75..74()

line 1:     if !exists('s:SyntasticRegistryInstance')
line 2:         let s:SyntasticRegistryInstance = copy(self)
line 3:         let s:SyntasticRegistryInstance._checkerMap = {}
line 4:     endif
line 5: 
line 6:     return s:SyntasticRegistryInstance
function 75..74 returning {'getCheckers': function('76'), 'getC...eateAndRegisterChecker': function('75')}

continuing in function 75

line 3:     call registry._registerChecker(checker)
calling function 75..81({'_populateHighlightRegexes': functio...rt': 0, 'getLocListRaw': function('15')})

line 1:     let ft = a:checker.getFiletype()
calling function 75..81..11()

line 1:     return self._filetype
function 75..81..11 returning 'lisp'

continuing in function 75..81

line 2:     if !has_key(self._checkerMap, ft)
line 3:         let self._checkerMap[ft] = {}
line 4:     endif
line 5: 
line 6:     let name = a:checker.getName()
calling function 75..81..12()

line 1:     return self._name
function 75..81..12 returning 'clisp'

continuing in function 75..81

line 7:     if has_key(self._checkerMap[ft], name)
line 8:         throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
line 9:     endif
line 10: 
line 11:     let self._checkerMap[ft][name] = a:checker
function 75..81 returning #0

continuing in function 75

function 75 returning #0

continuing in /Users/leostera/.vim/bundle/syntastic/syntax_checkers/lisp/clisp.vim

line 45: 
line 46: let &cpo = s:save_cpo
line 47: unlet s:save_cpo
line 48: 
line 49: " vim: set et sts=4 sw=4:
finished sourcing /Users/leostera/.vim/bundle/syntastic/syntax_checkers/lisp/clisp.vim
continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..83
Searching for "/Users/leostera/.vim/bundle/vim-surround/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/syntax_checkers/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/syntax_checkers/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/runtime/syntax_checkers/lisp/*.vim"
Searching for "/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/Vundle.vim/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/vim-multiple-cursors/after/syntax_checkers/lisp/*.vim"
Searching for "/Users/leostera/.vim/bundle/powerline/after/syntax_checkers/lisp/*.vim"
line 6: 
line 7:     if !has_key(self._checkerMap, a:filetype)
line 8:         let self._checkerMap[a:filetype] = {}
line 9:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..83 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

line 3: 
line 4:     let checkers_map = self._checkerMap[ft]
line 5:     if empty(checkers_map)
line 6:         return []
line 7:     endif
line 8: 
line 9:     call self._checkDeprecation(ft)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..84('lisp')

line 1:     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
line 2:         let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
line 3:         call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
line 4:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..84 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

line 10: 
line 11:     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:defaultCheckers, ft, 0)
line 16: 
line 17:     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..82({'clisp': {'_populateHighlightRegexes...t': 0, 'getLocListRaw': function('15')}}, ['clisp'])

line 1:     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..82 returning [{'_populateHighlightRegexes': functi...t': 0, 'getLocListRaw': function('15')}]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76 returning [{'_populateHighlightRegexes': functi...t': 0, 'getLocListRaw': function('15')}]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 20:         endfor
line 18:         for type in filetypes
line 19:             call extend(clist, s:registry.getCheckers(type, a:checker_names))
line 20:         endfor
line 21: 
line 22:         let names = []
line 23:         let unavailable_checkers = 0
line 24:         for checker in clist
line 25:             let cname = checker.getFiletype() . '/' . checker.getName()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..11()

line 1:     return self._filetype
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..11 returning 'lisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..12()

line 1:     return self._name
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..12 returning 'clisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 26:             if !checker.isAvailable()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20()

line 1:     if !has_key(self, '_available')
line 2:         let self._available = self._isAvailableFunc()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20..SyntasticCheckerIsAvailableDefault()

line 1:     return executable(self.getExec())
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20..SyntasticCheckerIsAvailableDefault..13()

line 1:     if exists('g:syntastic_' . self._filetype . '_' . self._name . '_exec')
line 2:         return expand(g:syntastic_{self._filetype}_{self._name}_exec)
line 3:     endif
line 4: 
line 5:     return self._exec
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20..SyntasticCheckerIsAvailableDefault..13 returning 'clisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20..SyntasticCheckerIsAvailableDefault

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20..SyntasticCheckerIsAvailableDefault returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20

line 3:     endif
line 4:     return self._available
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 27:                 call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Checker ' . cname . ' is not available')
line 28:                 let unavailable_checkers += 1
line 29:                 continue
line 30:             endif
line 31: 
line 32:             call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Invoking checker: ' . cname)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(1, 'CacheErrors: Invoking checker: lisp/clisp')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 33: 
line 34:             let loclist = checker.getLocList()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16()

line 1:     return g:SyntasticLoclist.New(self.getLocListRaw())
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15()

line 1:     let name = self._filetype . '/' . self._name
line 2:     try
line 3:         let list = self._locListFunc()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList()

line 1:     let makeprg = self.makeprgBuild({ 'args_after': '-q', 'fname_before': '-c' })
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19({'args_after': '-q', 'fname_before': '-c'})

line 1:     let basename = self._filetype . '_' . self._name . '_'
line 2: 
line 3:     let parts = []
line 4:     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14()

line 1:     return syntastic#util#shescape(self.getExec())
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..13()

line 1:     if exists('g:syntastic_' . self._filetype . '_' . self._name . '_exec')
line 2:         return expand(g:syntastic_{self._filetype}_{self._name}_exec)
line 3:     endif
line 4: 
line 5:     return self._exec
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..13 returning 'clisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..syntastic#util#shescape('clisp')

line 1:     return a:string =~ '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..syntastic#util#shescape returning 'clisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14 returning 'clisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'exe', 'clisp')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_exe', 'clisp')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning 'clisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('clisp')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['clisp']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning ['clisp']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 5:     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'args', '')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_args', '')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning ''

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('-q')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['-q']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning ['-q']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 6:     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand('%')

line 1:     return syntastic#util#shescape(expand(a:string))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand..syntastic#util#shescape('test.lisp')

line 1:     return a:string =~ '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand..syntastic#util#shescape returning 'test.lisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand returning 'test.lisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'fname', 'test.lisp')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('-c')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['-c']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_fname', 'test.lisp')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning 'test.lisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('test.lisp')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['test.lisp']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning ['-c', 'test.lisp']

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 7:     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'post_args', '')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_post_args', '')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning ''

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 8:     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'tail', '')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_tail', '')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning ''

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 9: 
line 10:     return join(parts)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19 returning 'clisp -q -c test.lisp'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList

line 4: 
line 5:     let errorformat  = '%-G;%.%#,' . '%W%>WARNING:%.%# line %l : %m,' . '%Z  %#%m,' . '%W%>WARNING:%.%# lines %l%\%.%\%.%\d%\+ : %m,' . '%Z  %#%m,' . '%E%>The following functions were %m,' . '%Z %m,' . '%-G%.%#'
line 14: 
line 15:     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'defaults': {'bufnr': bufnr('')} })
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake({'errorformat': '%-G;%.%#,%W%>WARNING... 1}, 'makeprg': 'clisp -q -c test.lisp'})

line 1:     call syntastic#log#debug(g:SyntasticDebugTrace, 'SyntasticMake: called with options:', a:options)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug(1, 'SyntasticMake: called with options:', {'errorformat': '%-G;%.%#,%W%>WARNING... 1}, 'makeprg': 'clisp -q -c test.lisp'})

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 2: 
line 3:     " save options and locale env variables {{{3
line 4:     let old_shell = &shell
line 5:     let old_shellredir = &shellredir
line 6:     let old_local_errorformat = &l:errorformat
line 7:     let old_errorformat = &errorformat
line 8:     let old_cwd = getcwd()
line 9:     let old_lc_messages = $LC_MESSAGES
line 10:     let old_lc_all = $LC_ALL
line 11:     " }}}3
line 12: 
line 13:     call s:bashHack()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack()

line 1:     if !exists('s:bash')
line 2:         if !s:running_windows && (s:uname() !~# "FreeBSD") && (s:uname() !~# "OpenBSD")
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack..<SNR>29_uname()

line 1:     if !exists('s:uname')
line 2:         let s:uname = system('uname')
line 3:         lockvar s:uname
line 4:     endif
line 5:     return s:uname
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack..<SNR>29_uname returning 'Darwin^@'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack..<SNR>29_uname()

line 1:     if !exists('s:uname')
line 2:         let s:uname = system('uname')
line 3:         lockvar s:uname
line 4:     endif
line 5:     return s:uname
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack..<SNR>29_uname returning 'Darwin^@'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack

line 3:             let s:bash = executable('/usr/local/bin/bash') ? '/usr/local/bin/bash' : executable('/bin/bash') ? '/bin/bash' : ''
line 6:         else
line 7:             let s:bash = ''
line 8:         endif
line 9:     endif
line 10: 
line 11:     if g:syntastic_bash_hack && s:bash != ''
line 12:         let &shell = s:bash
line 13:         let &shellredir = '&>'
line 14:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 14: 
line 15:     if has_key(a:options, 'errorformat')
line 16:         let &errorformat = a:options['errorformat']
line 17:     endif
line 18: 
line 19:     if has_key(a:options, 'cwd')
line 20:         execute 'lcd ' . fnameescape(a:options['cwd'])
line 21:     endif
line 22: 
line 23:     " set environment variables {{{3
line 24:     let env_save = {}
line 25:     if has_key(a:options, 'env') && len(a:options['env'])
line 26:         for key in keys(a:options['env'])
line 27:             if key =~? '\m^[a-z_]\+$'
line 28:                 exec 'let env_save[' . string(key) . '] = $' . key
line 29:                 exec 'let $' . key . ' = ' . string(a:options['env'][key])
line 30:             endif
line 31:         endfor
line 32:     endif
line 33:     let $LC_MESSAGES = 'C'
line 34:     let $LC_ALL = ''
line 35:     " }}}3
line 36: 
line 37:     let err_lines = split(system(a:options['makeprg']), "\n", 1)
Calling shell to execute: "(clisp -q -c test.lisp) &> /var/folders/zs/xl3rmn054_l6td2l5g20vkc00000gn/T/vf2Zzoe/3"
line 38: 
line 39:     " restore environment variables {{{3
line 40:     let $LC_ALL = old_lc_all
line 41:     let $LC_MESSAGES = old_lc_messages
line 42:     if len(env_save)
line 43:         for key in keys(env_save)
line 44:             exec 'let $' . key . ' = ' . string(env_save[key])
line 45:         endfor
line 46:     endif
line 47:     " }}}3
line 48: 
line 49:     call syntastic#log#debug(g:SyntasticDebugLoclist, 'checker output:', err_lines)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug(2, 'checker output:', [';; Compiling file /Users/leostera/r...b/test.fas', '0 errors, 0 warnings', ''])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 50: 
line 51:     if has_key(a:options, 'Preprocess')
line 52:         let err_lines = call(a:options['Preprocess'], [err_lines])
line 53:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'preprocess (external):', err_lines)
line 54:     elseif has_key(a:options, 'preprocess')
line 55:         let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
line 56:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'preprocess:', err_lines)
line 57:     endif
line 58:     lgetexpr err_lines
line 59: 
line 60:     let errors = deepcopy(getloclist(0))
line 61: 
line 62:     if has_key(a:options, 'cwd')
line 63:         execute 'lcd ' . fnameescape(old_cwd)
line 64:     endif
line 65: 
line 66:     silent! lolder
Error detected while processing function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake:
line   66:
E380: At bottom of quickfix stack
error list 1 of 1; 0 errors
line 67: 
line 68:     " restore options {{{3
line 69:     let &errorformat = old_errorformat
line 70:     let &l:errorformat = old_local_errorformat
line 71:     let &shellredir = old_shellredir
line 72:     let &shell = old_shell
line 73:     " }}}3
line 74: 
line 75:     if !s:running_windows && (s:uname() =~ "FreeBSD" || s:uname() =~ "OpenBSD")
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname()

line 1:     if !exists('s:uname')
line 2:         let s:uname = system('uname')
line 3:         lockvar s:uname
line 4:     endif
line 5:     return s:uname
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname returning 'Darwin^@'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname()

line 1:     if !exists('s:uname')
line 2:         let s:uname = system('uname')
line 3:         lockvar s:uname
line 4:     endif
line 5:     return s:uname
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname returning 'Darwin^@'

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 76:         call syntastic#util#redraw(g:syntastic_full_redraws)
line 77:     endif
line 78: 
line 79:     call syntastic#log#debug(g:SyntasticDebugLoclist, 'raw loclist:', errors)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug(2, 'raw loclist:', [])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 80: 
line 81:     if syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#util#var('exit_checks')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 82:         throw 'Syntastic: checker error'
line 83:     endif
line 84: 
line 85:     if has_key(a:options, 'defaults')
line 86:         call s:addToErrors(errors, a:options['defaults'])
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_addToErrors([], {'bufnr': 1})

line 1:     for err in a:errors
line 2:         for key in keys(a:options)
line 3:             if !has_key(err, key) || empty(err[key])
line 4:                 let err[key] = a:options[key]
line 5:             endif
line 6:         endfor
line 7:     endfor
line 8: 
line 9:     return a:errors
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_addToErrors returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 87:     endif
line 88: 
line 89:     " Add subtype info if present.
line 90:     if has_key(a:options, 'subtype')
line 91:         call s:addToErrors(errors, { 'subtype': a:options['subtype'] })
line 92:     endif
line 93: 
line 94:     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
line 95:         for rule in a:options['Postprocess']
line 96:             let errors = call(rule, [errors])
line 97:         endfor
line 98:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'postprocess (external):', errors)
line 99:     elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
line 100:         for rule in a:options['postprocess']
line 101:             let errors = call('syntastic#postprocess#' . rule, [errors])
line 102:         endfor
line 103:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'postprocess:', errors)
line 104:     endif
line 105: 
line 106:     return errors
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 4:         call syntastic#log#debug(g:SyntasticDebugTrace, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug(1, 'getLocList: checker lisp/clisp returned 0')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 5:     catch /\m\C^Syntastic: checker error$/
line 6:         let list = []
line 7:         call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
line 8:     endtry
line 9:     call self._populateHighlightRegexes(list)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..22([])

line 1:     if has_key(self, '_highlightRegexFunc')
line 2:         for e in a:errors
line 3:             if e['valid']
line 4:                 let term = self._highlightRegexFunc(e)
line 5:                 if term != ''
line 6:                     let e['hl'] = term
line 7:                 endif
line 8:             endif
line 9:         endfor
line 10:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..22 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 10:     call syntastic#log#debug(g:SyntasticDebugLoclist, name . ' raw:', list)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug(2, 'lisp/clisp raw:', [])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 11:     call self._quietMessages(list)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21([])

line 1:     " wildcard quiet_messages
line 2:     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var('quiet_messages', {})

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var returning {}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21

line 3:     if type(quiet_filters) != type({})
line 4:         call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
line 5:         unlet quiet_filters
line 6:         let quiet_filters = {}
line 7:     endif
line 8: 
line 9:     " per checker quiet_messages
line 10:     let name = self._filetype . '_' . self._name
line 11:     try
line 12:         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var('lisp_clisp_quiet_messages', {})

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var returning {}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21

line 13:     catch /\m^Vim\%((\a\+)\)\=:E712/
line 14:         call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
line 15:     endtry
line 16: 
line 17:     call syntastic#log#debug(g:SyntasticDebugLoclist, 'quiet_messages filter:', quiet_filters)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug(2, 'quiet_messages filter:', {})

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21

line 18: 
line 19:     if !empty(quiet_filters)
line 20:         call syntastic#util#dictFilter(a:errors, quiet_filters)
line 21:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'filtered by quiet_messages:', a:errors)
line 22:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 12:     return list
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..35([])

line 1:     let newObj = copy(self)
line 2: 
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
line 4: 
line 5:     for e in llist
line 6:         if get(e, 'type', '') == ''
line 7:             let e['type'] = 'E'
line 8:         endif
line 9:     endfor
line 10: 
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16: 
line 17:     return newObj
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..35 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 35: 
line 36:             if !loclist.isEmpty()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..39 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 37:                 if decorate_errors
line 38:                     call loclist.decorate(cname)
line 39:                 endif
line 40:                 call add(names, cname)
line 41:                 if checker.getWantSort() && !sort_aggregated_errors
line 42:                     call loclist.sort()
line 43:                     call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', loclist)
line 44:                 endif
line 45: 
line 46:                 let newLoclist = newLoclist.extend(loclist)
line 47: 
line 48:                 if !aggregate_errors
line 49:                     break
line 50:                 endif
line 51:             endif
line 52:         endfor
line 24:         for checker in clist
line 25:             let cname = checker.getFiletype() . '/' . checker.getName()
line 26:             if !checker.isAvailable()
line 27:                 call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Checker ' . cname . ' is not available')
line 28:                 let unavailable_checkers += 1
line 29:                 continue
line 30:             endif
line 31: 
line 32:             call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Invoking checker: ' . cname)
line 33: 
line 34:             let loclist = checker.getLocList()
line 35: 
line 36:             if !loclist.isEmpty()
line 37:                 if decorate_errors
line 38:                     call loclist.decorate(cname)
line 39:                 endif
line 40:                 call add(names, cname)
line 41:                 if checker.getWantSort() && !sort_aggregated_errors
line 42:                     call loclist.sort()
line 43:                     call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', loclist)
line 44:                 endif
line 45: 
line 46:                 let newLoclist = newLoclist.extend(loclist)
line 47: 
line 48:                 if !aggregate_errors
line 49:                     break
line 50:                 endif
line 51:             endif
line 52:         endfor
line 53: 
line 54:         " set names {{{3
line 55:         if !empty(names)
line 56:             if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
line 57:                 let type = substitute(names[0], '\m/.*', '', '')
line 58:                 let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
line 59:                 call newLoclist.setName( name . ' ('. type . ')' )
line 60:             else
line 61:                 " checkers from mixed types
line 62:                 call newLoclist.setName(join(names, ', '))
line 63:             endif
line 64:         endif
line 65:         " }}}3
line 66: 
line 67:         " issue warning about no active checkers {{{3
line 68:         if len(clist) == unavailable_checkers
line 69:             if !empty(a:checker_names)
line 70:                 if len(a:checker_names) == 1
line 71:                     call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
line 72:                 else
line 73:                     call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
line 74:                 endif
line 75:             else
line 76:                 call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: no checkers available for ' . &filetype)
line 77:             endif
line 78:         endif
line 79:         " }}}3
line 80: 
line 81:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'aggregated:', newLoclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(2, 'aggregated:', {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 82:         if sort_aggregated_errors
line 83:             call newLoclist.sort()
line 84:             call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', newLoclist)
line 85:         endif
line 86:     endif
line 87: 
line 88:     call newLoclist.deploy()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51()

line 1:     call self.setOwner(bufnr(''))
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..50(1)

line 1:     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..50 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51

line 2:     let self._stamp = syntastic#util#stamp()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..syntastic#util#stamp returning [0, 193578]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51

line 3:     for buf in self.getBuffers()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43()

line 1:     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43..syntastic#util#unique([1])

line 1:     let seen = {}
line 2:     let uniques = []
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 9:     return uniques
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43..syntastic#util#unique returning [1]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43 returning [1]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51

line 4:         call setbufvar(buf, 'syntastic_loclist', self)
line 5:     endfor
line 3:     for buf in self.getBuffers()
line 4:         call setbufvar(buf, 'syntastic_loclist', self)
line 5:     endfor
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 14:     endif
line 15: 
line 16:     let loclist = g:SyntasticLoclist.current()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..36()

line 1:     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
line 2:         let b:syntastic_loclist = g:SyntasticLoclist.New([])
line 3:     endif
line 4:     return b:syntastic_loclist
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..36 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 17: 
line 18:     " populate loclist and jump {{{3
line 19:     let do_jump = syntastic#util#var('auto_jump')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#util#var('auto_jump')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#util#var returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 20:     if do_jump == 2
line 21:         let first = loclist.getFirstIssue()
line 22:         let type = get(first, 'type', '')
line 23:         let do_jump = type ==? 'E'
line 24:     endif
line 25: 
line 26:     let w:syntastic_loclist_set = 0
line 27:     if syntastic#util#var('always_populate_loc_list') || do_jump
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#util#var('always_populate_loc_list')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..syntastic#util#var returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

line 28:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: setloclist (new)')
line 29:         call setloclist(0, loclist.getRaw())
line 30:         let w:syntastic_loclist_set = 1
line 31:         if run_checks && do_jump && !loclist.isEmpty()
line 32:             call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: jump')
line 33:             silent! lrewind
line 34: 
line 35:             " XXX: Vim doesn't call autocmd commands in a predictible
line 36:             " order, which can lead to missing filetype when jumping
line 37:             " to a new file; the following is a workaround for the
line 38:             " resulting brain damage
line 39:             if &filetype == ''
line 40:                 silent! filetype detect
line 41:             endif
line 42:         endif
line 43:     endif
line 44:     " }}}3
line 45: 
line 46:     call s:notifiers.refresh(loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..39 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 2:         " loclist not fully constructed yet
line 3:         return
line 4:     endif
line 5: 
line 6:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: refresh')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug(4, 'notifiers: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..86()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..86..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..86..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..86

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..86 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40([])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
line 4:     endif
line 5:     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi([0, 193578], [])

line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
line 6:         endif
line 7:     endfor
line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'signs: refresh')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug(4, 'signs: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87

line 2:     let old_signs = copy(self._bufSignIds())
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..91()

line 1:     if !exists("b:syntastic_sign_ids")
line 2:         let b:syntastic_sign_ids = []
line 3:     endif
line 4:     return b:syntastic_sign_ids
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..91 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87

line 3:     if self.enabled()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..86()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..86..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..86..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..86

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..86 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87

line 4:         call self._signErrors(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..89({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let loclist = a:loclist
line 2:     if !loclist.isEmpty()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..89..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..89..39 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..89

line 3: 
line 4:         let buf = bufnr('')
line 5:         if !bufloaded(buf)
line 6:             " signs can be placed only in loaded buffers
line 7:             return
line 8:         endif
line 9: 
line 10:         " errors come first, so that they are not masked by warnings
line 11:         let issues = copy(loclist.errors())
line 12:         call extend(issues, loclist.warnings())
line 13:         call filter(issues, 'v:val["bufnr"] == buf')
line 14:         let seen = {}
line 15: 
line 16:         for i in issues
line 17:             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
line 18:                 let seen[i['lnum']] = 1
line 19: 
line 20:                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
line 21:                 let sign_subtype = get(i, 'subtype', '')
line 22:                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
line 23: 
line 24:                 execute "sign place " . s:next_sign_id . " line=" . i['lnum'] . " name=" . sign_type . " buffer=" . i['bufnr']
line 25:                 call add(self._bufSignIds(), s:next_sign_id)
line 26:                 let s:next_sign_id += 1
line 27:             endif
line 28:         endfor
line 29:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..89 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87

line 5:     endif
line 6:     call self._removeSigns(old_signs)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..90([])

line 1:     if has('signs')
line 2:         for s in reverse(copy(a:ids))
line 3:             execute "sign unplace " . s
line 4:             call remove(self._bufSignIds(), index(self._bufSignIds(), s))
line 5:         endfor
line 6:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87..90 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..87 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp returning [0, 195125]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..7()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..7..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..7..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..7

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..7 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40([])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
line 4:     endif
line 5:     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi([0, 193578], [])

line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
line 6:         endif
line 7:     endfor
line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..40 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let b:syntastic_balloons = {}
line 2:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8..7()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8..7..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8..7..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8..7

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8..7 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8..39 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8

line 3:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: refresh')
line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
line 6:         if !empty(issues)
line 7:             for i in issues
line 8:                 if has_key(b:syntastic_balloons, i['lnum'])
line 9:                     let b:syntastic_balloons[i['lnum']] .= "\n" . i['text']
line 10:                 else
line 11:                     let b:syntastic_balloons[i['lnum']] = i['text']
line 12:                 endif
line 13:             endfor
line 14:             set beval bexpr=SyntasticBalloonsExprNotifier()
line 15:         endif
line 16:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..8 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp returning [0, 195722]

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..30()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..30..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..30..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..30

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..30 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if self.enabled()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..30()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..30..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..30..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..30

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..30 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: refresh')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug(4, 'highlighting: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31

line 3:         call self._reset()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..34()

line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..34 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31

line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..41()

line 1:     return copy(self._rawLoclist)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31..41 returning []

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31

line 6:         for item in issues
line 7:             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
line 8: 
line 9:             " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
line 10:             " used to override default highlighting.
line 11:             if has_key(item, 'hl')
line 12:                 call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
line 13:             elseif get(item, 'col', 0)
line 14:                 if get(item, 'vcol', 0)
line 15:                     let lastcol = virtcol([item['lnum'], '$'])
line 16:                     let coltype = 'v'
line 17:                 else
line 18:                     let lastcol = col([item['lnum'], '$'])
line 19:                     let coltype = 'c'
line 20:                 endif
line 21:                 let lcol = min([lastcol, item['col']])
line 22: 
line 23:                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
line 24:             endif
line 25:         endfor
line 26:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..31 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..26()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..26..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..26..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..26

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..26 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27..26()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27..26..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27..26..syntastic#util#var returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27..26

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27..26 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27

calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27..39 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: refresh')
line 3:         let b:syntastic_messages = copy(a:loclist.messages(bufnr('')))
line 4:         let b:syntastic_line = -1
line 5:         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
line 6:         autocmd! syntastic CursorMoved
line 7:         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
line 8:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..27 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: refresh')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug(4, 'autoloclist: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4

line 2:     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: toggle')
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug(4, 'autoloclist: toggle')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug

line 2:         return
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5

line 2:     if !a:loclist.isEmpty()
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..39 returning #1

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5

line 3:         if syntastic#util#var('auto_loc_list') == 1
line 4:             call a:loclist.show()
line 5:         endif
line 6:     else
line 7:         if syntastic#util#var('auto_loc_list') > 0
calling function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#util#var('auto_loc_list')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#util#var returning #2

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5

line 8: 
line 9:             "TODO: this will close the loc list window if one was opened by
line 10:             "something other than syntastic
line 11:             lclose
line 12:         endif
line 13:     endif
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4..5 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71..4 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors..71 returning #0

continuing in function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors

function <SNR>29_BufReadPostHook..<SNR>29_UpdateErrors returning #0

continuing in function <SNR>29_BufReadPostHook

line 5:     endif
function <SNR>29_BufReadPostHook returning #0

continuing in BufRead Auto commands for "*"

Executing BufRead Auto commands for "*"
autocommand call fugitive#detect(expand('<amatch>:p'))

line 0: call fugitive#detect(expand('<amatch>:p'))
calling function fugitive#detect('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
line 2:     unlet b:git_dir
line 3:   endif
line 4:   if !exists('b:git_dir')
line 5:     let dir = fugitive#extract_git_dir(a:path)
calling function fugitive#detect..fugitive#extract_git_dir('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if s:shellslash(a:path) =~# '^fugitive://.*//'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if s:winshell()
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash..<SNR>32_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash..<SNR>32_winshell returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 2:     return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
line 3:   endif
line 4:   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if s:winshell()
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash..<SNR>32_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash..<SNR>32_winshell returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect..fugitive#extract_git_dir..<SNR>32_shellslash returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 5:   let previous = ""
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>32_sub('/Users/leostera/repos/leostera/lisp-db/test.lisp', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..<SNR>32_sub returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 22:       return dir
line 23:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 24:       return resolve(dir)
line 25:     elseif type !=# '' && filereadable(dir)
line 26:       let line = get(readfile(dir, '', 1), 0, '')
line 27:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 28:         return simplify(root.'/'.line[8:-1])
line 29:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 30:         return line[8:-1]
line 31:       endif
line 32:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>32_sub('/Users/leostera/repos/leostera/lisp-db/test.lisp', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>32_sub returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir

line 33:       return root
line 34:     endif
line 35:     let previous = root
line 36:     let root = fnamemodify(root, ':h')
line 37:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>32_sub('/Users/leostera/repos/leostera/lisp-db', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..<SNR>32_sub returning '/Users/leostera/repos/leostera/lisp-db'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir('/Users/leostera/repos/leostera/lisp-db/.git')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>32_sub('/Users/leostera/repos/leostera/lisp-db/.git', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>32_sub returning '/Users/leostera/repos/leostera/lisp-db/.git'

continuing in function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir returning #1

continuing in function fugitive#detect..fugitive#extract_git_dir

line 22:       return dir
function fugitive#detect..fugitive#extract_git_dir returning '/Users/leostera/repos/leostera/lisp-db/.git'

continuing in function fugitive#detect

line 6:     if dir !=# ''
line 7:       let b:git_dir = dir
line 8:     endif
line 9:   endif
line 10:   if exists('b:git_dir')
line 11:     silent doautocmd User FugitiveBoot
No matching autocommands
line 12:     cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
line 13:     nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
line 14:     let buffer = fugitive#buffer()
calling function fugitive#detect..fugitive#buffer()

line 1:   return s:buffer(a:0 ? a:1 : '%')
calling function fugitive#detect..fugitive#buffer..<SNR>32_buffer('%')

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function fugitive#detect..fugitive#buffer..<SNR>32_buffer..<SNR>32_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function fugitive#detect..fugitive#buffer..<SNR>32_buffer..<SNR>32_buffer_getvar returning '/Users/leostera/repos/leostera/lisp-db/.git'

continuing in function fugitive#detect..fugitive#buffer..<SNR>32_buffer

line 4:     return buffer
function fugitive#detect..fugitive#buffer..<SNR>32_buffer returning {'containing_commit': function('<SNR>...'name': function('<SNR>32_buffer_name')}

continuing in function fugitive#detect..fugitive#buffer

function fugitive#detect..fugitive#buffer returning {'containing_commit': function('<SNR>...'name': function('<SNR>32_buffer_name')}

continuing in function fugitive#detect

line 15:     if expand('%:p') =~# '//'
line 16:       call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
line 17:     endif
line 18:     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
calling function fugitive#detect..<SNR>32_buffer_getvar('&tags')

line 1:   return getbufvar(self['#'],a:var)
function fugitive#detect..<SNR>32_buffer_getvar returning './tags,tags'

continuing in function fugitive#detect

line 19:       if filereadable(b:git_dir.'/tags')
line 20:         call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
line 21:       endif
line 22:       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
line 23:         call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
line 24:       endif
line 25:     endif
line 26:     silent doautocmd User Fugitive
Executing User Auto commands for "Fugitive"
autocommand call s:define_commands()

line 0: call s:define_commands()
calling function <SNR>32_define_commands()

line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar Gstatus :execute s:Status()
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RevisionComplete Gmerge execute s:Merge('merge', <bang>0, <q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gpull execute s:Merge('pull --progress', <bang>0, <q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -range -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 3:   endfor
function <SNR>32_define_commands returning #0

continuing in User Auto commands for "Fugitive"

Executing User Auto commands for "Fugitive"
autocommand if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif

line 0: if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
calling function <SNR>32_buffer()

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function <SNR>32_buffer..<SNR>32_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>32_buffer..<SNR>32_buffer_getvar returning '/Users/leostera/repos/leostera/lisp-db/.git'

continuing in function <SNR>32_buffer

line 4:     return buffer
function <SNR>32_buffer returning {'containing_commit': function('<SNR>...'name': function('<SNR>32_buffer_name')}

continuing in User Auto commands for "Fugitive"

calling function <SNR>32_buffer_commit()

line 1:   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')
calling function <SNR>32_buffer_commit..<SNR>32_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>32_buffer_commit..<SNR>32_buffer_spec..<SNR>32_shellslash('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if s:winshell()
calling function <SNR>32_buffer_commit..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>32_buffer_commit..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell returning #0

continuing in function <SNR>32_buffer_commit..<SNR>32_buffer_spec..<SNR>32_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>32_buffer_commit..<SNR>32_buffer_spec..<SNR>32_shellslash returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_commit..<SNR>32_buffer_spec

function <SNR>32_buffer_commit..<SNR>32_buffer_spec returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_commit

function <SNR>32_buffer_commit returning ''

continuing in User Auto commands for "Fugitive"

line 0:  exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 0: command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)
line 0:  exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 0: command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)
line 0:  endif
Executing User Auto commands for "Fugitive"
autocommand if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif

line 0: if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
calling function <SNR>32_buffer()

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function <SNR>32_buffer..<SNR>32_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>32_buffer..<SNR>32_buffer_getvar returning '/Users/leostera/repos/leostera/lisp-db/.git'

continuing in function <SNR>32_buffer

line 4:     return buffer
function <SNR>32_buffer returning {'containing_commit': function('<SNR>...'name': function('<SNR>32_buffer_name')}

continuing in User Auto commands for "Fugitive"

calling function <SNR>32_buffer_type('file', 'blob')

line 1:   if self.getvar('fugitive_type') != ''
calling function <SNR>32_buffer_type..<SNR>32_buffer_getvar('fugitive_type')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>32_buffer_type..<SNR>32_buffer_getvar returning ''

continuing in function <SNR>32_buffer_type

line 2:     let type = self.getvar('fugitive_type')
line 3:   elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if s:winshell()
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell returning #0

continuing in function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_type..<SNR>32_buffer_spec

function <SNR>32_buffer_type..<SNR>32_buffer_spec returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_type

line 4:     let type = 'head'
line 5:   elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
calling function <SNR>32_buffer_type..<SNR>32_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>32_buffer_type..<SNR>32_buffer_getline returning '(defun hello-world (who) (format t who))'

continuing in function <SNR>32_buffer_type

line 6:     let type = 'tree'
line 7:   elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
calling function <SNR>32_buffer_type..<SNR>32_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>32_buffer_type..<SNR>32_buffer_getline returning '(defun hello-world (who) (format t who))'

continuing in function <SNR>32_buffer_type

line 8:     let type = 'tree'
line 9:   elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
calling function <SNR>32_buffer_type..<SNR>32_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>32_buffer_type..<SNR>32_buffer_getline returning '(defun hello-world (who) (format t who))'

continuing in function <SNR>32_buffer_type

line 10:     let type = 'index'
line 11:   elseif isdirectory(self.spec())
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if s:winshell()
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell returning #0

continuing in function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_type..<SNR>32_buffer_spec

function <SNR>32_buffer_type..<SNR>32_buffer_spec returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_type

line 12:     let type = 'directory'
line 13:   elseif self.spec() == ''
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   if s:winshell()
calling function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash..<SNR>32_winshell returning #0

continuing in function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>32_buffer_type..<SNR>32_buffer_spec..<SNR>32_shellslash returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_type..<SNR>32_buffer_spec

function <SNR>32_buffer_type..<SNR>32_buffer_spec returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function <SNR>32_buffer_type

line 14:     let type = 'null'
line 15:   else
line 16:     let type = 'file'
line 17:   endif
line 18:   if a:0
line 19:     return !empty(filter(copy(a:000),'v:val ==# type'))
function <SNR>32_buffer_type returning #1

continuing in User Auto commands for "Fugitive"

line 0:  exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
line 0: command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])
line 0:  endif
Executing User Auto commands for "Fugitive"
autocommand if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif

line 0: if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif
line 0:     set foldtext=fugitive#foldtext() | endif
line 0:  endif
line 27:   endif
function fugitive#detect returning #0

continuing in BufRead Auto commands for "*"

Executing BufRead Auto commands for "*"
autocommand if has_key(s:temp_files,tolower(expand('<afile>:p'))) |   let b:git_dir = s:temp_files[tolower(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif

line 0: if has_key(s:temp_files,tolower(expand('<afile>:p'))) |   let b:git_dir = s:temp_files[tolower(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 0:    let b:git_dir = s:temp_files[tolower(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 0:    let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 0:    let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 0:    call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 0:    setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 0:    nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 0:  endif
Executing BufWinEnter Auto commands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
calling function <SNR>32_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>32_can_diffoff returning #0

continuing in BufWinEnter Auto commands for "*"

line 0:    call s:diffoff() | endif
line 0:  endif
Executing BufEnter Auto commands for "*"
autocommand call indent_guides#process_autocmds()

line 0: call indent_guides#process_autocmds()
calling function indent_guides#process_autocmds()

line 1:   if g:indent_guides_autocmds_enabled
line 2:     call indent_guides#enable()
line 3:   else
line 4:     call indent_guides#disable()
calling function indent_guides#process_autocmds..indent_guides#disable()

line 1:   let g:indent_guides_autocmds_enabled = 0
line 2:   call indent_guides#clear_matches()
calling function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches()

line 1:   call indent_guides#init_matches()
calling function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches..indent_guides#init_matches()

line 1:   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []
function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches..indent_guides#init_matches returning #0

continuing in function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches

line 2:   if !empty(w:indent_guides_matches)
line 3:     let l:index = 0
line 4:     for l:match_id in w:indent_guides_matches
line 5:       try
line 6:         call matchdelete(l:match_id)
line 7:       catch /E803:/
line 8:         " Do nothing
line 9:       endtry
line 10:       call remove(w:indent_guides_matches, l:index)
line 11:       let l:index += l:index
line 12:     endfor
line 13:   endif
function indent_guides#process_autocmds..indent_guides#disable..indent_guides#clear_matches returning #0

continuing in function indent_guides#process_autocmds..indent_guides#disable

function indent_guides#process_autocmds..indent_guides#disable returning #0

continuing in function indent_guides#process_autocmds

line 5:   end
function indent_guides#process_autocmds returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand call s:BufEnterHook()

line 0: call s:BufEnterHook()
calling function <SNR>29_BufEnterHook()

line 1:     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufEnter, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))) . ', &buftype = ' . string(&buftype))
calling function <SNR>29_BufEnterHook..syntastic#log#debug(8, 'autocmd: BufEnter, buffer 1 = ''test.lisp'', &buftype = ''''')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufEnterHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufEnterHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufEnterHook..syntastic#log#debug

line 2:         return
function <SNR>29_BufEnterHook..syntastic#log#debug returning #0

continuing in function <SNR>29_BufEnterHook

line 4:     if &buftype == ''
line 5:         call s:notifiers.refresh(g:SyntasticLoclist.current())
calling function <SNR>29_BufEnterHook..36()

line 1:     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
line 2:         let b:syntastic_loclist = g:SyntasticLoclist.New([])
line 3:     endif
line 4:     return b:syntastic_loclist
function <SNR>29_BufEnterHook..36 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufEnterHook

calling function <SNR>29_BufEnterHook..71({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
calling function <SNR>29_BufEnterHook..71..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufEnterHook..71..39 returning #1

continuing in function <SNR>29_BufEnterHook..71

line 2:         " loclist not fully constructed yet
line 3:         return
line 4:     endif
line 5: 
line 6:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: refresh')
calling function <SNR>29_BufEnterHook..71..syntastic#log#debug(4, 'notifiers: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufEnterHook..71..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufEnterHook..71..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufEnterHook..71..syntastic#log#debug

line 2:         return
function <SNR>29_BufEnterHook..71..syntastic#log#debug returning #0

continuing in function <SNR>29_BufEnterHook..71

line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufEnterHook..71..86()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>29_BufEnterHook..71..86..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..86..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..86

function <SNR>29_BufEnterHook..71..86 returning #1

continuing in function <SNR>29_BufEnterHook..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>29_BufEnterHook..71..40([0, 195125])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
line 4:     endif
line 5:     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
calling function <SNR>29_BufEnterHook..71..40..syntastic#util#compareLexi([0, 193578], [0, 195125])

line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
line 6:         endif
line 7:     endfor
line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
function <SNR>29_BufEnterHook..71..40..syntastic#util#compareLexi returning #-1

continuing in function <SNR>29_BufEnterHook..71..40

function <SNR>29_BufEnterHook..71..40 returning #0

continuing in function <SNR>29_BufEnterHook..71

calling function <SNR>29_BufEnterHook..71..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufEnterHook..71..39 returning #1

continuing in function <SNR>29_BufEnterHook..71

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufEnterHook..71..87({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'signs: refresh')
calling function <SNR>29_BufEnterHook..71..87..syntastic#log#debug(4, 'signs: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufEnterHook..71..87..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufEnterHook..71..87..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufEnterHook..71..87..syntastic#log#debug

line 2:         return
function <SNR>29_BufEnterHook..71..87..syntastic#log#debug returning #0

continuing in function <SNR>29_BufEnterHook..71..87

line 2:     let old_signs = copy(self._bufSignIds())
calling function <SNR>29_BufEnterHook..71..87..91()

line 1:     if !exists("b:syntastic_sign_ids")
line 2:         let b:syntastic_sign_ids = []
line 3:     endif
line 4:     return b:syntastic_sign_ids
function <SNR>29_BufEnterHook..71..87..91 returning []

continuing in function <SNR>29_BufEnterHook..71..87

line 3:     if self.enabled()
calling function <SNR>29_BufEnterHook..71..87..86()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>29_BufEnterHook..71..87..86..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..87..86..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..87..86

function <SNR>29_BufEnterHook..71..87..86 returning #1

continuing in function <SNR>29_BufEnterHook..71..87

line 4:         call self._signErrors(a:loclist)
calling function <SNR>29_BufEnterHook..71..87..89({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let loclist = a:loclist
line 2:     if !loclist.isEmpty()
calling function <SNR>29_BufEnterHook..71..87..89..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufEnterHook..71..87..89..39 returning #1

continuing in function <SNR>29_BufEnterHook..71..87..89

line 3: 
line 4:         let buf = bufnr('')
line 5:         if !bufloaded(buf)
line 6:             " signs can be placed only in loaded buffers
line 7:             return
line 8:         endif
line 9: 
line 10:         " errors come first, so that they are not masked by warnings
line 11:         let issues = copy(loclist.errors())
line 12:         call extend(issues, loclist.warnings())
line 13:         call filter(issues, 'v:val["bufnr"] == buf')
line 14:         let seen = {}
line 15: 
line 16:         for i in issues
line 17:             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
line 18:                 let seen[i['lnum']] = 1
line 19: 
line 20:                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
line 21:                 let sign_subtype = get(i, 'subtype', '')
line 22:                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
line 23: 
line 24:                 execute "sign place " . s:next_sign_id . " line=" . i['lnum'] . " name=" . sign_type . " buffer=" . i['bufnr']
line 25:                 call add(self._bufSignIds(), s:next_sign_id)
line 26:                 let s:next_sign_id += 1
line 27:             endif
line 28:         endfor
line 29:     endif
function <SNR>29_BufEnterHook..71..87..89 returning #0

continuing in function <SNR>29_BufEnterHook..71..87

line 5:     endif
line 6:     call self._removeSigns(old_signs)
calling function <SNR>29_BufEnterHook..71..87..90([])

line 1:     if has('signs')
line 2:         for s in reverse(copy(a:ids))
line 3:             execute "sign unplace " . s
line 4:             call remove(self._bufSignIds(), index(self._bufSignIds(), s))
line 5:         endfor
line 6:     endif
function <SNR>29_BufEnterHook..71..87..90 returning #0

continuing in function <SNR>29_BufEnterHook..71..87

function <SNR>29_BufEnterHook..71..87 returning #0

continuing in function <SNR>29_BufEnterHook..71

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>29_BufEnterHook..71..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufEnterHook..71..syntastic#util#stamp returning [0, 202145]

continuing in function <SNR>29_BufEnterHook..71

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufEnterHook..71..7()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>29_BufEnterHook..71..7..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..7..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..7

function <SNR>29_BufEnterHook..71..7 returning #1

continuing in function <SNR>29_BufEnterHook..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>29_BufEnterHook..71..40([0, 195722])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
line 4:     endif
line 5:     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
calling function <SNR>29_BufEnterHook..71..40..syntastic#util#compareLexi([0, 193578], [0, 195722])

line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
line 6:         endif
line 7:     endfor
line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
function <SNR>29_BufEnterHook..71..40..syntastic#util#compareLexi returning #-1

continuing in function <SNR>29_BufEnterHook..71..40

function <SNR>29_BufEnterHook..71..40 returning #0

continuing in function <SNR>29_BufEnterHook..71

calling function <SNR>29_BufEnterHook..71..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufEnterHook..71..39 returning #1

continuing in function <SNR>29_BufEnterHook..71

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufEnterHook..71..8({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let b:syntastic_balloons = {}
line 2:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>29_BufEnterHook..71..8..7()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>29_BufEnterHook..71..8..7..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..8..7..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..8..7

function <SNR>29_BufEnterHook..71..8..7 returning #1

continuing in function <SNR>29_BufEnterHook..71..8

calling function <SNR>29_BufEnterHook..71..8..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufEnterHook..71..8..39 returning #1

continuing in function <SNR>29_BufEnterHook..71..8

line 3:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: refresh')
line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
line 6:         if !empty(issues)
line 7:             for i in issues
line 8:                 if has_key(b:syntastic_balloons, i['lnum'])
line 9:                     let b:syntastic_balloons[i['lnum']] .= "\n" . i['text']
line 10:                 else
line 11:                     let b:syntastic_balloons[i['lnum']] = i['text']
line 12:                 endif
line 13:             endfor
line 14:             set beval bexpr=SyntasticBalloonsExprNotifier()
line 15:         endif
line 16:     endif
function <SNR>29_BufEnterHook..71..8 returning #0

continuing in function <SNR>29_BufEnterHook..71

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>29_BufEnterHook..71..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufEnterHook..71..syntastic#util#stamp returning [0, 202832]

continuing in function <SNR>29_BufEnterHook..71

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufEnterHook..71..30()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>29_BufEnterHook..71..30..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..30..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..30

function <SNR>29_BufEnterHook..71..30 returning #1

continuing in function <SNR>29_BufEnterHook..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufEnterHook..71..31({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if self.enabled()
calling function <SNR>29_BufEnterHook..71..31..30()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>29_BufEnterHook..71..31..30..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..31..30..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..31..30

function <SNR>29_BufEnterHook..71..31..30 returning #1

continuing in function <SNR>29_BufEnterHook..71..31

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: refresh')
calling function <SNR>29_BufEnterHook..71..31..syntastic#log#debug(4, 'highlighting: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufEnterHook..71..31..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufEnterHook..71..31..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufEnterHook..71..31..syntastic#log#debug

line 2:         return
function <SNR>29_BufEnterHook..71..31..syntastic#log#debug returning #0

continuing in function <SNR>29_BufEnterHook..71..31

line 3:         call self._reset()
calling function <SNR>29_BufEnterHook..71..31..34()

line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
function <SNR>29_BufEnterHook..71..31..34 returning #0

continuing in function <SNR>29_BufEnterHook..71..31

line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
calling function <SNR>29_BufEnterHook..71..31..41()

line 1:     return copy(self._rawLoclist)
function <SNR>29_BufEnterHook..71..31..41 returning []

continuing in function <SNR>29_BufEnterHook..71..31

line 6:         for item in issues
line 7:             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
line 8: 
line 9:             " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
line 10:             " used to override default highlighting.
line 11:             if has_key(item, 'hl')
line 12:                 call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
line 13:             elseif get(item, 'col', 0)
line 14:                 if get(item, 'vcol', 0)
line 15:                     let lastcol = virtcol([item['lnum'], '$'])
line 16:                     let coltype = 'v'
line 17:                 else
line 18:                     let lastcol = col([item['lnum'], '$'])
line 19:                     let coltype = 'c'
line 20:                 endif
line 21:                 let lcol = min([lastcol, item['col']])
line 22: 
line 23:                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
line 24:             endif
line 25:         endfor
line 26:     endif
function <SNR>29_BufEnterHook..71..31 returning #0

continuing in function <SNR>29_BufEnterHook..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufEnterHook..71..26()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>29_BufEnterHook..71..26..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..26..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..26

function <SNR>29_BufEnterHook..71..26 returning #1

continuing in function <SNR>29_BufEnterHook..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufEnterHook..71..27({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>29_BufEnterHook..71..27..26()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>29_BufEnterHook..71..27..26..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..27..26..syntastic#util#var returning #1

continuing in function <SNR>29_BufEnterHook..71..27..26

function <SNR>29_BufEnterHook..71..27..26 returning #1

continuing in function <SNR>29_BufEnterHook..71..27

calling function <SNR>29_BufEnterHook..71..27..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufEnterHook..71..27..39 returning #1

continuing in function <SNR>29_BufEnterHook..71..27

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: refresh')
line 3:         let b:syntastic_messages = copy(a:loclist.messages(bufnr('')))
line 4:         let b:syntastic_line = -1
line 5:         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
line 6:         autocmd! syntastic CursorMoved
line 7:         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
line 8:     endif
function <SNR>29_BufEnterHook..71..27 returning #0

continuing in function <SNR>29_BufEnterHook..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufEnterHook..71..4({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: refresh')
calling function <SNR>29_BufEnterHook..71..4..syntastic#log#debug(4, 'autoloclist: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufEnterHook..71..4..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufEnterHook..71..4..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufEnterHook..71..4..syntastic#log#debug

line 2:         return
function <SNR>29_BufEnterHook..71..4..syntastic#log#debug returning #0

continuing in function <SNR>29_BufEnterHook..71..4

line 2:     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)
calling function <SNR>29_BufEnterHook..71..4..5({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: toggle')
calling function <SNR>29_BufEnterHook..71..4..5..syntastic#log#debug(4, 'autoloclist: toggle')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufEnterHook..71..4..5..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufEnterHook..71..4..5..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufEnterHook..71..4..5..syntastic#log#debug

line 2:         return
function <SNR>29_BufEnterHook..71..4..5..syntastic#log#debug returning #0

continuing in function <SNR>29_BufEnterHook..71..4..5

line 2:     if !a:loclist.isEmpty()
calling function <SNR>29_BufEnterHook..71..4..5..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufEnterHook..71..4..5..39 returning #1

continuing in function <SNR>29_BufEnterHook..71..4..5

line 3:         if syntastic#util#var('auto_loc_list') == 1
line 4:             call a:loclist.show()
line 5:         endif
line 6:     else
line 7:         if syntastic#util#var('auto_loc_list') > 0
calling function <SNR>29_BufEnterHook..71..4..5..syntastic#util#var('auto_loc_list')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufEnterHook..71..4..5..syntastic#util#var returning #2

continuing in function <SNR>29_BufEnterHook..71..4..5

line 8: 
line 9:             "TODO: this will close the loc list window if one was opened by
line 10:             "something other than syntastic
line 11:             lclose
line 12:         endif
line 13:     endif
function <SNR>29_BufEnterHook..71..4..5 returning #0

continuing in function <SNR>29_BufEnterHook..71..4

function <SNR>29_BufEnterHook..71..4 returning #0

continuing in function <SNR>29_BufEnterHook..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
function <SNR>29_BufEnterHook..71 returning #0

continuing in function <SNR>29_BufEnterHook

line 6:     elseif &buftype == 'quickfix'
line 7:         " TODO: this is needed because in recent versions of Vim lclose
line 8:         " can no longer be called from BufWinLeave
line 9:         " TODO: at this point there is no b:syntastic_loclist
line 10:         let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
line 11:         let owner = str2nr(getbufvar(bufnr(""), 'syntastic_owner_buffer'))
line 12:         let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
line 13:         if !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
line 14:             call SyntasticLoclistHide()
line 15:         endif
line 16:     endif
function <SNR>29_BufEnterHook returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand if gettabvar(tabpagenr(), 'gitgutter_didtabenter')|   call settabvar(tabpagenr(), 'gitgutter_didtabenter', 0)| else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif

line 0: if gettabvar(tabpagenr(), 'gitgutter_didtabenter')|   call settabvar(tabpagenr(), 'gitgutter_didtabenter', 0)| else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
line 0:    call settabvar(tabpagenr(), 'gitgutter_didtabenter', 0)| else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
line 0:  else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
line 0:    call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
Searching for "autoload/gitgutter.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users/l
Searching for "/Users/leostera/.vim/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/gitgutter.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim"
chdir(/Users/leostera/.vim/bundle/vim-gitgutter/autoload)
fchdir() to previous dir
line 0: sourcing "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim"
line 1: " Primary functions {{{
line 2: 
line 3: function! gitgutter#all()
line 11: 
line 12: " file: (string) the file to process.
line 13: " realtime: (boolean) when truthy, do a realtime diff; otherwise do a disk-based diff.
line 14: function! gitgutter#process_buffer(file, realtime)
line 45: 
line 46: function! gitgutter#disable()
line 65: 
line 66: function! gitgutter#enable()
line 70: 
line 71: function! gitgutter#toggle()
line 78: 
line 79: " }}}
line 80: 
line 81: " Line highlights {{{
line 82: 
line 83: function! gitgutter#line_highlights_disable()
line 94: 
line 95: function! gitgutter#line_highlights_enable()
line 107: 
line 108: function! gitgutter#line_highlights_toggle()
line 115: 
line 116: " }}}
line 117: 
line 118: " Signs {{{
line 119: 
line 120: function! gitgutter#signs_enable()
line 130: 
line 131: function! gitgutter#signs_disable()
line 140: 
line 141: function! gitgutter#signs_toggle()
line 148: 
line 149: " }}}
line 150: 
line 151: " Hunks {{{
line 152: 
line 153: function! gitgutter#stage_hunk()
line 175: 
line 176: function! gitgutter#revert_hunk()
line 198: 
line 199: function! gitgutter#preview_hunk()
line 226: 
line 227: " }}}
finished sourcing /Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim
continuing in BufEnter Auto commands for "*"
Searching for "autoload/gitgutter/utility.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,
Searching for "/Users/leostera/.vim/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/gitgutter/utility.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim"
chdir(/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 0: sourcing "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim"
line 1: let s:file = ''
line 2: let s:using_xolox_shell = -1
line 3: let s:exit_code = 0
line 4: 
line 5: function! gitgutter#utility#warn(message)
line 11: 
line 12: function! gitgutter#utility#is_active()
line 15: 
line 16: " A replacement for the built-in `shellescape(arg)`.
line 17: "
line 18: " Recent versions of Vim handle shell escaping pretty well.  However older
line 19: " versions aren't as good.  This attempts to do the right thing.
line 20: "
line 21: " See:
line 22: " https://github.com/tpope/vim-fugitive/blob/8f0b8edfbd246c0026b7a2388e1d883d579ac7f6/plugin/fugitive.vim#L29-L37
line 23: function! gitgutter#utility#shellescape(arg)
line 32: 
line 33: function! gitgutter#utility#current_file()
line 36: 
line 37: function! gitgutter#utility#set_file(file)
line 40: 
line 41: function! gitgutter#utility#file()
line 44: 
line 45: function! gitgutter#utility#filename()
line 48: 
line 49: function! gitgutter#utility#directory_of_file()
line 52: 
line 53: function! gitgutter#utility#exists_file()
line 56: 
line 57: function! gitgutter#utility#has_unsaved_changes(file)
line 60: 
line 61: function! gitgutter#utility#has_fresh_changes(file)
line 64: 
line 65: function! gitgutter#utility#save_last_seen_change(file)
line 68: 
line 69: function! gitgutter#utility#buffer_contents()
line 79: 
line 80: function! gitgutter#utility#shell_error()
line 83: 
line 84: function! gitgutter#utility#using_xolox_shell()
line 98: 
line 99: function! gitgutter#utility#system(cmd, ...)
line 113: 
line 114: function! gitgutter#utility#file_relative_to_repo_root()
line 124: 
line 125: function! gitgutter#utility#command_in_directory_of_file(cmd)
line 128: 
line 129: function! gitgutter#utility#highlight_name_for_change(text)
line 142: 
line 143: function! gitgutter#utility#strip_trailing_new_line(line)
finished sourcing /Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim
continuing in BufEnter Auto commands for "*"
calling function gitgutter#utility#current_file()

line 1:   return expand('%:p')
function gitgutter#utility#current_file returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in BufEnter Auto commands for "*"

calling function gitgutter#process_buffer('/Users/leostera/repos/leostera/lisp-db/test.lisp', 0)

line 1:   call gitgutter#utility#set_file(a:file)
calling function gitgutter#process_buffer..gitgutter#utility#set_file('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   let s:file = a:file
function gitgutter#process_buffer..gitgutter#utility#set_file returning #0

continuing in function gitgutter#process_buffer

line 2:   if gitgutter#utility#is_active()
calling function gitgutter#process_buffer..gitgutter#utility#is_active()

line 1:   return g:gitgutter_enabled && gitgutter#utility#exists_file()
calling function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file()

line 1:   return filereadable(gitgutter#utility#file())
calling function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file..gitgutter#utility#file()

line 1:   return s:file
function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file..gitgutter#utility#file returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file

function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file returning #1

continuing in function gitgutter#process_buffer..gitgutter#utility#is_active

function gitgutter#process_buffer..gitgutter#utility#is_active returning #1

continuing in function gitgutter#process_buffer

line 3:     if g:gitgutter_sign_column_always
line 4:       call gitgutter#sign#add_dummy_sign()
line 5:     endif
line 6:     try
line 7:       if !a:realtime || gitgutter#utility#has_fresh_changes(a:file)
line 8:         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(a:file), 1)
calling function gitgutter#process_buffer..gitgutter#utility#has_unsaved_changes('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   return getbufvar(a:file, "&mod")
function gitgutter#process_buffer..gitgutter#utility#has_unsaved_changes returning #0

continuing in function gitgutter#process_buffer

Searching for "autoload/gitgutter/diff.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Us
Searching for "/Users/leostera/.vim/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/gitgutter/diff.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim"
chdir(/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 8: sourcing "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim"
line 1: let s:grep_available = executable('grep')
line 2: let s:grep_command = ' | ' . (g:gitgutter_escape_grep ? '\grep' : 'grep') . ' -e ' . gitgutter#utility#shellescape('^@@ ')
calling function gitgutter#utility#shellescape('^@@ ')

line 1:   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
line 2:     return a:arg
line 3:   elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
calling function gitgutter#utility#shellescape..gitgutter#utility#using_xolox_shell()

line 1:   if s:using_xolox_shell == -1
line 2:     if !g:gitgutter_avoid_cmd_prompt_on_windows
line 3:       let s:using_xolox_shell = 0
line 4:     " Although xolox/vim-shell works on both windows and unix we only want to use
line 5:     " it on windows.
line 6:     elseif has('win32') || has('win64') || has('win32unix')
line 7:       let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
line 8:     else
line 9:       let s:using_xolox_shell = 0
line 10:     endif
line 11:   endif
line 12:   return s:using_xolox_shell
function gitgutter#utility#shellescape..gitgutter#utility#using_xolox_shell returning #0

continuing in function gitgutter#utility#shellescape

line 4:     return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
line 5:   else
line 6:     return shellescape(a:arg)
function gitgutter#utility#shellescape returning '''^@@ '''

continuing in /Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim

line 3: let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
line 4: 
line 5: 
line 6: function! gitgutter#diff#run_diff(realtime, use_external_grep)
line 47: 
line 48: function! gitgutter#diff#parse_diff(diff)
line 58: 
line 59: function! gitgutter#diff#parse_hunk(line)
line 71: 
line 72: function! gitgutter#diff#process_hunks(hunks)
line 80: 
line 81: " Returns [ [<line_number (number)>, <name (string)>], ...]
line 82: function! gitgutter#diff#process_hunk(hunk)
line 114: 
line 115: function! gitgutter#diff#is_added(from_count, to_count)
line 118: 
line 119: function! gitgutter#diff#is_removed(from_count, to_count)
line 122: 
line 123: function! gitgutter#diff#is_modified(from_count, to_count)
line 126: 
line 127: function! gitgutter#diff#is_modified_and_added(from_count, to_count)
line 130: 
line 131: function! gitgutter#diff#is_modified_and_removed(from_count, to_count)
line 134: 
line 135: function! gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
line 143: 
line 144: function! gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
line 151: 
line 152: function! gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
line 160: 
line 161: function! gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
line 174: 
line 175: function! gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
line 184: 
line 185: function! gitgutter#diff#generate_diff_for_hunk(hunk, keep_header)
line 193: 
line 194: function! gitgutter#diff#discard_hunks(diff, hunk_to_keep, keep_header)
finished sourcing /Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim
continuing in function gitgutter#process_buffer
calling function gitgutter#process_buffer..gitgutter#diff#run_diff(0, 1)

line 1:   " Wrap compound command in parentheses to make Windows happy.
line 2:   let cmd = '(git ls-files --error-unmatch ' . gitgutter#utility#shellescape(gitgutter#utility#filename()) . ' && ('
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename()

line 1:   return fnamemodify(s:file, ':t')
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape('test.lisp')

line 1:   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
line 2:     return a:arg
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 3: 
line 4:   if a:realtime
line 5:     let blob_name = ':' . gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
line 6:     let blob_file = tempname()
line 7:     let cmd .= 'git show ' . blob_name . ' > ' . blob_file . ' && diff -U0 ' . g:gitgutter_diff_args . ' ' . blob_file . ' - '
line 9:   else
line 10:     let cmd .= 'git diff --no-ext-diff --no-color -U0 ' . g:gitgutter_diff_args . ' ' . gitgutter#utility#shellescape(gitgutter#utility#filename())
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename()

line 1:   return fnamemodify(s:file, ':t')
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape('test.lisp')

line 1:   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
line 2:     return a:arg
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 11:   endif
line 12: 
line 13:   if a:use_external_grep && s:grep_available
line 14:     let cmd .= s:grep_command
line 15:   endif
line 16: 
line 17:   if (a:use_external_grep && s:grep_available) || a:realtime
line 18:     " grep exits with 1 when no matches are found; diff exits with 1 when
line 19:     " differences are found.  However we want to treat non-matches and
line 20:     " differences as non-erroneous behaviour; so we OR the command with one
line 21:     " which always exits with success (0).
line 22:     let cmd.= ' || exit 0'
line 23:   endif
line 24: 
line 25:   let cmd .= '))'
line 26: 
line 27:   if a:realtime
line 28:     let diff = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(cmd), gitgutter#utility#buffer_contents())
line 29:   else
line 30:     let diff = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(cmd))
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file('(git ls-files --error-unmatch test.l...est.lisp | grep -e ''^@@ '' || exit 0))')

line 1:   return 'cd ' . gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()) . ' && ' . a:cmd
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#directory_of_file()

line 1:   return fnamemodify(s:file, ':h')
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#directory_of_file returning '/Users/leostera/repos/leostera/lisp-db'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#shellescape('/Users/leostera/repos/leostera/lisp-db')

line 1:   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
line 2:     return a:arg
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#shellescape returning '/Users/leostera/repos/leostera/lisp-db'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file

function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file returning 'cd /Users/leostera/repos/leostera/li...est.lisp | grep -e ''^@@ '' || exit 0))'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system('cd /Users/leostera/repos/leostera/li...est.lisp | grep -e ''^@@ '' || exit 0))')

line 1:   if gitgutter#utility#using_xolox_shell()
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system..gitgutter#utility#using_xolox_shell()

line 1:   if s:using_xolox_shell == -1
line 2:     if !g:gitgutter_avoid_cmd_prompt_on_windows
line 3:       let s:using_xolox_shell = 0
line 4:     " Although xolox/vim-shell works on both windows and unix we only want to use
line 5:     " it on windows.
line 6:     elseif has('win32') || has('win64') || has('win32unix')
line 7:       let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
line 8:     else
line 9:       let s:using_xolox_shell = 0
line 10:     endif
line 11:   endif
line 12:   return s:using_xolox_shell
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system..gitgutter#utility#using_xolox_shell returning #0

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system

line 2:     let options = {'command': a:cmd, 'check': 0}
line 3:     if a:0 > 0
line 4:       let options['stdin'] = a:1
line 5:     endif
line 6:     let ret = xolox#misc#os#exec(options)
line 7:     let output = join(ret.stdout, "\n")
line 8:     let s:exit_code = ret.exit_code
line 9:   else
line 10:     let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
Calling shell to execute: "(cd /Users/leostera/repos/leostera/lisp-db && (git ls-files --error-unmatch test.lisp && (git diff --no-ext-diff --no-color -U0  test.lisp | grep -e '^@@ ' || exit 0))) >/var/folders/zs/xl3rmn054_l6td2l5g20vkc00000gn/T/vf2Zzoe/4 2>&1"
line 11:   endif
line 12:   return output
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system returning 'error: pathspec ''test.lisp'' did no... git.^@Did you forget to ''git add''?^@'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 31:   endif
line 32: 
line 33:   if gitgutter#utility#shell_error()
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error()

line 1:   return gitgutter#utility#using_xolox_shell() ? s:exit_code : v:shell_error
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error..gitgutter#utility#using_xolox_shell()

line 1:   if s:using_xolox_shell == -1
line 2:     if !g:gitgutter_avoid_cmd_prompt_on_windows
line 3:       let s:using_xolox_shell = 0
line 4:     " Although xolox/vim-shell works on both windows and unix we only want to use
line 5:     " it on windows.
line 6:     elseif has('win32') || has('win64') || has('win32unix')
line 7:       let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
line 8:     else
line 9:       let s:using_xolox_shell = 0
line 10:     endif
line 11:   endif
line 12:   return s:using_xolox_shell
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error..gitgutter#utility#using_xolox_shell returning #0

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error

function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error returning #1

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 34:     " A shell error indicates the file is not tracked by git (unless something
line 35:     " bizarre is going on).
line 36:     throw 'diff failed'
Exception thrown: diff failed

function gitgutter#process_buffer..gitgutter#diff#run_diff aborted

continuing in function gitgutter#process_buffer

line 9:         call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(diff))
line 10:         let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
line 11: 
line 12:         if len(modified_lines) > g:gitgutter_max_signs
line 13:           call gitgutter#utility#warn('exceeded maximum number of signs (configured by g:gitgutter_max_signs).')
line 14:           call gitgutter#sign#clear_signs(a:file)
line 15:           return
line 16:         endif
line 17: 
line 18:         if g:gitgutter_signs || g:gitgutter_highlight_lines
line 19:           call gitgutter#sign#update_signs(a:file, modified_lines)
line 20:         endif
line 21: 
line 22:         call gitgutter#utility#save_last_seen_change(a:file)
line 23:       endif
line 24:     catch /diff failed/
Exception caught: diff failed

line 25:       call gitgutter#hunk#reset()
Searching for "autoload/gitgutter/hunk.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Us
Searching for "/Users/leostera/.vim/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/gitgutter/hunk.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim"
chdir(/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 25: sourcing "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim"
line 1: " number of lines [added, modified, removed]
line 2: let s:summary = [0, 0, 0]
line 3: let s:hunks = []
line 4: 
line 5: function! gitgutter#hunk#set_hunks(hunks)
line 8: 
line 9: function! gitgutter#hunk#hunks()
line 12: 
line 13: function! gitgutter#hunk#summary()
line 16: 
line 17: function! gitgutter#hunk#reset()
line 20: 
line 21: function! gitgutter#hunk#increment_lines_added(count)
line 24: 
line 25: function! gitgutter#hunk#increment_lines_modified(count)
line 28: 
line 29: function! gitgutter#hunk#increment_lines_removed(count)
line 32: 
line 33: function! gitgutter#hunk#next_hunk(count)
line 48: 
line 49: function! gitgutter#hunk#prev_hunk(count)
line 65: 
line 66: " Returns the hunk the cursor is currently in or 0 if the cursor isn't in a
line 67: " hunk.
line 68: function! gitgutter#hunk#current_hunk()
line 88: 
finished sourcing /Users/leostera/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim
continuing in function gitgutter#process_buffer
calling function gitgutter#process_buffer..gitgutter#hunk#reset()

line 1:   let s:summary = [0, 0, 0]  " TODO: is bling/airline expecting [-1, -1, -1]?
function gitgutter#process_buffer..gitgutter#hunk#reset returning #0

continuing in function gitgutter#process_buffer

line 26:     endtry
Exception finished: diff failed

line 27:   else
line 28:     call gitgutter#hunk#reset()
line 29:   endif
function gitgutter#process_buffer returning #0

continuing in BufEnter Auto commands for "*"

line 0:  endif
Executing BufEnter Auto commands for "*"
autocommand cal s:record(expand('<abuf>', 1))

line 0: cal s:record(expand('<abuf>', 1))
calling function <SNR>36_record('1')

line 1: ^Iif s:locked | retu | en
line 1:  retu | en
line 1:  en
line 2: ^Ilet bufnr = a:bufnr + 0
line 3: ^Ilet bufname = bufname(bufnr)
line 4: ^Iif bufnr > 0 && !empty(bufname)
line 5: ^I^Ical filter(s:mrbs, 'v:val != bufnr')
line 6: ^I^Ical insert(s:mrbs, bufnr)
line 7: ^I^Ical s:addtomrufs(bufname)
calling function <SNR>36_record..<SNR>36_addtomrufs('test.lisp')

line 1: ^Ilet fn = fnamemodify(a:fname, ':p')
line 2: ^Ilet fn = exists('+ssl') ? tr(fn, '/', '\') : fn
line 3: ^Iif ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
line 3:  retu
line 5: ^Ien
line 6: ^Ilet idx = index(s:mrufs, fn, 0, !{s:cseno})
line 7: ^Iif idx
line 8: ^I^Ical filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
line 9: ^I^Ical insert(s:mrufs, fn)
line 10: ^I^Iif {s:soup} && idx < 0
line 11: ^I^I^Ical s:savetofile(s:mergelists())
calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists()

line 1: ^Ilet diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile()

line 1: ^Iif !exists('s:cadir') || !exists('s:cafile')
line 2: ^I^Ilet s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
Searching for "autoload/ctrlp/utils.vim" in "/Users/leostera/.vim,/Users/leostera/.vim/bundle/vundle,/Users/leostera/.vim/bundle/vim-mustache-handlebars,/Users/leostera/.vim/bundle/vim-javascript,/Users/leostera/.vim/bundle/emmet-vim,/Users/leostera/.vim/bundle/vim-indent-guides,/Users/leostera/.vim/bundle/syntastic,/Users/leostera/.vim/bundle/vim-surround,/Users/leostera/.vim/bundle/vim-fugitive,/Users/leostera/.vim/bundle/vim-gitgutter,/Users/leostera/.vim/bundle/ctrlp.vim,/Users/leostera/.vim/bundle/vim-multiple-cursors,/Users/leostera/.vim/bundle/powerline,/Applications/MacVim.app/Contents/Resources/vim/vimfiles,/Applications/MacVim.app/Contents/Resources/vim/runtime,/Applications/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/leostera/.vim/after,/Users/leostera/.vim/bundle/Vundle.vim,/Users/leostera/.vim/bundle/powerline/powerline/bindings/vim,/Users/leostera/.vim/bundle/vundle/after,/Users/leostera/.vim/bundle/vim-mustache-handlebars/after,/Users/leostera/.vim/bundle/vim-javascript/after,/Users
Searching for "/Users/leostera/.vim/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/vundle/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/vim-mustache-handlebars/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/vim-javascript/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/emmet-vim/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/vim-indent-guides/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/syntastic/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/vim-surround/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/vim-fugitive/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/vim-gitgutter/autoload/ctrlp/utils.vim"
Searching for "/Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim"
chdir(/Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp)
fchdir() to previous dir
line 2: sourcing "/Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim"
line 1: " =============================================================================
line 2: " File:          autoload/ctrlp/utils.vim
line 3: " Description:   Utilities
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: 
line 7: " Static variables {{{1
line 8: fu! ctrlp#utils#lash()
line 11: 
line 12: fu! s:lash(...)
line 15: 
line 16: fu! ctrlp#utils#opts()
line 30: cal ctrlp#utils#opts()
calling function ctrlp#utils#opts()

line 1: ^Ilet s:lash = ctrlp#utils#lash()
calling function ctrlp#utils#opts..ctrlp#utils#lash()

line 1: ^Iretu &ssl || !exists('+ssl') ? '/' : '\'
function ctrlp#utils#opts..ctrlp#utils#lash returning '/'

continuing in function ctrlp#utils#opts

line 2: ^Ilet usrhome = $HOME . s:lash( $HOME )
calling function ctrlp#utils#opts..<SNR>62_lash('/Users/leostera')

line 1: ^Iretu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
function ctrlp#utils#opts..<SNR>62_lash returning '/'

continuing in function ctrlp#utils#opts

line 3: ^Ilet cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
line 4: ^Ilet cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
calling function ctrlp#utils#opts..<SNR>62_lash('/Users/leostera/.cache')

line 1: ^Iretu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
function ctrlp#utils#opts..<SNR>62_lash returning '/'

continuing in function ctrlp#utils#opts

line 6: ^Iif exists('g:ctrlp_cache_dir')
line 7: ^I^Ilet cadir = expand(g:ctrlp_cache_dir, 1)
line 8: ^I^Iif isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
line 9: ^I^I^Ilet cadir = cadir.s:lash(cadir).'.ctrlp_cache'
line 10: ^I^Ien
line 11: ^Ien
line 12: ^Ilet s:cache_dir = cadir
function ctrlp#utils#opts returning #0

continuing in /Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim

line 31: 
line 32: let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
line 33: " Files and Directories {{{1
line 34: fu! ctrlp#utils#cachedir()
line 37: 
line 38: fu! ctrlp#utils#cachefile(...)
line 43: 
line 44: fu! ctrlp#utils#readfile(file)
line 55: 
line 56: fu! ctrlp#utils#mkdir(dir)
line 62: 
line 63: fu! ctrlp#utils#writecache(lines, ...)
line 68: 
line 69: fu! ctrlp#utils#glob(...)
line 73: 
line 74: fu! ctrlp#utils#globpath(...)
line 77: 
line 78: fu! ctrlp#utils#fnesc(path, type, ...)
line 108: "}}}
line 109: 
line 110: " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
finished sourcing /Users/leostera/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim
continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile
calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#cachedir()

line 1: ^Iretu s:cache_dir
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#cachedir returning '/Users/leostera/.cache/ctrlp'

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile

calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash()

line 1: ^Iretu &ssl || !exists('+ssl') ? '/' : '\'
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash returning '/'

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile

line 3: ^I^Ilet s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash()

line 1: ^Iretu &ssl || !exists('+ssl') ? '/' : '\'
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash returning '/'

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile

line 4: ^Ien
line 5: ^Iretu s:cafile
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#mrufiles#cachefile returning '/Users/leostera/.cache/ctrlp/mru/cache.txt'

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists

calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#utils#readfile('/Users/leostera/.cache/ctrlp/mru/cache.txt')

line 1: ^Iif filereadable(a:file)
line 2: ^I^Ilet data = readfile(a:file)
line 3: ^I^Iif empty(data) || type(data) != 3
line 4: ^I^I^Iunl data
line 5: ^I^I^Ilet data = []
line 6: ^I^Ien
line 7: ^I^Iretu data
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..ctrlp#utils#readfile returning ['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb']

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists

line 2: ^Ical filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
line 3: ^Ilet mrufs = s:mrufs + diskmrufs
line 4: ^Iretu s:chop(mrufs)
calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..<SNR>36_chop(['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb'])

line 1: ^Iif len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
line 1:  cal remove(a:mrufs, {s:max}, -1) | en
line 1:  en
line 2: ^Iretu a:mrufs
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists..<SNR>36_chop returning ['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb']

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists

function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_mergelists returning ['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb']

continuing in function <SNR>36_record..<SNR>36_addtomrufs

calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile(['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb'])

line 1: ^Ical ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)
calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile..ctrlp#utils#writecache(['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb'], '/Users/leostera/.cache/ctrlp/mru', '/Users/leostera/.cache/ctrlp/mru/cache.txt')

line 1: ^Iif isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
calling function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile..ctrlp#utils#writecache..ctrlp#utils#mkdir('/Users/leostera/.cache/ctrlp/mru')

line 1: ^Iif exists('*mkdir') && !isdirectory(a:dir)
line 2: ^I^Isil! cal mkdir(a:dir, 'p')
line 3: ^Ien
line 4: ^Iretu a:dir
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile..ctrlp#utils#writecache..ctrlp#utils#mkdir returning '/Users/leostera/.cache/ctrlp/mru'

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile..ctrlp#utils#writecache

line 2: ^I^Isil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
line 3: ^Ien
function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile..ctrlp#utils#writecache returning #0

continuing in function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile

function <SNR>36_record..<SNR>36_addtomrufs..<SNR>36_savetofile returning #0

continuing in function <SNR>36_record..<SNR>36_addtomrufs

line 12: ^I^Ien
line 13: ^Ien
function <SNR>36_record..<SNR>36_addtomrufs returning #0

continuing in function <SNR>36_record

line 8: ^Ien
function <SNR>36_record returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

line 0: sil call s:LocalBrowse(expand("<amatch>"))
calling function <SNR>41_LocalBrowse('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4:   
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
function <SNR>41_LocalBrowse returning #0

continuing in BufEnter Auto commands for "*"

Executing VimEnter Auto commands for "*"
autocommand if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif

line 0: if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 0: call fugitive#detect(getcwd())|endif
line 0: endif
Executing VimEnter Auto commands for "*"
autocommand sil call s:VimEnter(expand("<amatch>"))

line 0: sil call s:VimEnter(expand("<amatch>"))
calling function <SNR>41_VimEnter('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
line 2:   let curwin       = winnr()
line 3:   let s:vimentered = 1
line 4:   windo call s:LocalBrowse(expand("%:p"))
line 4: call s:LocalBrowse(expand("%:p"))
calling function <SNR>41_VimEnter..<SNR>41_LocalBrowse('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4:   
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
line 11:   endif
line 12: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
line 15:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt")
line 23:      exe w:netrw_bannercnt
line 24:     endif
line 25:    endif
line 26: 
line 27:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    sil! call netrw#LocalBrowseCheck(a:dirname)
line 31:    if exists("w:netrw_bannercnt")
line 32:     exe w:netrw_bannercnt
line 33:    endif
line 34: 
line 35:   else
line 36:    " not a directory, ignore it
line 37: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 38:   endif
line 39: 
line 40: "  call Dret("s:LocalBrowse")
function <SNR>41_VimEnter..<SNR>41_LocalBrowse returning #0

continuing in function <SNR>41_VimEnter

line 5:   exe curwin."wincmd w"
line 5: 1wincmd w
line 6: "  call Dret("s:VimEnter")
function <SNR>41_VimEnter returning #0

continuing in VimEnter Auto commands for "*"

Executing CursorMoved Auto commands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>40_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     3match none
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let c = getline(c_lnum)[c_col - 1]
line 19:   let plist = split(&matchpairs, '.\zs[:,]')
line 20:   let i = index(plist, c)
line 21:   if i < 0
line 22:     " not found, in Insert mode try character before the cursor
line 23:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 24:       let before = 1
line 25:       let c = getline(c_lnum)[c_col - 2]
line 26:       let i = index(plist, c)
line 27:     endif
line 28:     if i < 0
line 29:       " not found, nothing to do
line 30:       return
line 31:     endif
line 32:   endif
line 33: 
line 34:   " Figure out the arguments for searchpairpos().
line 35:   if i % 2 == 0
line 36:     let s_flags = 'nW'
line 37:     let c2 = plist[i + 1]
line 38:   else
line 39:     let s_flags = 'nbW'
line 40:     let c2 = c
line 41:     let c = plist[i - 1]
line 42:   endif
line 43:   if c == '['
line 44:     let c = '\['
line 45:     let c2 = '\]'
line 46:   endif
line 47: 
line 48:   " Find the match.  When it was just before the cursor move it there for a
line 49:   " moment.
line 50:   if before > 0
line 51:     let save_cursor = winsaveview()
line 52:     call cursor(c_lnum, c_col - before)
line 53:   endif
line 54: 
line 55:   " When not in a string or comment ignore matches inside them.
line 56:   " We match "escape" for special items, such as lispEscapeSpecial.
line 57:   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
line 59:   execute 'if' s_skip '| let s_skip = 0 | endif'
line 59: if synIDattr(synID(line("."), col("."), 0), "name") =~?  "string\\|character\\|singlequote\\|escape\\|comment" | let s_skip = 0 | endif
line 59:  let s_skip = 0 | endif
line 59:  endif
line 60: 
line 61:   " Limit the search to lines visible in the window.
line 62:   let stoplinebottom = line('w$')
line 63:   let stoplinetop = line('w0')
line 64:   if i % 2 == 0
line 65:     let stopline = stoplinebottom
line 66:   else
line 67:     let stopline = stoplinetop
line 68:   endif
line 69: 
line 70:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 71:   " This fails when a timeout is not supported.
line 72:   if mode() == 'i' || mode() == 'R'
line 73:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 74:   else
line 75:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 76:   endif
line 77:   try
line 78:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 79:   catch /E118/
line 80:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 81:     " a long time on closed folds and long lines.
line 82:     " The "viewable" variables give a range in which we can scroll while
line 83:     " keeping the cursor at the same position.
line 84:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 85:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 86:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 87:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 88:     " one of these stoplines will be adjusted below, but the current values are
line 89:     " minimal boundaries within the current window
line 90:     if i % 2 == 0
line 91:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 92: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 93: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 94:       else
line 95: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 96:       endif
line 97:       let stoplinebottom = stopline
line 98:     else
line 99:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 100: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 101: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 102:       else
line 103: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 104:       endif
line 105:       let stoplinetop = stopline
line 106:     endif
line 107:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 108:   endtry
line 109: 
line 110:   if before > 0
line 111:     call winrestview(save_cursor)
line 112:   endif
line 113: 
line 114:   " If a match is found setup match highlighting.
line 115:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 116:     exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 116: 3match MatchParen /\(\%1l\%1c\)\|\(\%1l\%40c\)/
line 118:     let w:paren_hl_on = 1
line 119:   endif
function <SNR>40_Highlight_Matching_Pair returning #0

continuing in CursorMoved Auto commands for "*"

calling function 36()

line 1:     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
line 2:         let b:syntastic_loclist = g:SyntasticLoclist.New([])
line 3:     endif
line 4:     return b:syntastic_loclist
function 36 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

calling function 56()

line 1:     return !self.isEmpty()
calling function 56..39()

line 1:     return empty(self._rawLoclist)
function 56..39 returning #1

continuing in function 56

function 56 returning #0


Executing QuitPre Auto commands for "*"
autocommand call s:QuitPreHook()

line 0: call s:QuitPreHook()
calling function <SNR>29_QuitPreHook()

line 1:     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: QuitPre, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
calling function <SNR>29_QuitPreHook..syntastic#log#debug(8, 'autocmd: QuitPre, buffer 1 = ''test.lisp''')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_QuitPreHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_QuitPreHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_QuitPreHook..syntastic#log#debug

line 2:         return
function <SNR>29_QuitPreHook..syntastic#log#debug returning #0

continuing in function <SNR>29_QuitPreHook

line 3:     let b:syntastic_skip_checks = !g:syntastic_check_on_wq
line 4:     call SyntasticLoclistHide()
calling function <SNR>29_QuitPreHook..SyntasticLoclistHide()

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: hide')
calling function <SNR>29_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug(4, 'loclist: hide')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug

line 2:         return
function <SNR>29_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug returning #0

continuing in function <SNR>29_QuitPreHook..SyntasticLoclistHide

line 2:     silent! lclose
function <SNR>29_QuitPreHook..SyntasticLoclistHide returning #0

continuing in function <SNR>29_QuitPreHook

function <SNR>29_QuitPreHook returning #0

continuing in QuitPre Auto commands for "*"

"test.lisp" 
"test.lisp" 1L, 41C written
Executing BufWritePost Auto commands for "*"
autocommand call s:BufWritePostHook()

line 0: call s:BufWritePostHook()
calling function <SNR>29_BufWritePostHook()

line 1:     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufWritePost, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
calling function <SNR>29_BufWritePostHook..syntastic#log#debug(8, 'autocmd: BufWritePost, buffer 1 = ''test.lisp''')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook

line 3:     call s:UpdateErrors(1)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors(1)

line 1:     call syntastic#log#debugShowVariables(g:SyntasticDebugTrace, 'version')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables(1, 'version')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowVariables returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 2:     call syntastic#log#debugShowOptions(g:SyntasticDebugTrace, s:debug_dump_options)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions(1, ['shell', 'shellcmdflag', 'shellpipe'...elltemp', 'shellxquote', 'shellxescape'])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugShowOptions returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 3:     call syntastic#log#debugDump(g:SyntasticDebugVariables)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump(16)

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump..<SNR>56__isDebugEnabled_smart(16)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debugDump returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 4:     call syntastic#log#debug(g:SyntasticDebugTrace, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (a:0 ? join(a:000) : 'default checkers'))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debug(1, 'UpdateErrors (auto): default checkers')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 6:     if s:skipFile()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile()

line 1:     let fname = expand('%')
line 2:     let skip = (exists('b:syntastic_skip_checks') ? b:syntastic_skip_checks : 0) || (&buftype != '') || !filereadable(fname) || getwinvar(0, '&diff') || s:ignoreFile(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile..<SNR>29_ignoreFile('test.lisp')

line 1:     let fname = fnamemodify(a:filename, ':p')
line 2:     for pattern in g:syntastic_ignore_files
line 3:         if fname =~# pattern
line 4:             return 1
line 5:         endif
line 6:     endfor
line 7:     return 0
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile..<SNR>29_ignoreFile returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile

line 5:     if skip
line 6:         call syntastic#log#debug(g:SyntasticDebugTrace, 'skipFile: skipping')
line 7:     endif
line 8:     return skip
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_skipFile returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 7:         return
line 8:     endif
line 9: 
line 10:     call s:modemap.synch()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..62()

line 1:     if exists('g:syntastic_mode_map')
line 2:         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
line 3:         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
line 4:         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
line 5:     else
line 6:         let self._mode = 'active'
line 7:         let self._activeFiletypes = []
line 8:         let self._passiveFiletypes = []
line 9:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..62 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 11:     let run_checks = !a:auto_invoked || s:modemap.allowsAutoChecking(&filetype)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63('lisp')

line 1:     let fts = split(a:filetype, '\m\.')
line 2: 
line 3:     if self.isPassive()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63..64()

line 1:     return self._mode ==# 'passive'
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63..64 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63

line 4:         return self._isOneFiletypeActive(fts)
line 5:     else
line 6:         return self._noFiletypesArePassive(fts)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63..69(['lisp'])

line 1:     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63..69 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..63 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 12:     if run_checks
line 13:         call s:CacheErrors(a:000)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors([])

line 1:     call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(1, 'CacheErrors: default checkers')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 3:     call s:ClearCache()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache()

line 1:     call s:notifiers.reset(g:SyntasticLoclist.current())
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..36()

line 1:     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
line 2:         let b:syntastic_loclist = g:SyntasticLoclist.New([])
line 3:     endif
line 4:     return b:syntastic_loclist
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..36 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: reset')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug(4, 'notifiers: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let b:syntastic_balloons = {}
line 2:     if has('balloon_eval')
line 3:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: reset')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug(4, 'balloons: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9

line 4:         set nobeval
line 5:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..9 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if s:has_highlighting
line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: reset')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug(4, 'highlighting: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32

line 3:         call self._reset()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..34()

line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32..34 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32

line 4:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..32 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: reset')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug(4, 'cursor: reset')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28

line 2:     autocmd! syntastic CursorMoved
line 3:     unlet! b:syntastic_messages
line 4:     let b:syntastic_line = -1
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72..28 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72

line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
line 2:     for type in self._enabled_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4: 
line 5:         " reset notifiers regardless if they are enabled or not, since
line 6:         " the user might have disabled them since the last refresh();
line 7:         " notifiers MUST be prepared to deal with reset() when disabled
line 8:         if has_key(g:{class}, 'reset')
line 9:             call self._notifier[type].reset(a:loclist)
line 10:         endif
line 11: 
line 12:         " also reset stamps
line 13:         if index(s:persistent_notifiers, type) > -1
line 14:             let b:syntastic_{type}_stamp = []
line 15:         endif
line 16:     endfor
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..72 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache

line 2:     call b:syntastic_loclist.destroy()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52()

line 1:     for buf in self.getBuffers()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43()

line 1:     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43..syntastic#util#unique([1])

line 1:     let seen = {}
line 2:     let uniques = []
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 9:     return uniques
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43..syntastic#util#unique returning [1]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52..43 returning [1]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52

line 2:         call setbufvar(buf, 'syntastic_loclist', {})
line 3:     endfor
line 1:     for buf in self.getBuffers()
line 2:         call setbufvar(buf, 'syntastic_loclist', {})
line 3:     endfor
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache..52 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_ClearCache returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 4:     let newLoclist = g:SyntasticLoclist.New([])
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..35([])

line 1:     let newObj = copy(self)
line 2: 
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
line 4: 
line 5:     for e in llist
line 6:         if get(e, 'type', '') == ''
line 7:             let e['type'] = 'E'
line 8:         endif
line 9:     endfor
line 10: 
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16: 
line 17:     return newObj
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..35 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 5: 
line 6:     if !s:skipFile()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile()

line 1:     let fname = expand('%')
line 2:     let skip = (exists('b:syntastic_skip_checks') ? b:syntastic_skip_checks : 0) || (&buftype != '') || !filereadable(fname) || getwinvar(0, '&diff') || s:ignoreFile(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile..<SNR>29_ignoreFile('test.lisp')

line 1:     let fname = fnamemodify(a:filename, ':p')
line 2:     for pattern in g:syntastic_ignore_files
line 3:         if fname =~# pattern
line 4:             return 1
line 5:         endif
line 6:     endfor
line 7:     return 0
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile..<SNR>29_ignoreFile returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile

line 5:     if skip
line 6:         call syntastic#log#debug(g:SyntasticDebugTrace, 'skipFile: skipping')
line 7:     endif
line 8:     return skip
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_skipFile returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 7:         " debug logging {{{3
line 8:         call syntastic#log#debugShowVariables(g:SyntasticDebugTrace, 'aggregate_errors')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables(1, 'aggregate_errors')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debugShowVariables returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 9:         call syntastic#log#debug(g:SyntasticDebugTrace, 'getcwd() = ' . getcwd())
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(1, 'getcwd() = /Users/leostera/repos/leostera/lisp-db')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 10:         " }}}3
line 11: 
line 12:         let filetypes = s:resolveFiletypes()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_resolveFiletypes()

line 1:     let type = a:0 ? a:1 : &filetype
line 2:     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..<SNR>29_resolveFiletypes returning ['lisp']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 13:         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#util#var('aggregate_errors')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#util#var returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 14:         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
line 15:         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
line 16: 
line 17:         let clist = []
line 18:         for type in filetypes
line 19:             call extend(clist, s:registry.getCheckers(type, a:checker_names))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76('lisp', [])

line 1:     let ft = s:_normaliseFiletype(a:ftalias)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..<SNR>27__normaliseFiletype('lisp')

line 1:     let ft = get(s:defaultFiletypeMap, a:ftalias, a:ftalias)
line 2:     let ft = get(g:syntastic_filetype_map, ft, ft)
line 3:     let ft = substitute(ft, '\m-', '_', 'g')
line 4:     return ft
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..<SNR>27__normaliseFiletype returning 'lisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

line 2:     call self._loadCheckersFor(ft)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..83('lisp')

line 1:     if has_key(self._checkerMap, a:filetype)
line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..83 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

line 3: 
line 4:     let checkers_map = self._checkerMap[ft]
line 5:     if empty(checkers_map)
line 6:         return []
line 7:     endif
line 8: 
line 9:     call self._checkDeprecation(ft)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..84('lisp')

line 1:     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
line 2:         let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
line 3:         call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
line 4:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..84 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

line 10: 
line 11:     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:defaultCheckers, ft, 0)
line 16: 
line 17:     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..82({'clisp': {'_populateHighlightRegexes...t': 0, 'getLocListRaw': function('15')}}, ['clisp'])

line 1:     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76..82 returning [{'_populateHighlightRegexes': functi...t': 0, 'getLocListRaw': function('15')}]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..76 returning [{'_populateHighlightRegexes': functi...t': 0, 'getLocListRaw': function('15')}]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 20:         endfor
line 18:         for type in filetypes
line 19:             call extend(clist, s:registry.getCheckers(type, a:checker_names))
line 20:         endfor
line 21: 
line 22:         let names = []
line 23:         let unavailable_checkers = 0
line 24:         for checker in clist
line 25:             let cname = checker.getFiletype() . '/' . checker.getName()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..11()

line 1:     return self._filetype
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..11 returning 'lisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..12()

line 1:     return self._name
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..12 returning 'clisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 26:             if !checker.isAvailable()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20()

line 1:     if !has_key(self, '_available')
line 2:         let self._available = self._isAvailableFunc()
line 3:     endif
line 4:     return self._available
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..20 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 27:                 call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Checker ' . cname . ' is not available')
line 28:                 let unavailable_checkers += 1
line 29:                 continue
line 30:             endif
line 31: 
line 32:             call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Invoking checker: ' . cname)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(1, 'CacheErrors: Invoking checker: lisp/clisp')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 33: 
line 34:             let loclist = checker.getLocList()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16()

line 1:     return g:SyntasticLoclist.New(self.getLocListRaw())
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15()

line 1:     let name = self._filetype . '/' . self._name
line 2:     try
line 3:         let list = self._locListFunc()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList()

line 1:     let makeprg = self.makeprgBuild({ 'args_after': '-q', 'fname_before': '-c' })
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19({'args_after': '-q', 'fname_before': '-c'})

line 1:     let basename = self._filetype . '_' . self._name . '_'
line 2: 
line 3:     let parts = []
line 4:     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14()

line 1:     return syntastic#util#shescape(self.getExec())
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..13()

line 1:     if exists('g:syntastic_' . self._filetype . '_' . self._name . '_exec')
line 2:         return expand(g:syntastic_{self._filetype}_{self._name}_exec)
line 3:     endif
line 4: 
line 5:     return self._exec
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..13 returning 'clisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..syntastic#util#shescape('clisp')

line 1:     return a:string =~ '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14..syntastic#util#shescape returning 'clisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..14 returning 'clisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'exe', 'clisp')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_exe', 'clisp')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning 'clisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('clisp')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['clisp']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning ['clisp']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 5:     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'args', '')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_args', '')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning ''

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('-q')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['-q']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning ['-q']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 6:     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand('%')

line 1:     return syntastic#util#shescape(expand(a:string))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand..syntastic#util#shescape('test.lisp')

line 1:     return a:string =~ '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand..syntastic#util#shescape returning 'test.lisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..syntastic#util#shexpand returning 'test.lisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'fname', 'test.lisp')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('-c')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['-c']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_fname', 'test.lisp')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning 'test.lisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('test.lisp')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning ['test.lisp']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning ['-c', 'test.lisp']

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 7:     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'post_args', '')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_post_args', '')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning ''

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 8:     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23({'args_after': '-q', 'fname_before': '-c'}, 'lisp_clisp_', 'tail', '')

line 1:     let ret = []
line 2:     call extend( ret, self._shescape(get(a:opts, a:name . '_before', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 3:     call extend( ret, self._shescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var('lisp_clisp_tail', '')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..syntastic#util#var returning ''

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 4:     call extend( ret, self._shescape(get(a:opts, a:name . '_after', '')) )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24('')

line 1:     if type(a:opt) == type('') && a:opt != ''
line 2:         return [a:opt]
line 3:     elseif type(a:opt) == type([])
line 4:         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
line 5:     endif
line 6: 
line 7:     return []
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23..24 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23

line 5: 
line 6:     return ret
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19..23 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19

line 9: 
line 10:     return join(parts)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..19 returning 'clisp -q -c test.lisp'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList

line 4: 
line 5:     let errorformat  = '%-G;%.%#,' . '%W%>WARNING:%.%# line %l : %m,' . '%Z  %#%m,' . '%W%>WARNING:%.%# lines %l%\%.%\%.%\d%\+ : %m,' . '%Z  %#%m,' . '%E%>The following functions were %m,' . '%Z %m,' . '%-G%.%#'
line 14: 
line 15:     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'defaults': {'bufnr': bufnr('')} })
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake({'errorformat': '%-G;%.%#,%W%>WARNING... 1}, 'makeprg': 'clisp -q -c test.lisp'})

line 1:     call syntastic#log#debug(g:SyntasticDebugTrace, 'SyntasticMake: called with options:', a:options)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug(1, 'SyntasticMake: called with options:', {'errorformat': '%-G;%.%#,%W%>WARNING... 1}, 'makeprg': 'clisp -q -c test.lisp'})

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 2: 
line 3:     " save options and locale env variables {{{3
line 4:     let old_shell = &shell
line 5:     let old_shellredir = &shellredir
line 6:     let old_local_errorformat = &l:errorformat
line 7:     let old_errorformat = &errorformat
line 8:     let old_cwd = getcwd()
line 9:     let old_lc_messages = $LC_MESSAGES
line 10:     let old_lc_all = $LC_ALL
line 11:     " }}}3
line 12: 
line 13:     call s:bashHack()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack()

line 1:     if !exists('s:bash')
line 2:         if !s:running_windows && (s:uname() !~# "FreeBSD") && (s:uname() !~# "OpenBSD")
line 3:             let s:bash = executable('/usr/local/bin/bash') ? '/usr/local/bin/bash' : executable('/bin/bash') ? '/bin/bash' : ''
line 6:         else
line 7:             let s:bash = ''
line 8:         endif
line 9:     endif
line 10: 
line 11:     if g:syntastic_bash_hack && s:bash != ''
line 12:         let &shell = s:bash
line 13:         let &shellredir = '&>'
line 14:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_bashHack returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 14: 
line 15:     if has_key(a:options, 'errorformat')
line 16:         let &errorformat = a:options['errorformat']
line 17:     endif
line 18: 
line 19:     if has_key(a:options, 'cwd')
line 20:         execute 'lcd ' . fnameescape(a:options['cwd'])
line 21:     endif
line 22: 
line 23:     " set environment variables {{{3
line 24:     let env_save = {}
line 25:     if has_key(a:options, 'env') && len(a:options['env'])
line 26:         for key in keys(a:options['env'])
line 27:             if key =~? '\m^[a-z_]\+$'
line 28:                 exec 'let env_save[' . string(key) . '] = $' . key
line 29:                 exec 'let $' . key . ' = ' . string(a:options['env'][key])
line 30:             endif
line 31:         endfor
line 32:     endif
line 33:     let $LC_MESSAGES = 'C'
line 34:     let $LC_ALL = ''
line 35:     " }}}3
line 36: 
line 37:     let err_lines = split(system(a:options['makeprg']), "\n", 1)
Calling shell to execute: "(clisp -q -c test.lisp) &> /var/folders/zs/xl3rmn054_l6td2l5g20vkc00000gn/T/vf2Zzoe/5"
line 38: 
line 39:     " restore environment variables {{{3
line 40:     let $LC_ALL = old_lc_all
line 41:     let $LC_MESSAGES = old_lc_messages
line 42:     if len(env_save)
line 43:         for key in keys(env_save)
line 44:             exec 'let $' . key . ' = ' . string(env_save[key])
line 45:         endfor
line 46:     endif
line 47:     " }}}3
line 48: 
line 49:     call syntastic#log#debug(g:SyntasticDebugLoclist, 'checker output:', err_lines)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug(2, 'checker output:', [';; Compiling file /Users/leostera/r...b/test.fas', '0 errors, 0 warnings', ''])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 50: 
line 51:     if has_key(a:options, 'Preprocess')
line 52:         let err_lines = call(a:options['Preprocess'], [err_lines])
line 53:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'preprocess (external):', err_lines)
line 54:     elseif has_key(a:options, 'preprocess')
line 55:         let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
line 56:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'preprocess:', err_lines)
line 57:     endif
line 58:     lgetexpr err_lines
line 59: 
line 60:     let errors = deepcopy(getloclist(0))
line 61: 
line 62:     if has_key(a:options, 'cwd')
line 63:         execute 'lcd ' . fnameescape(old_cwd)
line 64:     endif
line 65: 
line 66:     silent! lolder
error list 1 of 2; 0 errors
line 67: 
line 68:     " restore options {{{3
line 69:     let &errorformat = old_errorformat
line 70:     let &l:errorformat = old_local_errorformat
line 71:     let &shellredir = old_shellredir
line 72:     let &shell = old_shell
line 73:     " }}}3
line 74: 
line 75:     if !s:running_windows && (s:uname() =~ "FreeBSD" || s:uname() =~ "OpenBSD")
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname()

line 1:     if !exists('s:uname')
line 2:         let s:uname = system('uname')
line 3:         lockvar s:uname
line 4:     endif
line 5:     return s:uname
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname returning 'Darwin^@'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname()

line 1:     if !exists('s:uname')
line 2:         let s:uname = system('uname')
line 3:         lockvar s:uname
line 4:     endif
line 5:     return s:uname
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_uname returning 'Darwin^@'

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 76:         call syntastic#util#redraw(g:syntastic_full_redraws)
line 77:     endif
line 78: 
line 79:     call syntastic#log#debug(g:SyntasticDebugLoclist, 'raw loclist:', errors)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug(2, 'raw loclist:', [])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 80: 
line 81:     if syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#util#var('exit_checks')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 82:         throw 'Syntastic: checker error'
line 83:     endif
line 84: 
line 85:     if has_key(a:options, 'defaults')
line 86:         call s:addToErrors(errors, a:options['defaults'])
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_addToErrors([], {'bufnr': 1})

line 1:     for err in a:errors
line 2:         for key in keys(a:options)
line 3:             if !has_key(err, key) || empty(err[key])
line 4:                 let err[key] = a:options[key]
line 5:             endif
line 6:         endfor
line 7:     endfor
line 8: 
line 9:     return a:errors
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake..<SNR>29_addToErrors returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake

line 87:     endif
line 88: 
line 89:     " Add subtype info if present.
line 90:     if has_key(a:options, 'subtype')
line 91:         call s:addToErrors(errors, { 'subtype': a:options['subtype'] })
line 92:     endif
line 93: 
line 94:     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
line 95:         for rule in a:options['Postprocess']
line 96:             let errors = call(rule, [errors])
line 97:         endfor
line 98:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'postprocess (external):', errors)
line 99:     elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
line 100:         for rule in a:options['postprocess']
line 101:             let errors = call('syntastic#postprocess#' . rule, [errors])
line 102:         endfor
line 103:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'postprocess:', errors)
line 104:     endif
line 105: 
line 106:     return errors
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList..SyntasticMake returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..SyntaxCheckers_lisp_clisp_GetLocList returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 4:         call syntastic#log#debug(g:SyntasticDebugTrace, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug(1, 'getLocList: checker lisp/clisp returned 0')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(1)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 5:     catch /\m\C^Syntastic: checker error$/
line 6:         let list = []
line 7:         call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
line 8:     endtry
line 9:     call self._populateHighlightRegexes(list)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..22([])

line 1:     if has_key(self, '_highlightRegexFunc')
line 2:         for e in a:errors
line 3:             if e['valid']
line 4:                 let term = self._highlightRegexFunc(e)
line 5:                 if term != ''
line 6:                     let e['hl'] = term
line 7:                 endif
line 8:             endif
line 9:         endfor
line 10:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..22 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 10:     call syntastic#log#debug(g:SyntasticDebugLoclist, name . ' raw:', list)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug(2, 'lisp/clisp raw:', [])

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 11:     call self._quietMessages(list)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21([])

line 1:     " wildcard quiet_messages
line 2:     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var('quiet_messages', {})

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var returning {}

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21

line 3:     if type(quiet_filters) != type({})
line 4:         call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
line 5:         unlet quiet_filters
line 6:         let quiet_filters = {}
line 7:     endif
line 8: 
line 9:     " per checker quiet_messages
line 10:     let name = self._filetype . '_' . self._name
line 11:     try
line 12:         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var('lisp_clisp_quiet_messages', {})

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#util#var returning {}

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21

line 13:     catch /\m^Vim\%((\a\+)\)\=:E712/
line 14:         call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
line 15:     endtry
line 16: 
line 17:     call syntastic#log#debug(g:SyntasticDebugLoclist, 'quiet_messages filter:', quiet_filters)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug(2, 'quiet_messages filter:', {})

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21

line 18: 
line 19:     if !empty(quiet_filters)
line 20:         call syntastic#util#dictFilter(a:errors, quiet_filters)
line 21:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'filtered by quiet_messages:', a:errors)
line 22:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15..21 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15

line 12:     return list
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..15 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..35([])

line 1:     let newObj = copy(self)
line 2: 
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
line 4: 
line 5:     for e in llist
line 6:         if get(e, 'type', '') == ''
line 7:             let e['type'] = 'E'
line 8:         endif
line 9:     endfor
line 10: 
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16: 
line 17:     return newObj
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16..35 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..16 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 35: 
line 36:             if !loclist.isEmpty()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..39 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 37:                 if decorate_errors
line 38:                     call loclist.decorate(cname)
line 39:                 endif
line 40:                 call add(names, cname)
line 41:                 if checker.getWantSort() && !sort_aggregated_errors
line 42:                     call loclist.sort()
line 43:                     call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', loclist)
line 44:                 endif
line 45: 
line 46:                 let newLoclist = newLoclist.extend(loclist)
line 47: 
line 48:                 if !aggregate_errors
line 49:                     break
line 50:                 endif
line 51:             endif
line 52:         endfor
line 24:         for checker in clist
line 25:             let cname = checker.getFiletype() . '/' . checker.getName()
line 26:             if !checker.isAvailable()
line 27:                 call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Checker ' . cname . ' is not available')
line 28:                 let unavailable_checkers += 1
line 29:                 continue
line 30:             endif
line 31: 
line 32:             call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Invoking checker: ' . cname)
line 33: 
line 34:             let loclist = checker.getLocList()
line 35: 
line 36:             if !loclist.isEmpty()
line 37:                 if decorate_errors
line 38:                     call loclist.decorate(cname)
line 39:                 endif
line 40:                 call add(names, cname)
line 41:                 if checker.getWantSort() && !sort_aggregated_errors
line 42:                     call loclist.sort()
line 43:                     call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', loclist)
line 44:                 endif
line 45: 
line 46:                 let newLoclist = newLoclist.extend(loclist)
line 47: 
line 48:                 if !aggregate_errors
line 49:                     break
line 50:                 endif
line 51:             endif
line 52:         endfor
line 53: 
line 54:         " set names {{{3
line 55:         if !empty(names)
line 56:             if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
line 57:                 let type = substitute(names[0], '\m/.*', '', '')
line 58:                 let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
line 59:                 call newLoclist.setName( name . ' ('. type . ')' )
line 60:             else
line 61:                 " checkers from mixed types
line 62:                 call newLoclist.setName(join(names, ', '))
line 63:             endif
line 64:         endif
line 65:         " }}}3
line 66: 
line 67:         " issue warning about no active checkers {{{3
line 68:         if len(clist) == unavailable_checkers
line 69:             if !empty(a:checker_names)
line 70:                 if len(a:checker_names) == 1
line 71:                     call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
line 72:                 else
line 73:                     call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
line 74:                 endif
line 75:             else
line 76:                 call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: no checkers available for ' . &filetype)
line 77:             endif
line 78:         endif
line 79:         " }}}3
line 80: 
line 81:         call syntastic#log#debug(g:SyntasticDebugLoclist, 'aggregated:', newLoclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug(2, 'aggregated:', {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(2)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

line 82:         if sort_aggregated_errors
line 83:             call newLoclist.sort()
line 84:             call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', newLoclist)
line 85:         endif
line 86:     endif
line 87: 
line 88:     call newLoclist.deploy()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51()

line 1:     call self.setOwner(bufnr(''))
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..50(1)

line 1:     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..50 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51

line 2:     let self._stamp = syntastic#util#stamp()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..syntastic#util#stamp returning [1, 746607]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51

line 3:     for buf in self.getBuffers()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43()

line 1:     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43..syntastic#util#unique([1])

line 1:     let seen = {}
line 2:     let uniques = []
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 3:     for e in a:list
line 4:         if !has_key(seen, e)
line 5:             let seen[e] = 1
line 6:             call add(uniques, e)
line 7:         endif
line 8:     endfor
line 9:     return uniques
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43..syntastic#util#unique returning [1]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51..43 returning [1]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51

line 4:         call setbufvar(buf, 'syntastic_loclist', self)
line 5:     endfor
line 3:     for buf in self.getBuffers()
line 4:         call setbufvar(buf, 'syntastic_loclist', self)
line 5:     endfor
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors..51 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..<SNR>29_CacheErrors returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 14:     endif
line 15: 
line 16:     let loclist = g:SyntasticLoclist.current()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..36()

line 1:     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
line 2:         let b:syntastic_loclist = g:SyntasticLoclist.New([])
line 3:     endif
line 4:     return b:syntastic_loclist
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..36 returning {'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')}

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 17: 
line 18:     " populate loclist and jump {{{3
line 19:     let do_jump = syntastic#util#var('auto_jump')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#util#var('auto_jump')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#util#var returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 20:     if do_jump == 2
line 21:         let first = loclist.getFirstIssue()
line 22:         let type = get(first, 'type', '')
line 23:         let do_jump = type ==? 'E'
line 24:     endif
line 25: 
line 26:     let w:syntastic_loclist_set = 0
line 27:     if syntastic#util#var('always_populate_loc_list') || do_jump
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#util#var('always_populate_loc_list')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..syntastic#util#var returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

line 28:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: setloclist (new)')
line 29:         call setloclist(0, loclist.getRaw())
line 30:         let w:syntastic_loclist_set = 1
line 31:         if run_checks && do_jump && !loclist.isEmpty()
line 32:             call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: jump')
line 33:             silent! lrewind
line 34: 
line 35:             " XXX: Vim doesn't call autocmd commands in a predictible
line 36:             " order, which can lead to missing filetype when jumping
line 37:             " to a new file; the following is a workaround for the
line 38:             " resulting brain damage
line 39:             if &filetype == ''
line 40:                 silent! filetype detect
line 41:             endif
line 42:         endif
line 43:     endif
line 44:     " }}}3
line 45: 
line 46:     call s:notifiers.refresh(loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..39 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 2:         " loclist not fully constructed yet
line 3:         return
line 4:     endif
line 5: 
line 6:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: refresh')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug(4, 'notifiers: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..86()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..86..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..86..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..86

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..86 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40([])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
line 4:     endif
line 5:     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi([1, 746607], [])

line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'signs: refresh')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug(4, 'signs: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87

line 2:     let old_signs = copy(self._bufSignIds())
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..91()

line 1:     if !exists("b:syntastic_sign_ids")
line 2:         let b:syntastic_sign_ids = []
line 3:     endif
line 4:     return b:syntastic_sign_ids
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..91 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87

line 3:     if self.enabled()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..86()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..86..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..86..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..86

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..86 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87

line 4:         call self._signErrors(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..89({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let loclist = a:loclist
line 2:     if !loclist.isEmpty()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..89..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..89..39 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..89

line 3: 
line 4:         let buf = bufnr('')
line 5:         if !bufloaded(buf)
line 6:             " signs can be placed only in loaded buffers
line 7:             return
line 8:         endif
line 9: 
line 10:         " errors come first, so that they are not masked by warnings
line 11:         let issues = copy(loclist.errors())
line 12:         call extend(issues, loclist.warnings())
line 13:         call filter(issues, 'v:val["bufnr"] == buf')
line 14:         let seen = {}
line 15: 
line 16:         for i in issues
line 17:             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
line 18:                 let seen[i['lnum']] = 1
line 19: 
line 20:                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
line 21:                 let sign_subtype = get(i, 'subtype', '')
line 22:                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
line 23: 
line 24:                 execute "sign place " . s:next_sign_id . " line=" . i['lnum'] . " name=" . sign_type . " buffer=" . i['bufnr']
line 25:                 call add(self._bufSignIds(), s:next_sign_id)
line 26:                 let s:next_sign_id += 1
line 27:             endif
line 28:         endfor
line 29:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..89 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87

line 5:     endif
line 6:     call self._removeSigns(old_signs)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..90([])

line 1:     if has('signs')
line 2:         for s in reverse(copy(a:ids))
line 3:             execute "sign unplace " . s
line 4:             call remove(self._bufSignIds(), index(self._bufSignIds(), s))
line 5:         endfor
line 6:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87..90 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..87 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp returning [1, 748149]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..7()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..7..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..7..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..7

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..7 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40([])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
line 4:     endif
line 5:     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi([1, 746607], [])

line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40..syntastic#util#compareLexi returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..40 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     let b:syntastic_balloons = {}
line 2:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8..7()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8..7..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8..7..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8..7

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8..7 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8..39 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8

line 3:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: refresh')
line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
line 6:         if !empty(issues)
line 7:             for i in issues
line 8:                 if has_key(b:syntastic_balloons, i['lnum'])
line 9:                     let b:syntastic_balloons[i['lnum']] .= "\n" . i['text']
line 10:                 else
line 11:                     let b:syntastic_balloons[i['lnum']] = i['text']
line 12:                 endif
line 13:             endfor
line 14:             set beval bexpr=SyntasticBalloonsExprNotifier()
line 15:         endif
line 16:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..8 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..syntastic#util#stamp returning [1, 748696]

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..30()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..30..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..30..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..30

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..30 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if self.enabled()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..30()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..30..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..30..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..30

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..30 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: refresh')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug(4, 'highlighting: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31

line 3:         call self._reset()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..34()

line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..34 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31

line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..41()

line 1:     return copy(self._rawLoclist)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31..41 returning []

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31

line 6:         for item in issues
line 7:             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
line 8: 
line 9:             " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
line 10:             " used to override default highlighting.
line 11:             if has_key(item, 'hl')
line 12:                 call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
line 13:             elseif get(item, 'col', 0)
line 14:                 if get(item, 'vcol', 0)
line 15:                     let lastcol = virtcol([item['lnum'], '$'])
line 16:                     let coltype = 'v'
line 17:                 else
line 18:                     let lastcol = col([item['lnum'], '$'])
line 19:                     let coltype = 'c'
line 20:                 endif
line 21:                 let lcol = min([lastcol, item['col']])
line 22: 
line 23:                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
line 24:             endif
line 25:         endfor
line 26:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..31 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..26()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..26..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..26..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..26

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..26 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27..26()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27..26..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27..26..syntastic#util#var returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27..26

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27..26 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27

calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27..39 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: refresh')
line 3:         let b:syntastic_messages = copy(a:loclist.messages(bufnr('')))
line 4:         let b:syntastic_line = -1
line 5:         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
line 6:         autocmd! syntastic CursorMoved
line 7:         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
line 8:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..27 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: refresh')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug(4, 'autoloclist: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4

line 2:     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5({'_sorted': 0, 'decorate': function('..._columns': 1, 'setName': function('48')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: toggle')
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug(4, 'autoloclist: toggle')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug..<SNR>56__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug..<SNR>56__isDebugEnabled_smart returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug

line 2:         return
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#log#debug returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5

line 2:     if !a:loclist.isEmpty()
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..39()

line 1:     return empty(self._rawLoclist)
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..39 returning #1

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5

line 3:         if syntastic#util#var('auto_loc_list') == 1
line 4:             call a:loclist.show()
line 5:         endif
line 6:     else
line 7:         if syntastic#util#var('auto_loc_list') > 0
calling function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#util#var('auto_loc_list')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5..syntastic#util#var returning #2

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5

line 8: 
line 9:             "TODO: this will close the loc list window if one was opened by
line 10:             "something other than syntastic
line 11:             lclose
line 12:         endif
line 13:     endif
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4..5 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71..4 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors..71 returning #0

continuing in function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors

function <SNR>29_BufWritePostHook..<SNR>29_UpdateErrors returning #0

continuing in function <SNR>29_BufWritePostHook

function <SNR>29_BufWritePostHook returning #0

continuing in BufWritePost Auto commands for "*"

Executing BufWritePost Auto commands for "*"
autocommand if gettabvar(tabpagenr(), 'gitgutter_didtabenter')|   call settabvar(tabpagenr(), 'gitgutter_didtabenter', 0)| else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif

line 0: if gettabvar(tabpagenr(), 'gitgutter_didtabenter')|   call settabvar(tabpagenr(), 'gitgutter_didtabenter', 0)| else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
line 0:    call settabvar(tabpagenr(), 'gitgutter_didtabenter', 0)| else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
line 0:  else|   call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
line 0:    call gitgutter#process_buffer(gitgutter#utility#current_file(), 0)| endif
calling function gitgutter#utility#current_file()

line 1:   return expand('%:p')
function gitgutter#utility#current_file returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in BufWritePost Auto commands for "*"

calling function gitgutter#process_buffer('/Users/leostera/repos/leostera/lisp-db/test.lisp', 0)

line 1:   call gitgutter#utility#set_file(a:file)
calling function gitgutter#process_buffer..gitgutter#utility#set_file('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   let s:file = a:file
function gitgutter#process_buffer..gitgutter#utility#set_file returning #0

continuing in function gitgutter#process_buffer

line 2:   if gitgutter#utility#is_active()
calling function gitgutter#process_buffer..gitgutter#utility#is_active()

line 1:   return g:gitgutter_enabled && gitgutter#utility#exists_file()
calling function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file()

line 1:   return filereadable(gitgutter#utility#file())
calling function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file..gitgutter#utility#file()

line 1:   return s:file
function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file..gitgutter#utility#file returning '/Users/leostera/repos/leostera/lisp-db/test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file

function gitgutter#process_buffer..gitgutter#utility#is_active..gitgutter#utility#exists_file returning #1

continuing in function gitgutter#process_buffer..gitgutter#utility#is_active

function gitgutter#process_buffer..gitgutter#utility#is_active returning #1

continuing in function gitgutter#process_buffer

line 3:     if g:gitgutter_sign_column_always
line 4:       call gitgutter#sign#add_dummy_sign()
line 5:     endif
line 6:     try
line 7:       if !a:realtime || gitgutter#utility#has_fresh_changes(a:file)
line 8:         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(a:file), 1)
calling function gitgutter#process_buffer..gitgutter#utility#has_unsaved_changes('/Users/leostera/repos/leostera/lisp-db/test.lisp')

line 1:   return getbufvar(a:file, "&mod")
function gitgutter#process_buffer..gitgutter#utility#has_unsaved_changes returning #0

continuing in function gitgutter#process_buffer

calling function gitgutter#process_buffer..gitgutter#diff#run_diff(0, 1)

line 1:   " Wrap compound command in parentheses to make Windows happy.
line 2:   let cmd = '(git ls-files --error-unmatch ' . gitgutter#utility#shellescape(gitgutter#utility#filename()) . ' && ('
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename()

line 1:   return fnamemodify(s:file, ':t')
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape('test.lisp')

line 1:   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
line 2:     return a:arg
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 3: 
line 4:   if a:realtime
line 5:     let blob_name = ':' . gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
line 6:     let blob_file = tempname()
line 7:     let cmd .= 'git show ' . blob_name . ' > ' . blob_file . ' && diff -U0 ' . g:gitgutter_diff_args . ' ' . blob_file . ' - '
line 9:   else
line 10:     let cmd .= 'git diff --no-ext-diff --no-color -U0 ' . g:gitgutter_diff_args . ' ' . gitgutter#utility#shellescape(gitgutter#utility#filename())
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename()

line 1:   return fnamemodify(s:file, ':t')
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#filename returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape('test.lisp')

line 1:   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
line 2:     return a:arg
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shellescape returning 'test.lisp'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 11:   endif
line 12: 
line 13:   if a:use_external_grep && s:grep_available
line 14:     let cmd .= s:grep_command
line 15:   endif
line 16: 
line 17:   if (a:use_external_grep && s:grep_available) || a:realtime
line 18:     " grep exits with 1 when no matches are found; diff exits with 1 when
line 19:     " differences are found.  However we want to treat non-matches and
line 20:     " differences as non-erroneous behaviour; so we OR the command with one
line 21:     " which always exits with success (0).
line 22:     let cmd.= ' || exit 0'
line 23:   endif
line 24: 
line 25:   let cmd .= '))'
line 26: 
line 27:   if a:realtime
line 28:     let diff = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(cmd), gitgutter#utility#buffer_contents())
line 29:   else
line 30:     let diff = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(cmd))
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file('(git ls-files --error-unmatch test.l...est.lisp | grep -e ''^@@ '' || exit 0))')

line 1:   return 'cd ' . gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()) . ' && ' . a:cmd
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#directory_of_file()

line 1:   return fnamemodify(s:file, ':h')
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#directory_of_file returning '/Users/leostera/repos/leostera/lisp-db'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#shellescape('/Users/leostera/repos/leostera/lisp-db')

line 1:   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
line 2:     return a:arg
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file..gitgutter#utility#shellescape returning '/Users/leostera/repos/leostera/lisp-db'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file

function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#command_in_directory_of_file returning 'cd /Users/leostera/repos/leostera/li...est.lisp | grep -e ''^@@ '' || exit 0))'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system('cd /Users/leostera/repos/leostera/li...est.lisp | grep -e ''^@@ '' || exit 0))')

line 1:   if gitgutter#utility#using_xolox_shell()
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system..gitgutter#utility#using_xolox_shell()

line 1:   if s:using_xolox_shell == -1
line 2:     if !g:gitgutter_avoid_cmd_prompt_on_windows
line 3:       let s:using_xolox_shell = 0
line 4:     " Although xolox/vim-shell works on both windows and unix we only want to use
line 5:     " it on windows.
line 6:     elseif has('win32') || has('win64') || has('win32unix')
line 7:       let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
line 8:     else
line 9:       let s:using_xolox_shell = 0
line 10:     endif
line 11:   endif
line 12:   return s:using_xolox_shell
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system..gitgutter#utility#using_xolox_shell returning #0

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system

line 2:     let options = {'command': a:cmd, 'check': 0}
line 3:     if a:0 > 0
line 4:       let options['stdin'] = a:1
line 5:     endif
line 6:     let ret = xolox#misc#os#exec(options)
line 7:     let output = join(ret.stdout, "\n")
line 8:     let s:exit_code = ret.exit_code
line 9:   else
line 10:     let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
Calling shell to execute: "(cd /Users/leostera/repos/leostera/lisp-db && (git ls-files --error-unmatch test.lisp && (git diff --no-ext-diff --no-color -U0  test.lisp | grep -e '^@@ ' || exit 0))) >/var/folders/zs/xl3rmn054_l6td2l5g20vkc00000gn/T/vf2Zzoe/6 2>&1"
line 11:   endif
line 12:   return output
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#system returning 'error: pathspec ''test.lisp'' did no... git.^@Did you forget to ''git add''?^@'

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 31:   endif
line 32: 
line 33:   if gitgutter#utility#shell_error()
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error()

line 1:   return gitgutter#utility#using_xolox_shell() ? s:exit_code : v:shell_error
calling function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error..gitgutter#utility#using_xolox_shell()

line 1:   if s:using_xolox_shell == -1
line 2:     if !g:gitgutter_avoid_cmd_prompt_on_windows
line 3:       let s:using_xolox_shell = 0
line 4:     " Although xolox/vim-shell works on both windows and unix we only want to use
line 5:     " it on windows.
line 6:     elseif has('win32') || has('win64') || has('win32unix')
line 7:       let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
line 8:     else
line 9:       let s:using_xolox_shell = 0
line 10:     endif
line 11:   endif
line 12:   return s:using_xolox_shell
function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error..gitgutter#utility#using_xolox_shell returning #0

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error

function gitgutter#process_buffer..gitgutter#diff#run_diff..gitgutter#utility#shell_error returning #1

continuing in function gitgutter#process_buffer..gitgutter#diff#run_diff

line 34:     " A shell error indicates the file is not tracked by git (unless something
line 35:     " bizarre is going on).
line 36:     throw 'diff failed'
Exception thrown: diff failed

function gitgutter#process_buffer..gitgutter#diff#run_diff aborted

continuing in function gitgutter#process_buffer

line 9:         call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(diff))
line 10:         let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
line 11: 
line 12:         if len(modified_lines) > g:gitgutter_max_signs
line 13:           call gitgutter#utility#warn('exceeded maximum number of signs (configured by g:gitgutter_max_signs).')
line 14:           call gitgutter#sign#clear_signs(a:file)
line 15:           return
line 16:         endif
line 17: 
line 18:         if g:gitgutter_signs || g:gitgutter_highlight_lines
line 19:           call gitgutter#sign#update_signs(a:file, modified_lines)
line 20:         endif
line 21: 
line 22:         call gitgutter#utility#save_last_seen_change(a:file)
line 23:       endif
line 24:     catch /diff failed/
Exception caught: diff failed

line 25:       call gitgutter#hunk#reset()
calling function gitgutter#process_buffer..gitgutter#hunk#reset()

line 1:   let s:summary = [0, 0, 0]  " TODO: is bling/airline expecting [-1, -1, -1]?
function gitgutter#process_buffer..gitgutter#hunk#reset returning #0

continuing in function gitgutter#process_buffer

line 26:     endtry
Exception finished: diff failed

line 27:   else
line 28:     call gitgutter#hunk#reset()
line 29:   endif
function gitgutter#process_buffer returning #0

continuing in BufWritePost Auto commands for "*"

line 0:  endif
Executing BufWritePost Auto commands for "*"
autocommand cal s:record(expand('<abuf>', 1))

line 0: cal s:record(expand('<abuf>', 1))
calling function <SNR>36_record('1')

line 1: ^Iif s:locked | retu | en
line 1:  retu | en
line 1:  en
line 2: ^Ilet bufnr = a:bufnr + 0
line 3: ^Ilet bufname = bufname(bufnr)
line 4: ^Iif bufnr > 0 && !empty(bufname)
line 5: ^I^Ical filter(s:mrbs, 'v:val != bufnr')
line 6: ^I^Ical insert(s:mrbs, bufnr)
line 7: ^I^Ical s:addtomrufs(bufname)
calling function <SNR>36_record..<SNR>36_addtomrufs('test.lisp')

line 1: ^Ilet fn = fnamemodify(a:fname, ':p')
line 2: ^Ilet fn = exists('+ssl') ? tr(fn, '/', '\') : fn
line 3: ^Iif ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
line 3:  retu
line 5: ^Ien
line 6: ^Ilet idx = index(s:mrufs, fn, 0, !{s:cseno})
line 7: ^Iif idx
line 8: ^I^Ical filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
line 9: ^I^Ical insert(s:mrufs, fn)
line 10: ^I^Iif {s:soup} && idx < 0
line 11: ^I^I^Ical s:savetofile(s:mergelists())
line 12: ^I^Ien
line 13: ^Ien
function <SNR>36_record..<SNR>36_addtomrufs returning #0

continuing in function <SNR>36_record

line 8: ^Ien
function <SNR>36_record returning #0

continuing in BufWritePost Auto commands for "*"

Executing BufWinLeave Auto commands for "*"
autocommand execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')

line 0: execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0: 
Executing BufWinLeave Auto commands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
calling function <SNR>32_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>32_can_diffoff returning #0

continuing in BufWinLeave Auto commands for "*"

line 0:    call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 0:  endif
Executing VimLeavePre Auto commands for "*"
autocommand cal s:savetofile(s:mergelists())

line 0: cal s:savetofile(s:mergelists())
calling function <SNR>36_mergelists()

line 1: ^Ilet diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
calling function <SNR>36_mergelists..ctrlp#mrufiles#cachefile()

line 1: ^Iif !exists('s:cadir') || !exists('s:cafile')
line 2: ^I^Ilet s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
line 3: ^I^Ilet s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
line 4: ^Ien
line 5: ^Iretu s:cafile
function <SNR>36_mergelists..ctrlp#mrufiles#cachefile returning '/Users/leostera/.cache/ctrlp/mru/cache.txt'

continuing in function <SNR>36_mergelists

calling function <SNR>36_mergelists..ctrlp#utils#readfile('/Users/leostera/.cache/ctrlp/mru/cache.txt')

line 1: ^Iif filereadable(a:file)
line 2: ^I^Ilet data = readfile(a:file)
line 3: ^I^Iif empty(data) || type(data) != 3
line 4: ^I^I^Iunl data
line 5: ^I^I^Ilet data = []
line 6: ^I^Ien
line 7: ^I^Iretu data
function <SNR>36_mergelists..ctrlp#utils#readfile returning ['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb']

continuing in function <SNR>36_mergelists

line 2: ^Ical filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
line 3: ^Ilet mrufs = s:mrufs + diskmrufs
line 4: ^Iretu s:chop(mrufs)
calling function <SNR>36_mergelists..<SNR>36_chop(['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb'])

line 1: ^Iif len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
line 1:  cal remove(a:mrufs, {s:max}, -1) | en
line 1:  en
line 2: ^Iretu a:mrufs
function <SNR>36_mergelists..<SNR>36_chop returning ['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb']

continuing in function <SNR>36_mergelists

function <SNR>36_mergelists returning ['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb']

continuing in VimLeavePre Auto commands for "*"

calling function <SNR>36_savetofile(['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb'])

line 1: ^Ical ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)
calling function <SNR>36_savetofile..ctrlp#utils#writecache(['/Users/leostera/repos/leostera/lisp...ews/lawyer_mailer/notify_jobs.html.erb'], '/Users/leostera/.cache/ctrlp/mru', '/Users/leostera/.cache/ctrlp/mru/cache.txt')

line 1: ^Iif isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
calling function <SNR>36_savetofile..ctrlp#utils#writecache..ctrlp#utils#mkdir('/Users/leostera/.cache/ctrlp/mru')

line 1: ^Iif exists('*mkdir') && !isdirectory(a:dir)
line 2: ^I^Isil! cal mkdir(a:dir, 'p')
line 3: ^Ien
line 4: ^Iretu a:dir
function <SNR>36_savetofile..ctrlp#utils#writecache..ctrlp#utils#mkdir returning '/Users/leostera/.cache/ctrlp/mru'

continuing in function <SNR>36_savetofile..ctrlp#utils#writecache

line 2: ^I^Isil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
line 3: ^Ien
function <SNR>36_savetofile..ctrlp#utils#writecache returning #0

continuing in function <SNR>36_savetofile

function <SNR>36_savetofile returning #0

continuing in VimLeavePre Auto commands for "*"

Executing VimLeavePre Auto commands for "*"
autocommand :py powerline.shutdown()

line 0: :py powerline.shutdown()
Writing viminfo file "/Users/leostera/.viminfo"